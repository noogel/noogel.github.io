<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)">
<meta name="generator" content="Hexo 7.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/resource/img/favicon2018.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/resource/img/favicon2018.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/resource/img/favicon2018.png">
  <link rel="mask-icon" href="/resource/img/favicon2018.png" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"noogel.xyz","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.8.2","exturl":false,"sidebar":{"position":"left","display":"hide","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta property="og:type" content="website">
<meta property="og:title" content="知一杂谈">
<meta property="og:url" content="https://noogel.xyz/page/5/index.html">
<meta property="og:site_name" content="知一杂谈">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="noogel">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://noogel.xyz/page/5/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/5/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>知一杂谈</title>
  

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?9cdc9a11cbd242c6336b07c464d8820c"></script>



  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="知一杂谈" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">知一杂谈</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">我思故我在</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-career"><a href="/career/" rel="section"><i class="sitemap fa-fw"></i>├ 技术</a></li>
        <li class="menu-item menu-item-life"><a href="/life/" rel="section"><i class="sitemap fa-fw"></i>├ 生活</a></li>
        <li class="menu-item menu-item-future"><a href="/future/" rel="section"><i class="sitemap fa-fw"></i>└ 未来</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">noogel</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">86</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">37</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/noogel" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;noogel" rel="noopener" target="_blank"><i class="github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:noogel@163.com" title="E-Mail → mailto:noogel@163.com" rel="noopener" target="_blank"><i class="envelope fa-fw"></i></a>
      </span>
  </div>



        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://noogel.xyz/2020/03/05/1.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="noogel">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知一杂谈">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/03/05/1.html" class="post-title-link" itemprop="url">设计模式与设计原则</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-03-05 00:00:00" itemprop="dateCreated datePublished" datetime="2020-03-05T00:00:00+00:00">2020-03-05</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><p>如果把设计模式理解为优秀软件系统模块设计的最小抽象，那么设计原则就是这些抽象的指导思想。目的是设计一个易于扩展和维护的系统。设计模式的六大原则有：</p>
<ul>
<li>Single Responsibility Principle：单一职责原则</li>
<li>Open Closed Principle：开闭原则</li>
<li>Liskov Substitution Principle：里氏替换原则</li>
<li>Law of Demeter：迪米特法则</li>
<li>Interface Segregation Principle：接口隔离原则</li>
<li>Dependence Inversion Principle：依赖倒置原则</li>
</ul>
<h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><p>应该有且只有一个原因引起类的变化，一个类只负责一个职责。一个功能应该要划分成多少个职责类去实现，并没有明显的限定。举例说明对于用户管理，用户信息管理和用户行为管理可以做初步拆分，用户信息管理又可以拆分成普通信息维护和敏感信息的维护。又比如用户发生一笔支付行为可以初步拆分为交易信息管理和支付信息管理。职责划分的粗细的影响因素有对于业务理解程度、项目开发阶段等，过粗会造成一个处理类包含太多职责，过细又会增加开发维护成本。单一职责是“高内聚低耦合”设计的一种实现形式，单一职责即为同一职责内部的内聚性，降低不同职责之间的耦合性。</p>
<h3 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h3><p>描述继承关系，子类全部实现或继承父类方法，子类可以扩展父类方法实现，将子类替换父类不会产生异常。在重构角度来说如果多个子类拥有相同的行为，可以将相同行为提取到父类实现，子类调用扩展父类实现。在开发上基于“组合大于继承”的原则，通过定义实现接口的形成被其它类调用。违反这个原则不一定会产生严重后果，但是会对后面的开发维护造成困难。</p>
<h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><p>描述的是对于需求产生变化后，软件实体部分应该进行扩展开发，避免修改。通过扩展实体行为来响应需求变化，而不是通过修改现有软件代码。</p>
<h3 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h3><p>描述的是一个对象应该进行减少对于其它对象的理解。通过封装我们可以屏蔽类内部逻辑，只提供足够用且少量的方法来给外部使用，降低对象之间的耦合性。当一个接口或者一个对象被公开，意味着后面我们进行开发和维护的时候很难再将这个对象收回，重构内部逻辑时也会更加困难。</p>
<h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><p>描述的是建立单一的接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量行为统一，避免臃肿。对于支付接口来说，定义类通用支付方法，对于获取分期支付信息也属于支付行为的一个环节，但不是所有实体类必须要实现的，可以拆分出来。</p>
<h3 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h3><p>描述的是实现类之间不能直接发生依赖关系，其依赖关系是通过接口或者抽象类产生，即面向接口编程。实现类依赖接口或者抽象类，而接口或者抽象类不依赖实现类。</p>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://design-patterns.readthedocs.io/zh_CN/latest/index.html">https://design-patterns.readthedocs.io/zh_CN/latest/index.html</a></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://noogel.xyz/2020/01/20/1.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="noogel">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知一杂谈">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/01/20/1.html" class="post-title-link" itemprop="url">我的 2019 年</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-01-20 00:00:00" itemprop="dateCreated datePublished" datetime="2020-01-20T00:00:00+00:00">2020-01-20</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="一些小的点"><a href="#一些小的点" class="headerlink" title="一些小的点"></a>一些小的点</h2><ol>
<li>坚持阅读英文技术资料，并至少翻译12篇技术文章。x</li>
<li>戒掉熬夜的坏习惯，习惯性去健身，保持精力的充沛。60%</li>
<li>刻意提高专注力，并坚持系统性的做技术储备。80%</li>
<li>常出去走走，看看外面的世界，准备至少两次的远途旅行。100%</li>
<li>找到一个互相合适的伴侣。100%</li>
<li>趁年轻努力挣钱，但是不要透支身体。50%</li>
<li>好好学说话，做一个有趣的人。60%</li>
</ol>
<h2 id="主要方向"><a href="#主要方向" class="headerlink" title="主要方向"></a>主要方向</h2><ol>
<li>英语学习，坚持阅读英文技术资料，至少翻译12篇技术文章，基本的口语表达。x</li>
<li>沟通能力，说话前多思考，减少小动作的出现，改变不好的下意识动作和反应。50%</li>
<li>正确锻炼，学会并养成跑步习惯，无氧健身增加身体健壮。90%</li>
</ol>
<h2 id="发音练习"><a href="#发音练习" class="headerlink" title="发音练习"></a>发音练习</h2><p>《张浩翔 魅力声音必修课》<br>预计学习时间 2 天，整理笔记，刻意练习。注意学习的几个阶段。</p>
<h2 id="做到了哪些"><a href="#做到了哪些" class="headerlink" title="做到了哪些"></a>做到了哪些</h2><ol>
<li>考了救护员证</li>
<li>去了天津、昆明、大理、丹东</li>
<li>跑了马拉松</li>
<li>去山顶露营</li>
</ol>
<p><a href="/2019/12/01/2.html">第一个半马</a></p>
<p><img src="/resource/img/15782140217189.jpg"></p>
<p><a href="/2019/11/30/1.html">云南之旅</a></p>
<p><img src="/resource/img/15751048275862.jpg"></p>
<p><a href="/2020/01/11/1.html">丹东之旅</a></p>
<p><img src="/resource/img/15786784707412.jpg"></p>
<p>救护员证</p>
<p><img src="/resource/img/2021-07-01-01-50-07.png"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://noogel.xyz/2020/01/17/1.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="noogel">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知一杂谈">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/01/17/1.html" class="post-title-link" itemprop="url">2020知识储备计划</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-01-17 00:00:00" itemprop="dateCreated datePublished" datetime="2020-01-17T00:00:00+00:00">2020-01-17</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li>六本本职技术书籍&#x2F;专题<ul>
<li>effective java done 01.29</li>
<li>Java 并发编程实战  done 02.14</li>
<li>深入理解 Java 虚拟机 part 04.01</li>
<li>Java 性能优化 21 讲 done 12.01</li>
</ul>
</li>
<li>六本技术扩展书籍&#x2F;专题<ul>
<li>图解密码技术 第三版 done 10.08</li>
<li>Linux 内核设计与实现（原书第三版）</li>
<li>现代编译原理</li>
<li>数据密集型应用系统设计</li>
<li>MySQL 实战 45 讲 part 08.26</li>
<li>Wireshark 数据包分析实战（第 3 版） done 2020.12.13</li>
<li>实现领域驱动设计 part</li>
</ul>
</li>
<li>六本人文社科书籍<ul>
<li>精进 done 02.11</li>
<li>我的改变：个人现代化 40 年 done 09.27</li>
<li>高效 PDCA 工作术 done 09.16</li>
<li>薄世宁医学通识讲义 done 10.20</li>
<li>这里是中国 done 10.05</li>
<li>活着 余华 done 12.10</li>
<li>论中国 基辛格 done </li>
<li>美国陷阱 done</li>
</ul>
</li>
<li>整理输出两篇高质量博客文章</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://noogel.xyz/2020/01/11/1.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="noogel">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知一杂谈">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/01/11/1.html" class="post-title-link" itemprop="url">丹东之旅</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-01-11 00:00:00" itemprop="dateCreated datePublished" datetime="2020-01-11T00:00:00+00:00">2020-01-11</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>丹东是中国的一个边境小城市，在东三省的辽宁，与朝鲜隔鸭绿江相望。丹东春秋去会比较好，还有点景色可以看看，冬天的话来泡温泉吧，还可以顺便来一趟朝鲜游，带着护照来就好了。可惜的是因为一些原因无法泡温泉和去趟朝鲜。所以只是趁着年末逃离下北京，换个环境放松一下，其它的不重要了。</p>
<p><img src="/resource/img/15786783058231.jpg"></p>
<p><img src="/resource/img/15786783449355.jpg"></p>
<p>丹东是个有山有水有美食的地方，来这边可以沿着鸭绿江散步，好奇的望望对面神秘的社会主义同僚。去趟鸭绿江美术馆、抗美援朝纪念馆之类的地方看看当地的人文。鸭绿江断桥是一定要去的，走上去一点点感受下当年的气息和脚下的滚滚江水，一座见证历史的铁桥。丹东的🍓很出名，冬天来了可以尝尝，味道还是很甜的。还有当地著名的全州拌饭馆，超级好吃绝对不是吹的，还有有名参鸡汤，夜里的烧烤。。。想想又饿了。</p>
<p><img src="/resource/img/15786783222921.jpg"></p>
<p>这里的夜景也还不错，丹东这个城市挺小的，发展还不错，赶上季节好可以来这里吃海鲜~</p>
<p><img src="/resource/img/15786784433586.jpg"></p>
<p><img src="/resource/img/15786784707412.jpg"></p>
<p><img src="/resource/img/15786786649467.jpg"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://noogel.xyz/2019/12/01/2.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="noogel">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知一杂谈">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/12/01/2.html" class="post-title-link" itemprop="url">第一个半马</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-12-01 00:00:00" itemprop="dateCreated datePublished" datetime="2019-12-01T00:00:00+00:00">2019-12-01</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>第一个半马…真的没啥挑战性，哈哈哈哈哈。</p>
<p>事情起源于表姐在群里问要不要去参加马拉松，她那有名额，然后就兴冲冲的报名了，报了个半马，然后开始了为期几个月的夜跑锻炼任务，从最初的慢悠悠的每天三公里，到逐步拔高的每次五公里，然后开始选鞋完善装备，提高到了十公里。因为家里有事中途中断了一些日子，之后就三天打鱼两天晒网的锻炼着，直到马拉松开始的那天。</p>
<p>周六早起动身，从北京出发到白洋淀站下车。迎着末夏的烈日，面对明天的半马，还是很兴奋的。都说出问题的都是跑半马的，因为半马大多是新手，不懂得如何把握自己身体和跑步强度，所以还是有点担心，就抱着玩玩看的心态去跑的。</p>
<p><img src="/resource/img/15782137244716.jpg"></p>
<p>半马路线图，从容城雄安市民服务中心出发一直跑到安新，全马则是跑到雄县。<br><img src="/resource/img/15782139652993.jpg"></p>
<p><img src="/resource/img/15782140046345.jpg"></p>
<p>第一个半马还算是比较轻松的跑过来了吧，期间粗心大意的没有把盐丸当回事，结果起跑就不力，心跳一直过速，直接影响了发挥，边跑变琢磨是怎么回事，后来觉得出汗多了，便找周围的人要了两粒盐丸，然后感觉心跳就慢慢的降到正常水平了。目标不高，完赛就好～，顺便拿起奖牌嘚瑟了一把。因为比赛在周日，担心第二天无法上班，其实多虑了，跑后做好充分的拉伸，第二天依然照常去上班了，腿也没有预期的酸痛，只是身体进行了一周左右的慢慢康复，身体的磨损在逐渐自我修复。</p>
<p><img src="/resource/img/15782140217189.jpg"></p>
<p><img src="/resource/img/15782154117780.jpg"></p>
<p><img src="/resource/img/15782154399317.jpg"></p>
<p>后面的时间可能不会再继续练跑步了，小区周围没有公园，只能在大街上跑，有比较多的尾气，感觉对身体不太好，然后买了辆山地准备以后骑行山间了。买后的一个周末独自骑行去了香山，前后 30 公里左右，感觉还不错，以后准备依赖这个了～</p>
<p><img src="/resource/img/15782154605761.jpg"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://noogel.xyz/2019/12/01/1.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="noogel">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知一杂谈">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/12/01/1.html" class="post-title-link" itemprop="url">语言栈转型经验谈</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-12-01 00:00:00" itemprop="dateCreated datePublished" datetime="2019-12-01T00:00:00+00:00">2019-12-01</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p><img src="/resource/img/15751828389282.jpg"></p>
<p>近一年都在做语言栈的转型，也注意到周围很多公司都在做相似的事情，大概的路径是 Python -&gt; Go -&gt; Java，转型的起因也是有诸多的因素，像 Python 这种开发速度快，执行相对慢的语言更适合中小型项目，加上国内语言生态不够成熟，项目做大了会发现大家一刀切的转到其它语言上，当然这些说的是在做 web 后端方向上，Python 在数据分析和人工智能方向上还是势头很猛的。Go 可能还是因为它能承载的并发更高，性能更好而逐渐流行起来。在并发模型上 Java 原生 API 使用上确实做得不好驾驭，Go 则要相对好用很多。还有在某些垂直领域上，Java 的生态已经很成熟，其它语言栈上则需要自己造轮子，相应对于开发人员的水平要求就会低很多了。</p>
<p>在当前互联网领域，后端研发做 web 主要谈的还是通过抽象和建模来提高项目的可迭代性与可维护性，另一方面谈的是工程实现上的优化和性能上的优化。在这些后面依赖的则是中台来保证的基础服务综合稳定性。</p>
<p>在语言栈转型中也踩过一些坑，遇到过一些小问题，当然这些也得益于一个相对靠谱的方案来保证迁移的安全，基于这些经验总结一下，在以后的迁移中使问题可预见和避免采坑。</p>
<h2 id="转型流程"><a href="#转型流程" class="headerlink" title="转型流程"></a>转型流程</h2><p>首先要明确转型的三个开发流程 MRO (Migration, Reconstruction, Optimization)</p>
<ul>
<li>迁移 就是把原语言代码照着抄一遍到新语言项目上，按照新语言的工程实现风格来做就可以。</li>
<li>重构 的目的是来提高项目代码的可维护性和可迭代性，让代码更加优雅和好读懂，可以放到迁移完成来做。</li>
<li>优化 则可以是在模块依赖、调用关系、接口字段等方面调整来降低项目的复杂性和提高合理性。</li>
</ul>
<p>然后看我们人力和时间是否充足，我想大部分情况下是不充足的，按照最短时间交付的原则，我们应该只做迁移流程，也就是说先对原有代码进行语言上的迁移，这样我们可以快速实现交付。在人力充沛的情况下可以配备两个小组，一个维护现有系统，一个主力开发新系统，或者说锁定需求全力开发新系统。在对快速交付更看中的行业里前一个方案更合适一些。</p>
<h2 id="交付流程"><a href="#交付流程" class="headerlink" title="交付流程"></a>交付流程</h2><p>在交付过程中的验证流程 <code>单测验证 -&gt; 测试环境功能验证 -&gt; QA生产回测 -&gt; 灰度验证 -&gt; 完全上线</code>。<br>只有功能和单测代码都迁移完才能算代码部分完成，需要优先保证单测行数覆盖率再去保证分支覆盖率，测试环境的功能验证需要覆盖所有 case 来保证大部分问题都被发现，然后进入小范围的灰度验证，之后逐步提高灰度比率直至完全上线。如果是纯读接口则可以直接进行异步校验，就是请求两遍，然后对比差异来不断的发现和修复 bug，直至问题收敛完全解决。<br>如果明确只做迁移，那么期间如果有发现旧逻辑的 bug 也不要管，这样才好去对比验证，验证通过上线后再去修复。只有通过明确目的和流程并且遵循这个流程做，才能更快的去交付。</p>
<h2 id="验证方案"><a href="#验证方案" class="headerlink" title="验证方案"></a>验证方案</h2><p><img src="/resource/img/15751818260554.jpg"></p>
<p>针对新代码的验证方案分为别为读写接口做不同的验证方案：</p>
<ul>
<li>读接口：异步请求到新接口做接口响应值校验，打印出差异数据，然后不断修正逻辑。这样可以避免在线上灰度造成数据的不一致。</li>
<li>写接口：测试用例覆盖，然后测试环境验证，灰度回测，灰度验证，修复问题，继续灰度验证。</li>
</ul>
<h3 id="平稳交付"><a href="#平稳交付" class="headerlink" title="平稳交付"></a>平稳交付</h3><p>在整个交付的过程中，转型前后对 SLA 要提供一致的保证，可以看看下面的几个衡量标准：</p>
<table>
<thead>
<tr>
<th>服务可用性级别</th>
<th>服务正常运行时间</th>
<th>年宕机时间</th>
<th>日宕机时间</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>90%</td>
<td>36.5day</td>
<td>2.4hour</td>
</tr>
<tr>
<td>2</td>
<td>99%</td>
<td>3.65day</td>
<td>14min</td>
</tr>
<tr>
<td>3</td>
<td>99.9%</td>
<td>8.76hour</td>
<td>86sec</td>
</tr>
<tr>
<td>4</td>
<td>99.99%</td>
<td>52.6min</td>
<td>8.6sec</td>
</tr>
<tr>
<td>5</td>
<td>99.999%</td>
<td>5.26min</td>
<td>0.86sec</td>
</tr>
<tr>
<td>6</td>
<td>99.9999%</td>
<td>31.5sec</td>
<td>8.6msec</td>
</tr>
</tbody></table>
<p><a target="_blank" rel="noopener" href="https://tool.lu/tables/">在线 MD 表格生成</a></p>
<p>一般 3 个 9 的可用性全年宕机时间约为 8.76 小时，针对不同系统不同用户规模对于系统可用性的要求不一样，边缘业务的要求可能会低一些，但是对于核心支付链路场景 TPS 可能不高，但是必须要求保证高可用级别。如何保证或者提升服务的 SLA 是我们接下来要探讨的目标，一般有下面两个影响因素：</p>
<ul>
<li>MTBF (Mean Time Between Failures) 系统服务平均故障时间间隔</li>
<li>MTTR (Mean Time To Recover) 系统服务平均故障恢复时长</li>
</ul>
<p>也就是说我们系统要尽可能的降低故障频率以及出现故障时能尽快的恢复。基于这两点我们在做系统平稳过渡时，要充分测试所有 case ，并且进行内部灰度方案和异步重试对比，发现异常立即回滚查找结局问题后再重新灰度。这里需要做到一键开关，数据可监控和追溯。</p>
<p>持续监控，感知系统稳定性的第一步就是监控，通过监控和系统日志来排查问题和及时响应处理。监控有两个层面，一个是基础设施提供的机器监控以及接口级别的响应稳定性监控，另一个是业务数据层面的多维度监控。系统日志按照等级大致分为 INFO 日志以及 ERROR 日志。</p>
<h3 id="快速交付"><a href="#快速交付" class="headerlink" title="快速交付"></a>快速交付</h3><p>关于快速交付，可以了解 下敏捷开发，及早和持续不断的交付有价值的软件。关于 Scrum 开发的介绍可以看： <a target="_blank" rel="noopener" href="http://www.scrumcn.com/agile/scrum-knowledge-library/agile101.html">什么是敏捷</a></p>
<h2 id="现状及未来"><a href="#现状及未来" class="headerlink" title="现状及未来"></a>现状及未来</h2><p><img src="/resource/img/15751828229085.jpg"></p>
<p>基于公司现状考虑 nginx 不支持长时间和自定义灰度，所以 http 接口层没做改动，只是在内部逻辑上通过 rpc 服务转到新的系统中。基于以上要点可以做到功能的快速交付。截止此文撰写时间，语言栈转型已经将系统核心接口逻辑 100% 迁移到新的系统上，对于日常系统需求已经可以做到在新系统开发和接入了。后面要做的有以下几点：</p>
<ol>
<li>将系统外围逻辑迁移到新系统；</li>
<li>不断监控降噪，细化监控粒度，继续提高服务的稳定性；</li>
<li>当前对于Python的花式“魔法” 硬翻译还需要不断重构和优化。</li>
<li>完善监控大盘，通过数据驱动来运营优化我们的流程；</li>
<li>项目复盘总结以及业务普及宣讲，提升人员对于业务细节的认知。</li>
</ol>
<h3 id="转型痛点"><a href="#转型痛点" class="headerlink" title="转型痛点"></a>转型痛点</h3><p>迁移后再做重构和优化过程。在迁移过程中有一个痛点是新需求过来了，要么锁定需求只做迁移，要么写两遍。基于人力情况可以选择一个小组同时写新旧系统或者一个小组维护新的一个小组维护旧的。<br>在转型过程中新需求过来有时要写两边，或者要把旧系统流量打到新系统接口上，常常在排查问题时遇到流量忘记转移的情况，所以在迁移过程要尽可能的快速交付上线。</p>
<h3 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h3><ol>
<li>对于每一位工程师来说语言栈的转型既是挑战也是机遇，只有保持开放学习心态，及时调整和提升才能更好应对，同时增强自身软素质。</li>
<li>当前互联网环境下分布式是必经之地，而系统绝非 100% 可靠，每一个环节可能的异常在上线后必定遇到，所以针对不同场景我们要在 AP 与 CP 之间做出选择。</li>
<li>对于支付交易核心链路，一条柱子肯定是不稳的，双链路也未必可靠，但至少更稳一些。曾经遇到过相隔几公里的两条光纤被施工队挖断的情况，双机房访问直接 gg 了，但总归是少见的。</li>
<li>提系统可用性要避免出问题，除了问题要快快快速响应恢复，有问题先回滚。</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://noogel.xyz/2019/11/30/1.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="noogel">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知一杂谈">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/11/30/1.html" class="post-title-link" itemprop="url">云南之旅</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-11-30 00:00:00" itemprop="dateCreated datePublished" datetime="2019-11-30T00:00:00+00:00">2019-11-30</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>多图预警！！！<br>多图预警！！！<br>多图预警！！！<br>多图预警！！！</p>
</blockquote>
<p>云南是一个离家好几千公里的地方。最初要去的想法是在一次同学聚会上大家商量的，结果到了十月一只有们两个人过来玩了，倒也好，制定行程和订票比较省事。于是，参加完同学婚礼就开始了我们的云南之旅，从国际庄直飞昆明。</p>
<p><img src="/resource/img/15751045317861.jpg"><br><img src="/resource/img/15751045387631.jpg"></p>
<p>去之前做攻略的时候并没有觉得昆明有什么好玩的地方，所以只是做了一天半的行程，要说昆明吃的地方也就是鲜花饼和米线了。对比过几家不同的，一个是花多纷的鲜花饼，另一个是建新园的米线不错。</p>
<p><img src="/resource/img/15751045473291.jpg"><br><img src="/resource/img/15751045562977.jpg"></p>
<p>玩的地方是真没觉得什么，然后就是去了云南省博物馆看了看，一般我到一个城市会先去了解下这个城市的历史和人文，博物馆建的是很恢弘有气势。看了看滇人、昆明人和汉人之间的历史渊源。</p>
<p><img src="/resource/img/15751045644302.jpg"><br><img src="/resource/img/15751045729460.jpg"><br><img src="/resource/img/15751045812265.jpg"></p>
<p>明明天还很早，博物馆就早早往外赶人了，算是逛了一半吧，然后看旁边有个官渡古镇，便抱着试试看的心态去逛了逛，果然跟预料的一样，纯粹的商业化街道让人不会再来第二次，就像北方的太行水镇、古北水镇，北京的王府井小吃街和天津的古文化街。。。</p>
<p><img src="/resource/img/15751045892406.jpg"></p>
<p>也许第一天太兴奋了吧，晚上不想回去，这边比北京在地理时区上差一个多小时。然后便跑去了云大看妹子，可惜到了都晚上了（😶），有大学地方就有小吃街，果然不出所料。</p>
<p><img src="/resource/img/15751046103704.jpg"></p>
<p>在昆明的第二天，睡了个懒觉，下午去的海埂公园看的滇池。不得不说，景色是真的不错，空气也很好，来到这里就是一场洗肺之旅。</p>
<p><img src="/resource/img/15751046189692.jpg"></p>
<p>海埂公园是从南到北的，可以遥望西山，走着走着不知不觉就想着去西山看看，站在山顶来俯瞰滇池和昆明应该很不错。就这样被什么驱使着，拿着地图导航，顺着一个不知名的小路就上⛰了。还真是曲径通幽处，好多次都给走错路了，因为真的挺偏。</p>
<p><img src="/resource/img/15751046257018.jpg"><br><img src="/resource/img/15751046325847.jpg"></p>
<p>山中刚下过雨路有点滑，望着遮住天空的树也不知道累，总归心情是很好的，空气也很好，想到这里总对比起北京令人头疼的雾霾天，天高皇帝远，有点不想回去了，在这种地方真的挺宜居的。</p>
<p><img src="/resource/img/15751046420805.jpg"></p>
<p>想看到的总归是要看到的，但不是在山顶，而是在爬山的某条路途中。</p>
<p><img src="/resource/img/15751046555743.jpg"></p>
<p>最后，爬到山顶是不能了，来的有点晚，得趁着天黑前下山回去，结果顺着某德导航走了一条崎岖山路，纯人工走出来的土路，崎岖泥泞，向前看不见头，向后难以攀爬。。。有点绝望了，真不知道这种路怎么会被收录并作为导航路线。。。大概是下图这样子的，真的是手脚并用出来的，最口看到村口灯光的时候特别的激动，是看到希望的激动😂。</p>
<p><img src="/resource/img/15751046702644.jpg"><br><img src="/resource/img/15751046775044.jpg"><br><img src="/resource/img/15751046843190.jpg"></p>
<p>已经很晚了，到了有人的地方赶紧打车回去市里找了个吃饭的地方。傣族风味，看评价还是挺地道的，发现和其它吃过的才来说，做法上好像没有太特别的地方，只是这里的都加了好多特别香味的香草。</p>
<p><img src="/resource/img/15751046944652.jpg"></p>
<p>要去的地方总归要去的，一个号称风花雪月的地方——大理，但是我要说与我和我的小伙伴无关。虽然我没有被过多的安利大理的美，但也还是抱着去放松的心态走一趟的。</p>
<p><img src="/resource/img/15751047021953.jpg"></p>
<p>后面几天的行程比较集中，便商量租了辆车，两个新手，开启了试车模式，尤其我这个拿本六年没摸过车的纯新手，还是比较紧张和激动的。。。我们开上了苍山，到过洱海，去过古镇（(⊙o⊙)…好像哪里不对），先练了半天车。</p>
<p><img src="/resource/img/15751047104251.jpg"><br><img src="/resource/img/15751047182887.jpg"><br><img src="/resource/img/15751047249600.jpg"></p>
<p>开过了洱海边的乡间小路、白族人的原始村镇，看到了一片金黄的稻田，如此没见过世面的我自己都很惊讶。。。</p>
<p><img src="/resource/img/15751047330258.jpg"><br><img src="/resource/img/15751047403680.jpg"><br><img src="/resource/img/15751047467681.jpg"><br><img src="/resource/img/15751047623159.jpg"><br><img src="/resource/img/15751047722235.jpg"><br><img src="/resource/img/15751047813440.jpg"></p>
<p>站在洱海边遥望苍山，哪些传说的爱情故事也只是传说，我所切实感受到的是景色真的很棒，随手一拍都是能做壁纸的那种。我想和对象一起来的话，住着海景房也是会很浪漫的吧？？？</p>
<p><img src="/resource/img/15751047922955.jpg"><br><img src="/resource/img/15751048016920.jpg"><br><img src="/resource/img/15751048087775.jpg"><br><img src="/resource/img/15751048169812.jpg"><br><img src="/resource/img/15751048217613.jpg"><br><img src="/resource/img/15751048275862.jpg"></p>
<p>待在这样的环境里我想一辈子也不会厌倦吧。晚上开去大理古城吃饭，石井私房菜，一个小巷子里，菜品也不错。邻桌的也是从北京过来旅游的。</p>
<p><img src="/resource/img/15751048653643.jpg"></p>
<p>也许大理的爱情偶遇会在古城中一个故事里发生，在不经意之间吧。</p>
<p><img src="/resource/img/15751048745592.jpg"></p>
<video style="margin: 0 auto; text-align: center; display: block; max-width:100%; object-fit:fill" >
  <source src="/resource/video/VUE_20191130182615.mp4" preload="meta" loop muted type="video/mp4">
</video>

<p>开车就要到平时不能到的地方去看看，经过重重山路不经意间来到了赵灵儿的故乡。查了查发现这里是南诏文化，巍山自治县，这里也有一个古城，慢悠悠的古城里有着原始的居民，又没有太过浓厚的商业化，保护的还相对比较好。</p>
<p><img src="/resource/img/15751048869368.jpg"><br><img src="/resource/img/15751048972343.jpg"><br><img src="/resource/img/15751049082094.jpg"></p>
<p>来大理的第三天，想着去丽江看看，最后因为时间距离问题没去，二刷再说吧。那么之前在洱海西线走了一遍，今天就在东线的环海公路走一遍吧。来到了一个叫双廊古镇的浓浓商业化的地方，有着网红打卡地天空之境，随处可见的海景房，这些都不重要，重要的是回去路上沿海公路，听着小歌吹着海风，心情超级好。当然还要感谢一下驾驶员智哥~</p>
<p><img src="/resource/img/15751049228201.jpg"><br><img src="/resource/img/15751049346970.jpg"><br><img src="/resource/img/15751049518586.jpg"></p>
<p>出来玩还是不要太久的，容易疲惫，好时光总是很快的，回家啦~</p>
<p><img src="/resource/img/15751049610316.jpg"><br><img src="/resource/img/15751049688245.jpg"><br><img src="/resource/img/15751049807690.jpg"></p>
<p>走啦～</p>
<hr>
<p>参考攻略</p>
<p>云南游玩交通参考</p>
<p><img src="/resource/img/15751145383497.jpg"></p>
<p>大理景点分布</p>
<p><img src="/resource/img/15751145598200.jpg"></p>
<p>行程规划</p>
<p><img src="/resource/img/15751832998709.jpg"></p>
<p>预算<br><img src="/resource/img/15751836377750.jpg"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://noogel.xyz/2019/08/29/2.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="noogel">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知一杂谈">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/08/29/2.html" class="post-title-link" itemprop="url">数据结构与算法思想</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-08-29 00:00:00" itemprop="dateCreated datePublished" datetime="2019-08-29T00:00:00+00:00">2019-08-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote class="blockquote-center">人生只有贪心，没有动态规划。</blockquote>

<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ul>
<li>数组</li>
<li>栈，先进后出</li>
<li>队列，先进先出<ul>
<li>双端队列，双端队列中的元素可以从两端弹出，插入和删除操作限定在队列的两边进行。</li>
<li>环形队列，环形队列是一种特殊的队列结构，保证了元素也是先进先出的，但与一般队列的区别是，他们是环形的，即队列头部的上个元素是队列尾部，通常是容纳元素数固定的一个闭环。</li>
</ul>
</li>
<li>堆，一种特别的树状数据结构。堆总是一棵完全树。即除了最底层，其他层的节点都被元素填满，且最底层尽可能地从左到右填入。</li>
<li>链表<ul>
<li>单向链表。</li>
<li>双向链表。</li>
<li>跳表，一种带多级索引的链表。</li>
</ul>
</li>
<li>散列表，是根据键而直接访问在内存存储位置的数据结构。它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。</li>
<li>树<ul>
<li>二叉树，二叉树是一个连通的无环图，并且每一个顶点的度不大于3。</li>
<li>红黑树，是一种自平衡二叉查找树。</li>
<li>字典树（Trie）</li>
</ul>
</li>
<li>图，图（Graph）是由顶点的有穷非空集合和顶点之间的边的集合组成。<ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/25498681">https://zhuanlan.zhihu.com/p/25498681</a></li>
<li>TODO</li>
</ul>
</li>
<li>布隆过滤器，一个概率型数据结构，可以用来判断一个元素是否在一个集合中。判断某个元素在，可能会被误判；判断某个元素不在，那么一定不在。<ul>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5bc7446e5188255c791b3360">https://juejin.im/post/5bc7446e5188255c791b3360</a></li>
</ul>
</li>
</ul>
<h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><h3 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h3><p>分治法是基于多项分支递归的一种很重要的算法范式。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。</p>
<p>例子：快排、归并排序、MapReduce</p>
<h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><p>贪心算法就是在每一步的选择中都按照当前最优的选择，从而希望最终结果得到最优解。贪心算法在有最优子结构的问题中尤为有效。最优子结构的意思是局部最优解能决定全局最优解。简单地说，问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解。<br>贪心算法与动态规划的不同在于它对每个子问题的解决方案都做出选择，不能回退。动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。</p>
<p>例子：最小生成树、哈夫曼编码</p>
<h3 id="动态规划（Dynamic-Programming）"><a href="#动态规划（Dynamic-Programming）" class="headerlink" title="动态规划（Dynamic Programming）"></a>动态规划（Dynamic Programming）</h3><p>动态规划通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。常常适用于有重叠子问题和最优子结构性质的问题。<br>若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。</p>
<blockquote>
<p>递归+记忆&#x3D;递推</p>
</blockquote>
<p>适用情况：</p>
<ol>
<li>具有最优子结构性质。</li>
<li>无后效性，子问题确定后不会再改变。</li>
<li>子问题重叠的性质。</li>
</ol>
<p>例子：背包问题<br><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92</a><br><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/23995189/answer/613096905">https://www.zhihu.com/question/23995189/answer/613096905</a></p>
<h3 id="回溯法（backtracking）"><a href="#回溯法（backtracking）" class="headerlink" title="回溯法（backtracking）"></a>回溯法（backtracking）</h3><p>回溯法采用试错的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：</p>
<ol>
<li>找到一个可能存在的正确的答案</li>
<li>在尝试了所有可能的分步方法后宣告该问题没有答案</li>
</ol>
<p>在最坏的情况下，回溯法会导致一次复杂度为指数时间的计算。</p>
<p>例子：八皇后问题</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%9B%9E%E6%BA%AF%E6%B3%95">https://zh.wikipedia.org/wiki/%E5%9B%9E%E6%BA%AF%E6%B3%95</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zuzZ/p/8178950.html">https://www.cnblogs.com/zuzZ/p/8178950.html</a></p>
<h3 id="分支界限法"><a href="#分支界限法" class="headerlink" title="分支界限法"></a>分支界限法</h3><p>与贪婪算法一样，这种方法也是用来为组合优化问题设计求解算法的，所不同的是它在问题的整个可能解空间搜索，所设计出来的算法虽其时间复杂度比贪婪算法高，但它的优点是与穷举法类似，都能保证求出问题的最佳解，而且这种方法不是盲目的穷举搜索，而是在搜索过程中通过限界，可以中途停止对某些不可能得到最优解的子空间进一步搜索（类似于人工智能中的剪枝），故它比穷举法效率更高。</p>
<h3 id="概率算法"><a href="#概率算法" class="headerlink" title="概率算法"></a>概率算法</h3><p>例子：<br>数值随机化算法<br>蒙特卡罗(Monte Carlo)算法<br>拉斯维加斯(Las Vegas)算法<br>舍伍德(Sherwood)算法</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/42619498">https://zhuanlan.zhihu.com/p/42619498</a></p>
<h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><h3 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a>15. 三数之和</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c &#x3D; 0 ？找出所有满足条件且不重复的三元组。</p>
<p>注意：答案中不可以包含重复的三元组。</p>
<p>例如, 给定数组 nums &#x3D; [-1, 0, 1, 2, -1, -4]，</p>
<p>满足要求的三元组集合为：<br>[<br>  [-1, 0, 1],<br>  [-1, -1, 2]<br>]</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>初读这道题时忽略了一个点，就是在检查时，如果有两个重复的数字可以都用上组成一个三元组集合，但是在返回结果的时候不能第一个数字参与组成三元组后第二个相同数字继续组成三元组。<strong>①</strong></p>
<p>有三种思路，先进性排序处理，然后再进行处理。第一种就是做三层枚举；第二种就是两层枚举，在进行 set O(1) 查找；第三种是一层枚举，然后从剩余列表中的左右两边进行查找，满足三元组的添加记录。</p>
<p>下面是主要介绍第三种思路的细节 <strong>②</strong>：</p>
<ol>
<li>排序处理</li>
<li>从第 0 位置开始遍历<ol>
<li>分别取剩余数组的首尾值进行求和</li>
<li>如果大于零则向前移动尾部游标</li>
<li>如果小于零则向后移动头部游标</li>
<li>如果等于零则添加记录<ol>
<li>添加记录后对首尾游标向中间移动一格</li>
</ol>
</li>
<li>如果首尾游标没有相交则继续 2.1 步骤处理</li>
</ol>
</li>
<li>进行下一位置的遍历，直到数组尾部</li>
<li>返回结果</li>
</ol>
<p>整个流程思路基本是这样子的，然后我们对于边界情况的处理单独进行描述 <strong>③</strong></p>
<ol>
<li>如果当前遍历位置值大于 0 则直接返回结果</li>
<li>对于我在 ① 中描述的情况，需要在 2.1 之前进行与判断，当前位置与上一位置值相同则跳过，进行排重处理</li>
<li>同样的情况处理在 4.1 之后也要进行首尾游标移动方向相邻值的排重处理</li>
</ol>
<h4 id="解题思维"><a href="#解题思维" class="headerlink" title="解题思维"></a>解题思维</h4><ol>
<li>首先需要做到的是充分理解题意，至少要做到能肉眼推导正确结果。</li>
<li>解决方案一般都会有多种，合理选择最优方案进行骨架设计 ②，充分考虑时间和空间复杂度。</li>
<li>然后解决边界条件 ③，优化代码可读性。</li>
<li>充分进行测试验证算法的正确性。</li>
</ol>
<h4 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h4><p>最后放一下解题代码，也是参考别人的方案实现的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class ThreeSum &#123;</span><br><span class="line"></span><br><span class="line">    public static List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; resp = new ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            if (nums[i] &gt; 0) break;</span><br><span class="line">            int l = i + 1;</span><br><span class="line">            int r = nums.length - 1;</span><br><span class="line">            if (i &gt; 0 &amp;&amp; nums[i-1] == nums[i]) continue;</span><br><span class="line">            while (l &lt; r)&#123;</span><br><span class="line">                int sum = nums[i] + nums[l] + nums[r];</span><br><span class="line">                if ( sum&gt; 0) r--;</span><br><span class="line">                else if (sum &lt; 0) l++;</span><br><span class="line">                else if (sum == 0)&#123;</span><br><span class="line">                    resp.add(Arrays.asList(nums[i], nums[l] , nums[r]));</span><br><span class="line">                    while (l &lt; r &amp;&amp; nums[l] == nums[l+1]) l++;</span><br><span class="line">                    while (l &lt; r &amp;&amp; nums[r] == nums[r-1]) r--;</span><br><span class="line">                    l++;</span><br><span class="line">                    r--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return resp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a>22. 括号生成</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。</p>
<p>例如，给出 n &#x3D; 3，生成结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[---</span><br><span class="line">title: 51. N皇后</span><br><span class="line">date: 2019-08-20</span><br><span class="line">tags: [算法, leetcode]</span><br><span class="line">id: 1</span><br><span class="line">---</span><br><span class="line">  &quot;((()))&quot;,</span><br><span class="line">  &quot;(()())&quot;,</span><br><span class="line">  &quot;(())()&quot;,</span><br><span class="line">  &quot;()(())&quot;,</span><br><span class="line">  &quot;()()()&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>根据递归做暴力处理，同时进行剪枝操作。</p>
<h4 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class GenerateParenthesis &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        GenerateParenthesis obj = new GenerateParenthesis();</span><br><span class="line">        List&lt;String&gt; stringList = obj.generateParenthesis(3);</span><br><span class="line">        System.out.println(stringList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;String&gt; generateParenthesis(int n) &#123;</span><br><span class="line">        List&lt;String&gt; collect = new ArrayList&lt;&gt;();</span><br><span class="line">        gen(collect, &quot;&quot;, n, n);</span><br><span class="line">        return collect;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void gen(List&lt;String&gt; collect, String cur, int left, int right) &#123;</span><br><span class="line">        if (left == 0 &amp;&amp; right == 0) &#123;</span><br><span class="line">            collect.add(cur);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (left &gt; 0) &#123;</span><br><span class="line">            gen(collect, cur + &quot;(&quot;, left - 1, right);</span><br><span class="line">        &#125;</span><br><span class="line">        if (right &gt; 0 &amp;&amp; right &gt; left) &#123;</span><br><span class="line">            gen(collect, cur + &quot;)&quot;, left, right - 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="49、242-字母异位词"><a href="#49、242-字母异位词" class="headerlink" title="49、242. 字母异位词"></a>49、242. 字母异位词</h3><p>第一题：</p>
<p><code>242. 有效的字母异位词</code><br>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p>
<p>示例 1:</p>
<p>输入: s &#x3D; “anagram”, t &#x3D; “nagaram”<br>输出: true<br>示例 2:</p>
<p>输入: s &#x3D; “rat”, t &#x3D; “car”<br>输出: false</p>
<p>说明:<br>你可以假设字符串只包含小写字母。</p>
<p>解答第一个思路是使用 HashMap 进行字频统计再对比，第二个思路是字符串排序后进行比较。</p>
<p>第二题：</p>
<p><code>49. 字母异位词分组</code></p>
<p>给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</p>
<p>示例:</p>
<p>输入: [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”],<br>输出:<br>[<br>  [“ate”,”eat”,”tea”],<br>  [“nat”,”tan”],<br>  [“bat”]<br>]<br>说明：</p>
<p>所有输入均为小写字母。<br>不考虑答案输出的顺序。</p>
<p>练习输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class Anagram &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(isAnagram(&quot;anagram&quot;, &quot;nagaram&quot;));</span><br><span class="line">        System.out.println(isAnagram2(&quot;anagram&quot;, &quot;nagaram&quot;));</span><br><span class="line">        groupAnagrams(new String[]&#123;&quot;eat&quot;, &quot;ate&quot;, &quot;aaa&quot;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static boolean isAnagram(String s, String t) &#123;</span><br><span class="line">        if (null == s &amp;&amp; null == t) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else if (null == s || null == t) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125; else if (s.length() != t.length()) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Character, Integer&gt; left = new HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;Character, Integer&gt; right = new HashMap&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; s.length(); i++) &#123;</span><br><span class="line">            left.put(s.charAt(i), left.getOrDefault(s.charAt(i), 0) + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int j = 0; j &lt; t.length(); j++) &#123;</span><br><span class="line">            right.put(t.charAt(j), right.getOrDefault(t.charAt(j), 0) + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        for (Map.Entry&lt;Character, Integer&gt; c : left.entrySet()) &#123;</span><br><span class="line">            if (!c.getValue().equals(right.getOrDefault(c.getKey(), 0))) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static boolean isAnagram2(String s, String t) &#123;</span><br><span class="line">        if (null == s &amp;&amp; null == t) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else if (null == s || null == t) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125; else if (s.length() != t.length()) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        char[] left = s.toCharArray();</span><br><span class="line">        char[] right = t.toCharArray();</span><br><span class="line">        Arrays.sort(left);</span><br><span class="line">        Arrays.sort(right);</span><br><span class="line">        for (int i = 0; i &lt; left.length; i++) &#123;</span><br><span class="line">            if (left[i] != right[i]) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; res = new HashMap&lt;&gt;();</span><br><span class="line">        for (String sr : strs) &#123;</span><br><span class="line">            char[] chars = sr.toCharArray();</span><br><span class="line">            Arrays.sort(chars);</span><br><span class="line">            String sortedSr = new String(chars);</span><br><span class="line">            if (!res.containsKey(sortedSr)) &#123;</span><br><span class="line">                res.put(sortedSr, new ArrayList&lt;&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            List&lt;String&gt; mapVal = res.get(sortedSr);</span><br><span class="line">            mapVal.add(sr);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; rep = new ArrayList&lt;&gt;();</span><br><span class="line">        for (Map.Entry&lt;String, List&lt;String&gt;&gt; entry : res.entrySet()) &#123;</span><br><span class="line">            rep.add(entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        return rep;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="51-N皇后"><a href="#51-N皇后" class="headerlink" title="51. N皇后"></a>51. N皇后</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><p>n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
<p><img src="/resource/img/2020-10-23-01-09-53.png"></p>
<p>上图为 8 皇后问题的一种解法。</p>
<p>给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。</p>
<p>每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p>
<p>示例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入: 4</span><br><span class="line">输出: [</span><br><span class="line"> [&quot;.Q..&quot;,  // 解法 1</span><br><span class="line">  &quot;...Q&quot;,</span><br><span class="line">  &quot;Q...&quot;,</span><br><span class="line">  &quot;..Q.&quot;],</span><br><span class="line"></span><br><span class="line"> [&quot;..Q.&quot;,  // 解法 2</span><br><span class="line">  &quot;Q...&quot;,</span><br><span class="line">  &quot;...Q&quot;,</span><br><span class="line">  &quot;.Q..&quot;]</span><br><span class="line">]</span><br><span class="line">解释: 4 皇后问题存在两个不同的解法。</span><br></pre></td></tr></table></figure>

<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>…</p>
<h4 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.HashSet;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">public class SolveNQueens &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SolveNQueens queens = new SolveNQueens();</span><br><span class="line">        System.out.println(queens.solveNQueens(5));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; resp = new ArrayList&lt;&gt;();</span><br><span class="line">        Set&lt;Integer&gt; cols = new HashSet&lt;&gt;();</span><br><span class="line">        Set&lt;Integer&gt; pie = new HashSet&lt;&gt;();</span><br><span class="line">        Set&lt;Integer&gt; na = new HashSet&lt;&gt;();</span><br><span class="line">        dfs(n, 0, new ArrayList&lt;&gt;(), resp, cols, pie, na);</span><br><span class="line">        return resp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void dfs(int max, int row, List&lt;String&gt; curState, List&lt;List&lt;String&gt;&gt; resp,</span><br><span class="line">                    Set&lt;Integer&gt; cols, Set&lt;Integer&gt; pie, Set&lt;Integer&gt; na) &#123;</span><br><span class="line">        // 终结条件</span><br><span class="line">        if (row &gt;= max) &#123;</span><br><span class="line">            if (curState.size() == max) &#123;</span><br><span class="line">                resp.add(curState);</span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 循环列</span><br><span class="line">        for (int col = 0; col &lt; max; col++) &#123;</span><br><span class="line">            if (cols.contains(col) || pie.contains(row + col) || na.contains(row - col)) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            cols.add(col);</span><br><span class="line">            pie.add(row + col);</span><br><span class="line">            na.add(row - col);</span><br><span class="line">            curState.add(trans(col, max));</span><br><span class="line">            int size = curState.size();</span><br><span class="line">            List&lt;String&gt; newState = (max - row == 1) ? new ArrayList&lt;String&gt;() &#123;&#123;</span><br><span class="line">                addAll(curState);</span><br><span class="line">            &#125;&#125; : curState;</span><br><span class="line">            // 递归层</span><br><span class="line">            dfs(max, row + 1, newState, resp, cols, pie, na);</span><br><span class="line">            cols.remove(col);</span><br><span class="line">            pie.remove(row + col);</span><br><span class="line">            na.remove(row - col);</span><br><span class="line">            curState.remove(size - 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String trans(int point, int max) &#123;</span><br><span class="line">        char[] chars = new char[max];</span><br><span class="line">        for (int i = 0; i &lt; max; i++) &#123;</span><br><span class="line">            chars[i] = i == point ? &#x27;Q&#x27; : &#x27;.&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">        return String.valueOf(chars);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="69-x-的平方根"><a href="#69-x-的平方根" class="headerlink" title="69. x 的平方根"></a>69. x 的平方根</h3><p>实现 <code>int sqrt(int x)</code> 函数。</p>
<p>计算并返回 x 的平方根，其中 x 是非负整数。</p>
<p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 4</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: 8</span><br><span class="line">输出: 2</span><br><span class="line">说明: 8 的平方根是 2.82842..., </span><br><span class="line">     由于返回类型是整数，小数部分将被舍去。</span><br></pre></td></tr></table></figure>

<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>二分查找比较</p>
<p>需要注意的地方有两个</p>
<ol>
<li>注意开始边界问题</li>
<li>注意类型长度越界</li>
</ol>
<h4 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class MySqrt &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MySqrt mySqrt = new MySqrt();</span><br><span class="line">        System.out.println(mySqrt.mySqrt(2147395599));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 边界问题</span><br><span class="line">    // 1. 0\1边界</span><br><span class="line">    //  类型长度越界</span><br><span class="line">    public int mySqrt(int x) &#123;</span><br><span class="line">        if (x == 0) return 0;</span><br><span class="line">        if (x == 1) return 1;</span><br><span class="line">        return mySqrt(x, 0, x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int mySqrt(long x, long left, long right) &#123;</span><br><span class="line">        long cur = (right - left) / 2 + left;</span><br><span class="line">        long cur2 = cur * cur;</span><br><span class="line">        if (cur2 == x) &#123;</span><br><span class="line">            return (int) cur;</span><br><span class="line">        &#125; else if (right - left == 1) &#123;</span><br><span class="line">            return (int) left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (cur2 &lt; x) &#123;</span><br><span class="line">            left = cur;</span><br><span class="line">        &#125; else if (cur2 &gt; x) &#123;</span><br><span class="line">            right = cur;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return (int) cur;</span><br><span class="line">        &#125;</span><br><span class="line">        return mySqrt(x, left, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p>牛顿迭代法</p>
<hr>
<h3 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a>98. 验证二叉搜索树</h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p>
<p>假设一个二叉搜索树具有如下特征：</p>
<p>节点的左子树只包含小于当前节点的数。<br>节点的右子树只包含大于当前节点的数。<br>所有左子树和右子树自身必须也是二叉搜索树。<br>示例 1:</p>
<p>输入:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  2</span><br><span class="line"> / \</span><br><span class="line">1   3</span><br></pre></td></tr></table></figure>

<p>输出: true<br>示例 2:</p>
<p>输入:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  5</span><br><span class="line"> / \</span><br><span class="line">1   4</span><br><span class="line">     / \</span><br><span class="line">    3   6</span><br></pre></td></tr></table></figure>

<p>输出: false<br>解释: 输入为: [5,1,4,null,null,3,6]。<br>     根节点的值为 5 ，但是其右子节点值为 4 。</p>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>首先拿到这个题看起来思路比较简单，实现起来还有有点困难，而且在思考过程中踩过一个坑，又爬上来的。哎，看题还是要全面点。</p>
<ol>
<li>首先想到就是中序遍历了，放到一个列表中，然后比较大小即可。</li>
<li>或者是做一个递归操作，判断当前节点是否在一个范围即可。</li>
</ol>
<p>思路是这么两个思路，代码实现起来为了执行效率做了短路处理，就是边遍历边检查，遇到错误就一路返回不再进行后面处理，当然这是思路理顺后的优化。</p>
<p>中序遍历没坑，直接写就行了，有坑的是第二种操作，刚开始觉得只要比较当前节点的父节点和两个子节点就好了，就像下面画的，已 C 点为当前节点进行处理，实际是一个错误的思路，并且情况也分析的不对。</p>
<p><img src="/resource/img/2020-10-23-01-10-19.png"></p>
<p>意识到问题后就重新分析，把当前节点作为最底端的节点，我们去比较的都是当前节点和父辈及以上的节点的大小，也就是拆出来四种情况。</p>
<p><img src="/resource/img/2020-10-23-01-10-31.png"></p>
<p>其中 <code>⨁</code> 表示当前节点，和其它点的相对位置表示左右子节点关系，<code>min -&gt; max</code> 指向当前节点值必须在此区间中才可以，<code>+∞</code> 和 <code>-∞</code> 为单点情况的边界表示。最后拆分出这四种子情况，只要任一节点符合这四种情况之一即当前节点满足，当所有节点均满足则二叉搜索🌲有效，事实根据这个思路写出的代码验证是可行的。比较开心的是重新思考后的思路写出来的代码一次通过✌️。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>解法1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isValidBST(TreeNode root)&#123;</span><br><span class="line">        return forEachNode(root, new ArrayList&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean forEachNode(TreeNode node, List&lt;Integer&gt; val)&#123;</span><br><span class="line">        if (null == node) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!forEachNode(node.left, val))&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!validOrAdd(val, node))&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!forEachNode(node.right, val))&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean validOrAdd(List&lt;Integer&gt; val, TreeNode node)&#123;</span><br><span class="line">        if(val.size() &gt; 0 &amp;&amp; val.get(val.size() - 1) &gt;= node.val)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return val.add(node.val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解法2</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isValidBST(TreeNode root)&#123;</span><br><span class="line">        return subValidBSTLeft(root, null, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean subValidBSTLeft(TreeNode node, Integer min, Integer max) &#123;</span><br><span class="line">        if (null == node)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if (null == min &amp;&amp; null == max)&#123;</span><br><span class="line">        &#125;else if (null == min &amp;&amp; null !=max &amp;&amp; node.val &lt; max)&#123;</span><br><span class="line">        &#125;else if (null != min &amp;&amp; null == max &amp;&amp; min &lt; node.val)&#123;</span><br><span class="line">        &#125;else if (null != min &amp;&amp; null != max &amp;&amp; min &lt; node.val &amp;&amp; node.val &lt; max)&#123;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        // left</span><br><span class="line">        if (!subValidBSTLeft(node.left, min, node.val))&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        // right</span><br><span class="line">        if (!subValidBSTLeft(node.right, node.val, max))&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="102-二叉树的层次遍历"><a href="#102-二叉树的层次遍历" class="headerlink" title="102. 二叉树的层次遍历"></a>102. 二叉树的层次遍历</h3><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。</p>
<p>例如:<br>给定二叉树: [3,9,20,null,null,15,7],</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>返回其层次遍历结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h4 id="解答-2"><a href="#解答-2" class="headerlink" title="解答"></a>解答</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; resp = new ArrayList&lt;&gt;();</span><br><span class="line">        levelOrder(root, 0, resp);</span><br><span class="line">        return resp;</span><br><span class="line">    &#125;</span><br><span class="line">    public void levelOrder(TreeNode cur, int cur_level, List&lt;List&lt;Integer&gt;&gt; resp) &#123;</span><br><span class="line">        if(null == cur)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(cur_level == resp.size())&#123;</span><br><span class="line">            resp.add(new ArrayList&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        resp.get(cur_level).add(cur.val);</span><br><span class="line">        levelOrder(cur.left, cur_level+1, resp);</span><br><span class="line">        levelOrder(cur.right, cur_level+1, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一次过</p>
</blockquote>
<hr>
<h3 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a>104. 二叉树的最大深度</h3><h4 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h4><p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例：<br>给定二叉树 [3,9,20,null,null,15,7]，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>返回它的最大深度 3 。</p>
<h4 id="解答-3"><a href="#解答-3" class="headerlink" title="解答"></a>解答</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxDepth(TreeNode root) &#123;</span><br><span class="line">        return maxDepth(root, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    public int maxDepth(TreeNode cur, int level) &#123;</span><br><span class="line">        if(null == cur) return level;</span><br><span class="line">        int left_level = maxDepth(cur.left, level + 1);</span><br><span class="line">        int right_level = maxDepth(cur.right, level + 1);</span><br><span class="line">        return left_level &gt; right_level ? left_level: right_level;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一次过</p>
</blockquote>
<hr>
<h3 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111. 二叉树的最小深度"></a>111. 二叉树的最小深度</h3><h4 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h4><p>给定一个二叉树，找出其最小深度。</p>
<p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例:</p>
<p>给定二叉树 [3,9,20,null,null,15,7],</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>返回它的最小深度  2.</p>
<h4 id="解答-4"><a href="#解答-4" class="headerlink" title="解答"></a>解答</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int minDepth(TreeNode root) &#123;</span><br><span class="line">        return minDepth(root, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int minDepth(TreeNode cur, int level) &#123;</span><br><span class="line">        if (null == cur) return level;</span><br><span class="line">        if (null == cur.left &amp;&amp; null == cur.right) &#123;</span><br><span class="line">            return level + 1;</span><br><span class="line">        &#125; else if (null != cur.left &amp;&amp; null == cur.right) &#123;</span><br><span class="line">            return minDepth(cur.left, level + 1);</span><br><span class="line">        &#125; else if (null == cur.left &amp;&amp; null != cur.right) &#123;</span><br><span class="line">            return minDepth(cur.right, level + 1);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            int left_level = minDepth(cur.left, level + 1);</span><br><span class="line">            int right_level = minDepth(cur.right, level + 1);</span><br><span class="line">            return left_level &gt; right_level ? right_level : left_level;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a>141. 环形链表</h3><p>给定一个链表，判断链表中是否有环。</p>
<p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p>
<p>正常的解题思路，通过记录走过的节点来判断是否有环。</p>
<p>时间复杂度：O(n)，对于含有 n 个元素的链表，我们访问每个元素最多一次。添加一个结点到哈希表中只需要花费 O(1) 的时间。</p>
<p>空间复杂度：O(n)，空间取决于添加到哈希表中的元素数目，最多可以添加 n 个元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123;</span><br><span class="line"> *         val = x;</span><br><span class="line"> *         next = null;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public boolean hasCycle(ListNode head) &#123;</span><br><span class="line">        HashSet&lt;Integer&gt; points = new HashSet&lt;Integer&gt;();</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        while (null != cur)&#123;</span><br><span class="line">            int curHashCode = cur.hashCode();</span><br><span class="line">            if(points.contains(curHashCode))&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            points.add(curHashCode);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种解题思路是双指针大小步，一个指针每次走一步，另一个指针每次走两步，如果有环的话则两个指针最终会相遇。</p>
<p>在最糟糕的情形下，时间复杂度为 O(N+K)，也就是 O(n)。</p>
<p>空间复杂度：O(1)，我们只使用了慢指针和快指针两个结点，所以空间复杂度为 O(1)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123;</span><br><span class="line"> *         val = x;</span><br><span class="line"> *         next = null;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public boolean hasCycle(ListNode head) &#123;</span><br><span class="line">        if (null == head)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;else if (null == head.next)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;else if (head == head.next.next)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode minCur = head.next;</span><br><span class="line">        ListNode maxCur = head.next.next;</span><br><span class="line">        while (minCur != maxCur)&#123;</span><br><span class="line">            if (null == minCur.next)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;else if (null == maxCur.next)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;else if (null == maxCur.next.next)&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            minCur = minCur.next;</span><br><span class="line">            maxCur = maxCur.next.next;</span><br><span class="line">            if (minCur == maxCur)&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="146-LRU缓存"><a href="#146-LRU缓存" class="headerlink" title="146. LRU缓存"></a>146. LRU缓存</h3><p>运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。</p>
<p>获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。<br>写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。</p>
<p>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lru-cache">https://leetcode-cn.com/problems/lru-cache</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">from collections import OrderedDict</span><br><span class="line"></span><br><span class="line">class LRUCache(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self, capacity):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type capacity: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        self._cache = OrderedDict()</span><br><span class="line">        self._size = capacity</span><br><span class="line"></span><br><span class="line">    def get(self, key):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type key: int</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if key not in self._cache:</span><br><span class="line">            return -1</span><br><span class="line">        val = self._cache.pop(key)</span><br><span class="line">        self._cache[key] = val</span><br><span class="line">        return val</span><br><span class="line"></span><br><span class="line">    def put(self, key, value):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type key: int</span><br><span class="line">        :type value: int</span><br><span class="line">        :rtype: None</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if key in self._cache:</span><br><span class="line">            self._cache.pop(key)</span><br><span class="line">            self._cache[key] = value</span><br><span class="line">        else:</span><br><span class="line">            if len(self._cache) == self._size:</span><br><span class="line">                self._cache.popitem(last=False)</span><br><span class="line">            self._cache[key] = value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Your LRUCache object will be instantiated and called as such:</span><br><span class="line"># obj = LRUCache(capacity)</span><br><span class="line"># param_1 = obj.get(key)</span><br><span class="line"># obj.put(key,value)</span><br></pre></td></tr></table></figure>

<p>有序字典的解法<br>时间复杂度 O(1)<br>空间复杂度 O(capacity)</p>
<p>Java 解法需要 LinkedHashMap <strong>TODO</strong></p>
<p>LRU(Least Recently Used)最少最近使用，一种页面置换算法。</p>
<p>LFU(Least Frequently Used)最近最不常用。</p>
<h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><p>LRU</p>
<p><img src="/resource/img/2020-10-23-01-10-55.png"></p>
<hr>
<h3 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a>206. 反转链表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">public class ReverseLinkedList &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ListNode listNode = ListNode.of(</span><br><span class="line">                1,</span><br><span class="line">                ListNode.of(</span><br><span class="line">                        2,</span><br><span class="line">                        ListNode.of(</span><br><span class="line">                                3,</span><br><span class="line">                                ListNode.of(</span><br><span class="line">                                        4,</span><br><span class="line">                                        ListNode.of(</span><br><span class="line">                                                5, null</span><br><span class="line">                                        )</span><br><span class="line">                                )</span><br><span class="line">                        )</span><br><span class="line">                )</span><br><span class="line">        );</span><br><span class="line">        ListNode next = listNode;</span><br><span class="line">        while (null != next) &#123;</span><br><span class="line">            System.out.println(next.val);</span><br><span class="line">            next = next.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;===&quot;);</span><br><span class="line">        ListNode reverse = reverse3(listNode);</span><br><span class="line"></span><br><span class="line">        ListNode next2 = reverse;</span><br><span class="line">        while (null != next2) &#123;</span><br><span class="line">            System.out.println(next2.val);</span><br><span class="line">            next2 = next2.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 官方推荐的</span><br><span class="line">     * @param head</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static ListNode reverse2(ListNode head) &#123;</span><br><span class="line">        // prev -&gt; curr -&gt; nextTemp</span><br><span class="line">        ListNode prev = null;</span><br><span class="line">        ListNode curr = head;</span><br><span class="line">        while (curr != null) &#123;</span><br><span class="line">            ListNode nextTemp = curr.next;</span><br><span class="line">            curr.next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = nextTemp;</span><br><span class="line">        &#125;</span><br><span class="line">        return prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 自己写的</span><br><span class="line">     * @param head</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static ListNode reverse(ListNode head) &#123;</span><br><span class="line">        // cur -&gt; prev -&gt; tmp</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        ListNode next = head.next;</span><br><span class="line">        head.next = null;</span><br><span class="line">        while (null != cur) &#123;</span><br><span class="line">            ListNode tmp = null;</span><br><span class="line">            if (null != next) &#123;</span><br><span class="line">                tmp = next.next;</span><br><span class="line">                next.next = cur;</span><br><span class="line">            &#125;</span><br><span class="line">            if (null == next) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = next;</span><br><span class="line">            next = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        return cur;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 复写的</span><br><span class="line">     * 1. 记录前一个节点，当前节点</span><br><span class="line">     * 2. 迭代</span><br><span class="line">     * 3. 取出当前节点到临时变量</span><br><span class="line">     * 4. -- 现在有 prev -&gt; curr -&gt; next 三个节点</span><br><span class="line">     * 5. 将 curr.next -&gt; prev，改变指向方向</span><br><span class="line">     * 6. 依次挪动节点位置 prev = curr , curr = nextTemp</span><br><span class="line">     * 7. 最后返回 prev</span><br><span class="line">     *</span><br><span class="line">     * 时间复杂度 O(n)</span><br><span class="line">     * 空间复杂度 O(1)</span><br><span class="line">     * @param head</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static ListNode reverse3(ListNode head) &#123;</span><br><span class="line">        // prev -&gt; curr -&gt; next</span><br><span class="line">        ListNode prev = null;</span><br><span class="line">        ListNode curr = head;</span><br><span class="line">        while (null != curr) &#123;</span><br><span class="line">            ListNode next = curr.next;</span><br><span class="line">            curr.next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line">        return prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="208-实现-Trie-前缀树"><a href="#208-实现-Trie-前缀树" class="headerlink" title="208. 实现 Trie (前缀树)"></a>208. 实现 Trie (前缀树)</h3><h4 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h4><p>实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。</p>
<p>示例:</p>
<p>Trie trie &#x3D; new Trie();</p>
<p>trie.insert(“apple”);<br>trie.search(“apple”);   &#x2F;&#x2F; 返回 true<br>trie.search(“app”);     &#x2F;&#x2F; 返回 false<br>trie.startsWith(“app”); &#x2F;&#x2F; 返回 true<br>trie.insert(“app”);<br>trie.search(“app”);     &#x2F;&#x2F; 返回 true<br>说明:</p>
<p>你可以假设所有的输入都是由小写字母 a-z 构成的。<br>保证所有输入均为非空字符串。</p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>前缀树<br>Trie<br>字典树</p>
<h4 id="解答-5"><a href="#解答-5" class="headerlink" title="解答"></a>解答</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">public class Trie &#123;</span><br><span class="line">    private final int SIZE = 26;</span><br><span class="line">    private Node root;</span><br><span class="line"></span><br><span class="line">    private class Node &#123;</span><br><span class="line">        private boolean isStr;</span><br><span class="line">        private int num;</span><br><span class="line">        private Node[] child;</span><br><span class="line"></span><br><span class="line">        public Node() &#123;</span><br><span class="line">            child = new Node[SIZE];</span><br><span class="line">            isStr = false;</span><br><span class="line">            num = 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Trie() &#123;</span><br><span class="line">        root = new Node();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void insert(String word) &#123;</span><br><span class="line">        if (null == word || word.isEmpty()) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        Node pNode = this.root;</span><br><span class="line">        for (int i = 0; i &lt; word.length(); i++) &#123;</span><br><span class="line">            int index = word.charAt(i) - &#x27;a&#x27;;</span><br><span class="line">            if (pNode.child[index] == null) &#123;</span><br><span class="line">                Node tmp = new Node();</span><br><span class="line">                pNode.child[index] = tmp;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                pNode.child[index].num++;</span><br><span class="line">            &#125;</span><br><span class="line">            pNode = pNode.child[index];</span><br><span class="line">        &#125;</span><br><span class="line">        pNode.isStr = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean search(String word) &#123;</span><br><span class="line">        if (null == word || word.isEmpty()) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        Node pNode = this.root;</span><br><span class="line">        for (int i = 0; i &lt; word.length(); i++) &#123;</span><br><span class="line">            int index = word.charAt(i) - &#x27;a&#x27;;</span><br><span class="line">            if (pNode.child[index] == null || (word.length() - i == 1 &amp;&amp; pNode.child[index].isStr == false)) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            pNode = pNode.child[index];</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean startsWith(String prefix) &#123;</span><br><span class="line">        if (null == prefix || prefix.isEmpty()) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        Node pNode = this.root;</span><br><span class="line">        for (int i = 0; i &lt; prefix.length(); i++) &#123;</span><br><span class="line">            int index = prefix.charAt(i) - &#x27;a&#x27;;</span><br><span class="line">            if (pNode.child[index] == null) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            pNode = pNode.child[index];</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="703-数据流中的第K大元素"><a href="#703-数据流中的第K大元素" class="headerlink" title="703. 数据流中的第K大元素"></a>703. 数据流中的第K大元素</h3><p>设计一个找到数据流中第K大元素的类（class）。注意是排序后的第K大元素，不是第K个不同的元素。</p>
<p>你的 KthLargest 类需要一个同时接收整数 k 和整数数组nums 的构造器，它包含数据流中的初始元素。每次调用 KthLargest.add，返回当前数据流中第K大的元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line">public class KthLargest &#123;</span><br><span class="line">    private PriorityQueue&lt;Integer&gt; minHeap;</span><br><span class="line">    private int kSize;</span><br><span class="line"></span><br><span class="line">    public KthLargest(int k, int[] nums) &#123;</span><br><span class="line">        kSize = k;</span><br><span class="line">        minHeap=new PriorityQueue&lt;Integer&gt;(kSize);</span><br><span class="line">        for (int i = 0; i&lt; nums.length; i++)&#123;</span><br><span class="line">            add(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int add(int val) &#123;</span><br><span class="line">        if (minHeap.size() &lt; kSize)&#123;</span><br><span class="line">            minHeap.offer(val);</span><br><span class="line">        &#125;else if (minHeap.peek() &lt; val)&#123;</span><br><span class="line">            minHeap.poll();</span><br><span class="line">            minHeap.offer(val);</span><br><span class="line">        &#125;</span><br><span class="line">        return minHeap.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java中PriorityQueue通过二叉小顶堆实现，可以用一棵完全二叉树表示。</p>
<p>关于堆操作：<a target="_blank" rel="noopener" href="https://shmilyaw-hotmail-com.iteye.com/blog/1775868">https://shmilyaw-hotmail-com.iteye.com/blog/1775868</a></p>
<p>操作说明：</p>
<table><thead><tr class="header"><th>方法名</th><th>功能描述</th></tr></thead>
<tbody><tr class="odd"><td>add(Ee)</td><td>在队列头部增加一个元素，如果容量已满，则抛出异常，成功则返回true。</td></tr>
<tr class="even"><td>clear()</td><td>清空</td></tr>
<tr class="odd"><td>contains(Objecto)</td><td>检查是否包含当前参数元素</td></tr>
<tr class="even"><td>offer(Ee)</td><td>在队列头部增加一个元素，如果容量已满，则返回false，成功加入，返回true。</td></tr>
<tr class="odd"><td>peek()</td><td>返回队列头部节点，但不移除队列头节点。</td></tr>
<tr class="even"><td>poll()</td><td>将队列头部元素移出队列并返回。</td></tr>
<tr class="odd"><td>remove(Objecto)</td><td>将队列头部元素移出队列并返回，如果队列为空，则抛出异常。</td></tr>
<tr class="even"><td>size()</td><td>返回长度</td></tr></tbody></table>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://noogel.xyz/2019/07/29/1.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="noogel">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知一杂谈">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/07/29/1.html" class="post-title-link" itemprop="url">第一次露营</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-07-29 00:00:00" itemprop="dateCreated datePublished" datetime="2019-07-29T00:00:00+00:00">2019-07-29</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>发现自己没玩过的事情好多，上周末便实施了一次露营⛺️之路，叫上小伙伴一起报了个户外团，第一次去选择的比较休闲级别的，然后自带了几十斤装备在山上扎营看天。</p>
<p>去之前连帐篷都没有打开过，不过好在很好弄，去到了迅速选择好营地很快就扎好了。然后在山顶四处转了转。第一次出来玩还是挺兴奋的，但没多久就冻得回帐篷换上了衣服，对比去的时候早上北京的天气超级闷热。<br><img src="/resource/img/15644162500365.jpg"></p>
<p>周围也有好多同行的人在扎营，还有两只🐶子互相溜着玩，和它们的主人一样的兴奋。<br><img src="/resource/img/15644164178708.jpg"></p>
<p>到了傍晚，就开始下起了大雾，一直持续到了第二天早上，后来想想从山脚下看来这应该是☁️吧，那就是身在云中了。在这么个野外环境下，找厕所也是很方了，哈哈哈。</p>
<p><img src="/resource/img/15644165914978.jpg"></p>
<p><img src="/resource/img/15644165994873.jpg"></p>
<p>下了这么一晚上的雾，有点遗憾的是没能看到星空🌃，而且没能选到一个防露水的帐篷晚上被滴醒好几次😶。。。</p>
<p><img src="/resource/img/15644166097428.jpg"></p>
<p>早上还是挺可以的，看到了日出🌅和云海，还有四处觅食的🐂。其实云海肉眼看上去不太明显，但是做成一个加速的短视频就很好看了。</p>
<p><img src="/resource/img/15644168860852.jpg"></p>
<p><img src="/resource/img/15644168979835.jpg"></p>
<p><img src="/resource/img/15644169199043.jpg"></p>
<p><img src="/resource/img/15644169500468.jpg"></p>
<p>露营前简单做的攻略</p>
<p>说明：</p>
<ol>
<li>加粗为必备</li>
<li>标 A 的说明已准备好</li>
</ol>
<p>装备：</p>
<p><strong>帐篷A</strong>、<strong>防潮垫A</strong>、<strong>睡袋A</strong>、气垫（防咯）、<strong>头灯A</strong>、手电A、<strong>登山包A</strong>、<strong>充电宝A</strong>、手机</p>
<p><strong>雨衣A</strong>、雨鞋套A、<strong>登山鞋或运动鞋</strong>、<strong>长袖防风衣物</strong>、羽绒服、头巾、棉帽</p>
<p><strong>暖贴A</strong>、水杯、<strong>水5L A</strong>、<strong>湿巾A</strong>、<strong>纸巾A</strong>、洗漱用品、<strong>垃圾袋A</strong>、耳塞（风声吵）、眼罩</p>
<p><strong>自发热小火锅A</strong>、八宝粥、面包、筷子、红牛、便携气炉</p>
<p><strong>药物</strong>（快客、思密达+ 、藿香正气、创可贴、防虫喷雾、布洛芬）、风油精 AAAAA</p>
<p>银行卡一张A、<strong>工具刀A</strong>、备用手机A</p>
<p>这里说一些注意点</p>
<ol>
<li>帐篷一定要四季防雨防露水的，赶上下雨就惨了</li>
<li>防潮垫一定要有，并且根据情况准备厚点的防咯</li>
<li>暖贴可以准备一些晚上睡觉冷贴身上</li>
<li>垃圾袋还是多带点将垃圾带走</li>
<li>工具刀准备一下防止意外保护安全</li>
<li>如果带气炉的话要注意地铁不让进</li>
<li>吃的尽量带一些高热量食物，自发热小火锅我觉得必备</li>
</ol>
<p>最后附上一张小朋友拍的很棒的照片。</p>
<p><img src="/resource/img/15644170535159.jpg"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://noogel.xyz/2019/07/25/1.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="noogel">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知一杂谈">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/07/25/1.html" class="post-title-link" itemprop="url">Redis 数据结构</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-07-25 00:00:00" itemprop="dateCreated datePublished" datetime="2019-07-25T00:00:00+00:00">2019-07-25</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="跳表（Skip-List）"><a href="#跳表（Skip-List）" class="headerlink" title="跳表（Skip List）"></a>跳表（Skip List）</h2><h3 id="怎样理解跳表"><a href="#怎样理解跳表" class="headerlink" title="怎样理解跳表"></a>怎样理解跳表</h3><p><img src="/resource/img/15639866952706.jpg"></p>
<p>用一种比较通俗的方式去说，<strong>跳表是一种带有 N 级索引的有序链表，其中 N 级索引的作用是可以加速查找到链表的目标节点。</strong></p>
<p>比较大众化的解释是，<strong>跳表是一个随机化的数据结构，实质就是一种可以进行『二分』查找的有序链表。</strong>这里对于随机化的理解是 N 级索引节点的选择上。</p>
<p>跳表不仅能提高搜索性能，同时也可以提高插入和删除操作的性能。在一定程度上可以代替红黑树（Red-black tree）。</p>
<h3 id="跳表的结构"><a href="#跳表的结构" class="headerlink" title="跳表的结构"></a>跳表的结构</h3><p><img src="/resource/img/15639887557859.jpg"></p>
<p>从链表说起，对于普通链表中，即使其存储的数据是有序的，当我们要寻找一个数据，时间复杂度也会比较高 O(n)。</p>
<p><img src="/resource/img/15639870290579.jpg"></p>
<p>然后我们对链表建立一级索引，每两个节点提取一个节点放到索引层，其中的 down 指针指向下一级。</p>
<p>当我们寻找节点 16，只需要走过 <code>1&#39; -&gt; 4&#39; -&gt; 7&#39; -&gt; 9&#39; -&gt; 13&#39; -&gt; 13 -&gt; 16</code> 节点即可（<code>17&#39;</code>也要访问判断），而原始链表需要走过 10 个节点，节省了 2 个节点路径。如果我们再抽出二级索引后是这样子的。</p>
<p><img src="/resource/img/15639877153042.jpg"></p>
<p>寻找节点 16 只需要走过 <code>1&#39;&#39; -&gt; 7&#39;&#39; -&gt; 13&#39;&#39; -&gt; 13&#39; -&gt; 13 -&gt; 16</code> 节点。这样我们又可以加快查找到目标节点，图中举例节点比较靠前，试想节点靠后，并且增加了 N 级索引之后效率一定会提升很多。</p>
<h3 id="跳表的性能指标"><a href="#跳表的性能指标" class="headerlink" title="跳表的性能指标"></a>跳表的性能指标</h3><p>单一链表的查询时间复杂度是 O(n)，插入、删除的时间复杂度也是 O(n)。</p>
<p>以两个节点为跨度的话，那么跳表有如下总结：</p>
<ol>
<li>第 k 级索引的节点个数是 <code>n/(2^k)</code></li>
<li>假设有 h 级索引，最高级索引有 2 个节点，高度 <code>h=log2n - 1</code> (2为底数)，每一层都遍历 m 个节点，时间复杂度为 O(m*log n)。此时算得 m&#x3D;3。</li>
</ol>
<p>以多个节点为跨度，可以节省更多节点，是空间和时间上的相互折中。在实际开发中，索引节点只存储关键值和关键指针，之后链表节点才存储实际对象。</p>
<p>跳表的的查询、插入、更新、删除时间复杂度均为 O(log n)。</p>
<p>如何选择索引层？通过一个随机函数决定将节点插入到哪几级索引中，随机函数特点是要保证跳表索引大小和数据大小平衡性。</p>
<h3 id="跳表在-Redis-中的应用"><a href="#跳表在-Redis-中的应用" class="headerlink" title="跳表在 Redis 中的应用"></a>跳表在 Redis 中的应用</h3><p>Redis 中有序集合通过散列表 + 跳表实现的，主要支持的功能有：</p>
<ul>
<li>插入一个数据;</li>
<li>删除一个数据;</li>
<li>查找一个数据;</li>
<li>按照区间查找数据;</li>
<li>迭代输出有序序列;</li>
</ul>
<p>相比红黑树，跳表在区间查找上有更好的性能；并且实现起来也相对容易；可以通过调整索引策略来平衡性能和内存使用；红黑树插入删除时为了平衡高度需要旋转附近节点，高并发时需要锁，跳表不需要考虑。</p>
<p>关于源码分析：<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000013418471">https://segmentfault.com/a/1190000013418471</a></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/dd01e8dc4d1f">https://www.jianshu.com/p/dd01e8dc4d1f</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/pcwl1206/article/details/83512600">https://blog.csdn.net/pcwl1206/article/details/83512600</a></p>
</blockquote>
<h2 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h2><p>在一个集合中只有为数不多的整数时，Redis 使用 intset 整数集合存储数据。具有如下特性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct intset &#123;</span><br><span class="line">    //编码方式</span><br><span class="line">    uint32_t encoding;</span><br><span class="line">    //元素数目</span><br><span class="line">    uint32_t length;</span><br><span class="line">    //保存元素的数组</span><br><span class="line">    int8_t contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure>

<ol>
<li>数据从小到大排序并且自动去重。</li>
<li>数据类型实际存储在 encoding 中。</li>
<li>当 encoding 中的数据类型不能满足时会自动进行类型升级。<ol>
<li>重新分配空间</li>
<li>迁移</li>
<li>添加新元素</li>
<li>时间复杂度为 O(n)</li>
</ol>
</li>
<li>不支持降级操作。</li>
</ol>
<p>优点：</p>
<ol>
<li>灵活，不用考虑整数集合类型，直接添加自动升级。</li>
<li>节省空间，只在必要时进行升级。</li>
</ol>
<p>升级操作是指将整数由 16 位、32 位、64 位的方式增加支持范围。</p>
<h2 id="IO-模型"><a href="#IO-模型" class="headerlink" title="IO 模型"></a>IO 模型</h2><p>通俗的理解 Redis 是一个单进程单线程模型的 KV 内存数据库，截止到目前官方会在年底发布多线程版本，并且 Redis 也有自己的持久化方案。采用 I&#x2F;O 复用模型和非阻塞 IO 技术，被广泛应用在高并发场景中。</p>
<p>Redis 高性能的几个关键点：</p>
<ul>
<li>完全基于内存操作，数据也是存储在内存中。</li>
<li>数据结构简单，很多查找和操作的时间复杂度在 O(1)。</li>
<li>单线程模式，避免了上下文的切换和锁竞争。</li>
<li>使用了 I&#x2F;O 多路复用模型和非阻塞 IO。</li>
</ul>
<p>Redis 同时支持多个客户端连接，采用 I&#x2F;O 多路复用模型（select\poll\epoll）可以同时监听多个 IO 流事件。</p>
<blockquote>
<p>多路指的是多个网络连接，复用指的是复用同一个线程。<br>采用多路IO复用技术可以让单个线程高效的处理多个连接请求(尽量减少网络IO的时间消耗)，且Redis在内存中操作数据的速度非常快(内存内的操作不会成为这里的性能瓶颈)，主要以上两点造就了Redis具有很高的吞吐量。</p>
</blockquote>
<p>TODO I&#x2F;O 多路复用</p>
<h2 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a target="_blank" rel="noopener" href="http://researchlab.github.io/2018/10/08/redis-11-redisio/">http://researchlab.github.io/2018/10/08/redis-11-redisio/</a></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2015 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">noogel</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdn.jsdelivr.net/npm/mermaid@8.13.4/dist/mermaid.min.js","integrity":"sha256-96rwDGMWIQYB0yKGp1sKi1yrjrLPj2oT39IpbCsIrsg="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>



  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"noogel","repo":"noogel.github.io","client_id":"41a4e14aca0b3552334a","client_secret":"ebe0f9bfd24824f3d0d0f41bfd88a8736353759b","admin_user":"noogel","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","js":{"url":"https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js","integrity":"sha256-Pmj85ojLaPOWwRtlMJwmezB/Qg8BzvJp5eTzvXaYAfA="},"path_md5":"82ca3c470e333e0bd93410abdccf0f6d"}</script>
<script src="/js/third-party/comments/gitalk.js"></script>

</body>
</html>
