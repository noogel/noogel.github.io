<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>知一杂谈</title>
  
  <subtitle>我思故我在</subtitle>
  <link href="https://noogel.xyz/atom.xml" rel="self"/>
  
  <link href="https://noogel.xyz/"/>
  <updated>2025-10-18T17:05:54.273Z</updated>
  <id>https://noogel.xyz/</id>
  
  <author>
    <name>noogel</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vibe Coding 实践：用 Flask 构建 Docker 管理平台</title>
    <link href="https://noogel.xyz/2025/10/19/1.html"/>
    <id>https://noogel.xyz/2025/10/19/1.html</id>
    <published>2025-10-19T00:00:00.000Z</published>
    <updated>2025-10-18T17:05:54.273Z</updated>
    
    <content type="html"><![CDATA[<p>今天，我想向大家介绍一个非常有实用价值的项目：<strong>niche-dind</strong>，一个基于 Web 界面的 Docker 容器管理平台。</p><p>在当今的软件开发领域，Docker 几乎已经成为基础设施的标配。从开发环境到生产环境，我们都享受着容器化带来的便捷与一致性。然而，市面上很少有简单易用的个人 docker 维护工具，随着项目数量和容器规模的增长，随之而来的管理负担也变得越来越重。</p><p>对于个人用户，你可能习惯于每天敲击着 <code>docker-compose up</code> 或 <code>docker stack deploy</code> 命令。但当需要同时管理数十个项目、几十个服务，并随时查看它们的运行状态、资源占用和实时日志时，纯粹的命令行操作就显得力不从心了。</p><p>这就是 <strong>niche-dind</strong>（全称 <strong>Docker in Docker Manager</strong>）诞生的初衷：<strong>用一个直观、统一的 Web 界面，彻底解放 DevOps 双手，将容器管理提升到项目和应用栈（Stack）的层面。</strong></p><p><img src="/resource/img/2025-10-19-00-45-36.png"></p><span id="more"></span><hr><h2 id="一、告别命令行：从管理容器到管理项目"><a href="#一、告别命令行：从管理容器到管理项目" class="headerlink" title="一、告别命令行：从管理容器到管理项目"></a>一、告别命令行：从管理容器到管理项目</h2><p>传统的 Docker GUI 工具大多停留在单个容器的操作，但现代应用部署已经演进到 Compose 或 Swarm Stack 的层次。<code>niche-dind</code> 的最大价值，就在于它将管理重心直接放在了项目（Project）和部署栈（Stack）上。</p><p>对于使用 <code>docker-compose.yml</code> 来定义服务的用户来说，<code>niche-dind</code> 提供了完整的生命周期管理：</p><ul><li><strong>可视化配置:</strong> 你可以直接在 Web 界面上创建、编辑和查看你的 Compose 配置，告别 VIM 或 Nano 的束缚。</li><li><strong>一键式操作:</strong> 无论是初次部署、配置更新还是项目删除，都只需要一次点击，平台将自动完成所有底层的 Docker SDK 调用。</li></ul><p><img src="/resource/img/2025-10-19-00-47-03.png"></p><hr><h2 id="二、洞察一切：实时监控与日志聚合"><a href="#二、洞察一切：实时监控与日志聚合" class="headerlink" title="二、洞察一切：实时监控与日志聚合"></a>二、洞察一切：实时监控与日志聚合</h2><p>对于运维工程师而言，服务的“可观察性”（Observability）是确保系统稳定的基石。当出现问题时，你需要立即知道<strong>什么地方</strong>出了问题、<strong>为什么</strong>会出问题。</p><p><code>niche-dind</code> 提供了一个全面的仪表板，让你对容器环境有全局的掌控：</p><ul><li><strong>资源使用统计:</strong> 实时查看每个容器的 <strong>CPU 使用率</strong>、<strong>内存占用</strong>、以及<strong>网络 I&#x2F;O 统计</strong>。你可以迅速识别出资源瓶颈，避免突发性的性能问题。</li><li><strong>健康检查状态:</strong> 它不仅告诉你容器是“启动”还是“停止”，还会展示应用级别的健康检查结果，让你知道应用是否真的在正常工作。</li></ul><hr><h2 id="三、面向团队：OIDC-认证与生态系统管理"><a href="#三、面向团队：OIDC-认证与生态系统管理" class="headerlink" title="三、面向团队：OIDC 认证与生态系统管理"></a>三、面向团队：OIDC 认证与生态系统管理</h2><p>一个优秀的管理平台，必须是“团队友好”的。这意味着它要解决企业级的安全和协作需求。</p><h3 id="1-OIDC-单点登录认证（SSO）"><a href="#1-OIDC-单点登录认证（SSO）" class="headerlink" title="1. OIDC 单点登录认证（SSO）"></a>1. OIDC 单点登录认证（SSO）</h3><p>在企业环境中，使用统一的身份认证系统是标准要求。<code>niche-dind</code> 深度集成了 <strong>OIDC</strong>（OpenID Connect）协议。</p><ul><li><strong>企业级安全:</strong> 支持包括 Keycloak、Auth0 等主流 OIDC 提供商，实现一键登录。</li><li><strong>会话管理:</strong> 统一管理用户会话，确保安全性。</li></ul><p>这种设计使得 <code>niche-dind</code> 不仅仅是一个个人工具，而是一个真正面向团队的协作平台。</p><h3 id="2-完整的镜像与仓库管理"><a href="#2-完整的镜像与仓库管理" class="headerlink" title="2. 完整的镜像与仓库管理"></a>2. 完整的镜像与仓库管理</h3><p>从代码到容器，最后到部署，镜像和仓库是整个 CI&#x2F;CD 流程的起点。</p><ul><li><strong>中央仓库配置:</strong> 统一管理多个 Docker Registry（例如 Docker Hub、阿里云 ACR、私有 Harbor）。你可以配置认证信息，并一键测试连接性。</li><li><strong>镜像生命周期:</strong> 直接查看本地镜像列表、执行镜像的拉取（Pull）和推送（Push）操作，以及进行标签管理。你不再需要手动登录到每台服务器去处理镜像。</li></ul><p><img src="/resource/img/2025-10-19-00-47-58.png"></p><hr><h2 id="四、技术解密：为什么选择-Python-和-Flask"><a href="#四、技术解密：为什么选择-Python-和-Flask" class="headerlink" title="四、技术解密：为什么选择 Python 和 Flask"></a>四、技术解密：为什么选择 Python 和 Flask</h2><p>一个优秀的工具离不开一个简洁、可靠的技术基石。<code>niche-dind</code> 的技术选型体现了“<strong>用最简单的方式解决最复杂的问题</strong>”的原则。</p><p>它的核心技术栈是：</p><table><thead><tr><th align="left">模块</th><th align="left">技术栈</th><th align="left">版本</th><th align="left">核心价值</th></tr></thead><tbody><tr><td align="left"><strong>后端框架</strong></td><td align="left"><strong>Flask</strong></td><td align="left">3.0.2</td><td align="left">轻量、灵活、易于维护，是构建 API 服务的利器。</td></tr><tr><td align="left"><strong>容器核心</strong></td><td align="left"><strong>Docker SDK</strong></td><td align="left">7.1.0</td><td align="left">稳定且功能完备，是与 Docker 引擎交互的官方桥梁。</td></tr><tr><td align="left"><strong>认证组件</strong></td><td align="left"><strong>Authlib</strong></td><td align="left">1.6.0</td><td align="left">专业的 OAuth&#x2F;OIDC 库，确保认证流程的安全可靠。</td></tr><tr><td align="left"><strong>生产部署</strong></td><td align="left"><strong>Gunicorn</strong></td><td align="left">21.2.0</td><td align="left">工业级的 WSGI HTTP 服务器，提供高性能和高并发支持。</td></tr></tbody></table><p>选择 Python 和 Flask 的原因很简单：<strong>开发效率高，代码可读性强。</strong> 尤其是 <code>Docker SDK</code> 库，它将复杂的 Docker API 调用封装成优雅的 Python 对象和方法，让开发者可以专注于业务逻辑，而不是 HTTP 请求细节。</p><hr><h2 id="五、如何开始使用（极简部署）"><a href="#五、如何开始使用（极简部署）" class="headerlink" title="五、如何开始使用（极简部署）"></a>五、如何开始使用（极简部署）</h2><p>作为一款容器管理工具，<code>niche-dind</code> 自身的部署当然也必须是容器化的。开发者已经将部署流程简化到了极致。</p><ol><li><p><strong>克隆项目：</strong></p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://gitee.com/noogel/niche-dind</span><br><span class="line"><span class="built_in">cd</span> niche-dind</span><br></pre></td></tr></table></figure></li><li><p><strong>一键启动：</strong></p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure></li></ol><p>就是这么简单。通过一个 <code>docker-compose.yml</code> 文件，应用及其依赖将被完全拉起，并在默认情况下运行于 <code>http://localhost:5002</code>。</p><p>如果你打算在真实环境中使用 OIDC 认证，只需要在启动前配置好以下环境变量即可：<code>OIDC_CLIENT_ID</code>、<code>OIDC_CLIENT_SECRET</code>、<code>OIDC_ISSUER</code> 等。</p><hr><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>在容器化大潮中，管理工具的进步往往落后于部署技术的迭代。<strong>niche-dind</strong> 正是试图弥补这一差距的优秀实践。</p><p>它不仅仅是一个 Web 界面，更是一套<strong>面向团队、以项目为中心、具备企业级认证能力</strong>的容器管理解决方案。它帮助我们将精力从繁琐的命令行操作中解脱出来，专注于应用的构建和创新。</p><p>我强烈推荐任何正在使用 Docker Compose 的团队，花点时间去了解和尝试这个项目。如果你觉得它有价值，不妨在 Gitee 上给它点一个 Star，甚至参与到开发中来。</p><p><strong>项目地址：<a href="https://gitee.com/noogel/niche-dind">https://gitee.com/noogel/niche-dind</a></strong></p><p>让管理变得简单，将复杂留给工具本身。这是现代运维哲学的核心。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天，我想向大家介绍一个非常有实用价值的项目：&lt;strong&gt;niche-dind&lt;/strong&gt;，一个基于 Web 界面的 Docker 容器管理平台。&lt;/p&gt;
&lt;p&gt;在当今的软件开发领域，Docker 几乎已经成为基础设施的标配。从开发环境到生产环境，我们都享受着容器化带来的便捷与一致性。然而，市面上很少有简单易用的个人 docker 维护工具，随着项目数量和容器规模的增长，随之而来的管理负担也变得越来越重。&lt;/p&gt;
&lt;p&gt;对于个人用户，你可能习惯于每天敲击着 &lt;code&gt;docker-compose up&lt;/code&gt; 或 &lt;code&gt;docker stack deploy&lt;/code&gt; 命令。但当需要同时管理数十个项目、几十个服务，并随时查看它们的运行状态、资源占用和实时日志时，纯粹的命令行操作就显得力不从心了。&lt;/p&gt;
&lt;p&gt;这就是 &lt;strong&gt;niche-dind&lt;/strong&gt;（全称 &lt;strong&gt;Docker in Docker Manager&lt;/strong&gt;）诞生的初衷：&lt;strong&gt;用一个直观、统一的 Web 界面，彻底解放 DevOps 双手，将容器管理提升到项目和应用栈（Stack）的层面。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/resource/img/2025-10-19-00-45-36.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="项目" scheme="https://noogel.xyz/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>数字长征：一次 HTTP 请求的分层哲学</title>
    <link href="https://noogel.xyz/2025/10/18/1.html"/>
    <id>https://noogel.xyz/2025/10/18/1.html</id>
    <published>2025-10-18T00:00:00.000Z</published>
    <updated>2025-10-18T16:00:23.275Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/resource/img/2025-10-18-23-13-24.png"></p><blockquote><p>万物皆有裂隙，那是光照进来的地方。—— 莱昂纳德·科恩</p></blockquote><p>在数字世界的舞台上，每一次简单的点击、每一次轻滑的屏幕，都意味着一次跨越山海的数字旅行。它始于用户手机的指尖，穿过无数的网线、光纤，最终抵达某地的服务器，并在一段代码框架内完成它的使命。</p><p>这绝非一次平淡无奇的旅程。它涉及了网络通信的经典哲学、安全防护的严密艺术、负载均衡的调度智慧，以及应用框架的精巧设计。我们不妨剥开层层外壳，看看这短短的毫秒之间，究竟发生了哪些惊心动魄的故事，以及每一阶段的“幕后英雄”是如何恪尽职守的。</p><h2 id="旅程的起点——DNS的“地址簿”哲学"><a href="#旅程的起点——DNS的“地址簿”哲学" class="headerlink" title="旅程的起点——DNS的“地址簿”哲学"></a>旅程的起点——DNS的“地址簿”哲学</h2><h3 id="阶段一：用户手机经过-DNS-解析到-IP"><a href="#阶段一：用户手机经过-DNS-解析到-IP" class="headerlink" title="阶段一：用户手机经过 DNS 解析到 IP"></a>阶段一：用户手机经过 DNS 解析到 IP</h3><p>当我们尝试访问一个域名，比如<code>www.example.com</code>时，计算机世界的首要难题是：<em>它在哪里？</em></p><p><strong>职责：</strong> 将人类可读的域名转换为机器可识别的IP地址。<br><strong>技术原理：</strong> <strong>域名系统（DNS）</strong>，一个全球分布式、层次化的数据库。</p><span id="more"></span><h4 id="1-技术的秘密：递归查询与缓存"><a href="#1-技术的秘密：递归查询与缓存" class="headerlink" title="1. 技术的秘密：递归查询与缓存"></a>1. 技术的秘密：递归查询与缓存</h4><p>我们的手机或电脑并不知道<code>example.com</code>的IP。它首先将请求交给本地的 <strong>DNS递归解析器</strong>（通常由ISP提供或配置，如Google的8.8.8.8）。</p><ol><li><strong>本地缓存查阅：</strong> 解析器首先检查自己的缓存。如果不久前查询过，直接返回IP地址。这是速度的秘密，也是我们日常网络体验顺畅的关键。</li><li><strong>根域查询（<code>.</code>）：</strong> 如果缓存中没有，解析器将请求发往全球<strong>13组根服务器</strong>。根服务器并不知道最终答案，它只指引方向：“去问<code>.com</code>顶级域服务器吧。”</li><li><strong>TLD查询（<code>.com</code>）：</strong> 解析器转向<code>.com</code>的<strong>顶级域服务器（TLD）</strong>。TLD服务器再次指引：“去找<code>example.com</code>的<strong>权威名称服务器</strong>。”</li><li><strong>权威查询：</strong> 解析器找到<code>example.com</code>的权威名称服务器，这个服务器存储着该域名的最终记录，它终于返回了我们梦寐以求的IP地址，比如：<code>104.26.12.24</code>。</li></ol><p><strong>哲学思考：</strong> DNS是去中心化的典范。它没有一个万能的中央大脑，而是通过<strong>分层授权</strong>，将巨大的查询任务分解，确保了互联网的扩展性和韧性。每一个环节都只做自己知道的事，并将未知的责任交给下一层，这便是数字世界的“自治”精神。</p><h2 id="跨越山海——网络、高防与调度艺术"><a href="#跨越山海——网络、高防与调度艺术" class="headerlink" title="跨越山海——网络、高防与调度艺术"></a>跨越山海——网络、高防与调度艺术</h2><h3 id="阶段二：IP-经过网络到服务器"><a href="#阶段二：IP-经过网络到服务器" class="headerlink" title="阶段二：IP 经过网络到服务器"></a>阶段二：IP 经过网络到服务器</h3><p>当手机拿到目标IP后，它就可以通过TCP&#x2F;IP协议栈，将HTTP请求封装成数据包，通过互联网发送。数据包在路由器之间跳转，最终到达数据中心的网络入口。</p><h3 id="阶段三：经过高防设备"><a href="#阶段三：经过高防设备" class="headerlink" title="阶段三：经过高防设备"></a>阶段三：经过高防设备</h3><p>请求不会直接击中应用服务器，因为这如同将城堡的宝藏暴露在城墙之外。数据包首先被送往一道坚固的防线：<strong>高性能负载均衡器&#x2F;Web应用防火墙WAF</strong>。</p><p><strong>职责：</strong> 负载均衡、安全防护（高防）、SSL卸载。<br><strong>技术原理：</strong> <strong>反向代理、四&#x2F;七层负载均衡、Web应用防火墙（WAF）</strong>。</p><h4 id="1-技术的秘密：两个身份"><a href="#1-技术的秘密：两个身份" class="headerlink" title="1. 技术的秘密：两个身份"></a>1. 技术的秘密：两个身份</h4><p><strong>A. 负载均衡器（Load Balancer）：</strong><br>通常工作在L4（传输层）或L7（应用层）。它接收请求，并根据预设的算法（如<strong>最少连接数、轮询</strong>等）决定将请求转发给哪一台健康的后端服务器集群。它的核心价值在于：<strong>分散压力</strong>，确保没有单台服务器因过载而崩溃；<strong>故障转移</strong>，自动将流量导向健康的机器。</p><p><strong>B. Web 应用防火墙（WAF）：</strong><br>“高防”的核心。WAF在L7层对请求内容进行深度审查。</p><ul><li><strong>安全职责：</strong> 阻止<strong>OWASP Top 10</strong>攻击，如SQL注入、跨站脚本（XSS）。它不是简单的IP封禁，而是像一位经验老道的侦探，检查HTTP请求的<strong>Payload</strong>，识别出潜在的恶意代码模式。</li><li><strong>DDoS高防：</strong> 在网络层和应用层，通过流量清洗和行为分析，过滤掉大量的恶意请求，确保合法请求能够顺利通过。</li></ul><p><strong>哲学思考：<strong>高防设备代表了系统的</strong>弹性</strong>与<strong>韧性</strong>。它是一个完美的“守门人”和“调度员”，它既确保了系统的稳定运行（负载均衡），也捍卫了系统的安全边界（WAF）。安全与性能，在此得到了精妙的平衡。</p><h2 id="前置审查——Nginx的“门卫”与“路由员”"><a href="#前置审查——Nginx的“门卫”与“路由员”" class="headerlink" title="前置审查——Nginx的“门卫”与“路由员”"></a>前置审查——Nginx的“门卫”与“路由员”</h2><h3 id="阶段四：到-Nginx-路径解析，登录验证"><a href="#阶段四：到-Nginx-路径解析，登录验证" class="headerlink" title="阶段四：到 Nginx 路径解析，登录验证"></a>阶段四：到 Nginx 路径解析，登录验证</h3><p>通过重重检查后，请求被转发到了更高层级的应用入口：<strong>Nginx（或类似的Web服务器&#x2F;反向代理）</strong>。</p><p><strong>职责：</strong> 统一入口、静态文件服务、请求路由分发、前置身份验证。<br><strong>技术原理：</strong> <strong>反向代理（Proxy Pass）、Location匹配、HTTP模块</strong>。</p><h4 id="1-技术的秘密：Location匹配与认证子请求"><a href="#1-技术的秘密：Location匹配与认证子请求" class="headerlink" title="1. 技术的秘密：Location匹配与认证子请求"></a>1. 技术的秘密：Location匹配与认证子请求</h4><p><strong>A. 请求路由解析：</strong><br>Nginx使用其配置中的<code>location</code>指令，根据请求的URI进行<strong>模式匹配</strong>，决定如何处理。</p><ul><li>如果是<code>/static/</code>开头的路径，Nginx会直接从文件系统返回静态资源（图片、CSS、JS），这避免了Tomcat和Spring处理这些低价值请求，极大地<strong>提高了效率</strong>。</li><li>如果是<code>/api/</code>开头的路径，Nginx会执行<code>proxy_pass</code>，将请求转发给后端的应用服务器集群（如Tomcat）。</li></ul><p><strong>B. 登录验证（Authentication）：</strong><br>在将请求转发给Spring应用之前，Nginx可以执行“<strong>前置认证</strong>”。</p><ul><li>通过**<code>auth_request</code>模块**，Nginx可以向一个<strong>内部认证服务</strong>（一个独立的微服务或应用接口）发起一个<strong>子请求</strong>，携带用户提供的Token（如JWT）。</li><li>如果认证服务返回<code>200 OK</code>，Nginx才将原始请求转发给Tomcat。如果返回<code>401 Unauthorized</code>，Nginx直接返回错误给客户端。</li></ul><p><strong>哲学思考：</strong> Nginx是<strong>职责分离</strong>的绝佳实践。它将“高频低值”（静态文件）和“通用前置”（认证、限流）的任务承担下来，让后端的应用服务器（Tomcat&#x2F;Spring）能专注于它们的核心使命——<strong>业务逻辑的实现</strong>。高效的系统，总是懂得如何将精力放在最重要的事情上。</p><h2 id="步入殿堂——Servlet容器与Spring的前置调度"><a href="#步入殿堂——Servlet容器与Spring的前置调度" class="headerlink" title="步入殿堂——Servlet容器与Spring的前置调度"></a>步入殿堂——Servlet容器与Spring的前置调度</h2><h3 id="阶段五：到-Tomcat-Servelet"><a href="#阶段五：到-Tomcat-Servelet" class="headerlink" title="阶段五：到 Tomcat Servelet"></a>阶段五：到 Tomcat Servelet</h3><p>请求穿过Nginx，现在抵达了Java应用的核心运行环境：<strong>Servlet容器</strong>（如Tomcat、Jetty）。</p><p><strong>职责：</strong> 提供Java Web运行环境，解析原始HTTP请求，将请求封装成Java对象，并启动Servlet处理链。<br><strong>技术原理：</strong> <strong>Servlet API 规范、Tomcat连接器与处理线程</strong>。</p><h4 id="1-技术的秘密：从字节流到Java对象"><a href="#1-技术的秘密：从字节流到Java对象" class="headerlink" title="1. 技术的秘密：从字节流到Java对象"></a>1. 技术的秘密：从字节流到Java对象</h4><ol><li><strong>连接器（Connector）：</strong> Tomcat的连接器（如AJP&#x2F;HTTP）负责监听端口，接收原始TCP连接，并读取<strong>原始的HTTP字节流</strong>。</li><li><strong>协议处理：</strong> 连接器将这些字节流根据HTTP协议规范，解析成一个标准的**<code>HttpServletRequest</code><strong>对象和一个</strong><code>HttpServletResponse</code>**对象。</li><li><strong>过滤器链（Filter Chain）：</strong> 请求进入Servlet容器后，会经过一系列的**<code>Filter</code>**。这些Filter是Servlet规范的一部分，早于Spring框架运行。它们处理通用的任务，如字符编码设置、Session管理、CORS处理等。</li><li><strong>分发到DispatcherServlet：</strong> 过滤器链的终点，是将请求交给应用程序的核心入口——Spring的**<code>DispatcherServlet</code>**。</li></ol><h3 id="阶段六：到-Spring-Request-Mapping"><a href="#阶段六：到-Spring-Request-Mapping" class="headerlink" title="阶段六：到 Spring Request Mapping"></a>阶段六：到 Spring Request Mapping</h3><p><strong><code>DispatcherServlet</code></strong>，被誉为Spring MVC的“<strong>前端控制器（Front Controller）</strong>”设计模式的实现。它是Spring世界的核心枢纽。</p><p><strong>职责：</strong> 调度、请求映射、参数处理、视图渲染。<br><strong>技术原理：</strong> <strong>前端控制器模式、HandlerMapping、HandlerAdapter</strong>。</p><h4 id="1-技术的秘密：两大“功臣”"><a href="#1-技术的秘密：两大“功臣”" class="headerlink" title="1. 技术的秘密：两大“功臣”"></a>1. 技术的秘密：两大“功臣”</h4><p><strong>A. HandlerMapping（处理器映射器）：</strong><br>这是DispatcherServlet的首要任务。它像一本精确的导航图。</p><ul><li><strong>工作原理：</strong> 它遍历所有已注册的<code>@Controller</code>中的所有方法，根据方法上的<code>@RequestMapping</code>、<code>@GetMapping</code>等注解，将请求的<strong>URI、HTTP方法</strong>等信息，映射到<strong>具体的处理方法</strong>。</li><li><strong>输出结果：</strong> 找到最匹配的处理方法后，HandlerMapping返回一个**<code>HandlerExecutionChain</code><strong>（处理器执行链），其中包含目标方法和所有适用的</strong>拦截器（Interceptor）**。</li></ul><p><strong>B. 拦截器（HandlerInterceptor）：</strong><br>在执行目标方法之前，请求会依次经过<strong>Spring拦截器链</strong>。</p><ul><li><strong><code>preHandle()</code>：</strong> 方法执行前，可用于更细粒度的权限检查、日志记录等。</li><li><strong><code>postHandle()</code>：</strong> 方法执行后、视图渲染前，可用于修改Model数据。</li><li><strong><code>afterCompletion()</code>：</strong> 整个请求完成后，可用于资源清理。</li></ul><p><strong>哲学思考：</strong> Servlet容器（Tomcat）负责网络和基础协议的抽象，它是<strong>基础设施</strong>。<code>DispatcherServlet</code>是<strong>应用框架的入口</strong>，它将低级的HTTP请求提升到高级的“业务操作”层面。这种清晰的职责划分，是软件架构优美之处。</p><h2 id="执行与归来——业务逻辑的实现"><a href="#执行与归来——业务逻辑的实现" class="headerlink" title="执行与归来——业务逻辑的实现"></a>执行与归来——业务逻辑的实现</h2><h3 id="阶段七：找到对应执行类，找到对应执行方法"><a href="#阶段七：找到对应执行类，找到对应执行方法" class="headerlink" title="阶段七：找到对应执行类，找到对应执行方法"></a>阶段七：找到对应执行类，找到对应执行方法</h3><p>请求终于抵达了它的终点。</p><p><strong>职责：</strong> 真正执行业务逻辑，处理数据。<br><strong>技术原理：</strong> <strong>HandlerAdapter（处理器适配器）</strong>、<strong>依赖注入（DI）</strong>、<strong>AOP</strong>。</p><h4 id="1-技术的秘密：适配与执行"><a href="#1-技术的秘密：适配与执行" class="headerlink" title="1. 技术的秘密：适配与执行"></a>1. 技术的秘密：适配与执行</h4><p><strong>A. HandlerAdapter（处理器适配器）：</strong><br>既然找到了目标方法，如何才能优雅地执行它？这便是HandlerAdapter的责任。</p><ul><li><strong>参数解析：</strong> 目标方法的参数（如<code>@PathVariable</code>、<code>@RequestParam</code>、<code>@RequestBody</code>）需要从<code>HttpServletRequest</code>中解析出来。HandlerAdapter会调用相应的**<code>HandlerMethodArgumentResolver</code>**来完成这一任务。例如，它使用<code>HttpMessageConverter</code>将JSON请求体转换为Java对象。</li><li><strong>方法的调用：</strong> 它最终使用Java反射机制，调用目标Controller实例上的具体方法。</li></ul><p><strong>B. 业务逻辑执行：</strong><br>方法内部，通常会调用<strong>Service层</strong>，Service层调用<strong>Repository层</strong>，完成数据查询、事务处理等核心业务操作。</p><ul><li><strong>AOP的魔力：</strong> 在执行Service方法时，Spring的**AOP（面向切面编程）**可能悄然介入，比如自动开启和提交数据库事务（<code>@Transactional</code>），或记录操作日志。</li></ul><h3 id="阶段八：执行后返回"><a href="#阶段八：执行后返回" class="headerlink" title="阶段八：执行后返回"></a>阶段八：执行后返回</h3><p>业务方法执行完毕，得到了结果。</p><p><strong>职责：</strong> 将Java对象的结果转换为客户端可识别的HTTP响应。<br><strong>技术原理：</strong> <strong>HttpMessageConverter、视图解析器（View Resolver）</strong>。</p><h4 id="1-技术的秘密：响应的封装"><a href="#1-技术的秘密：响应的封装" class="headerlink" title="1. 技术的秘密：响应的封装"></a>1. 技术的秘密：响应的封装</h4><ol><li><p><strong>返回值的处理：</strong></p><ul><li>如果Controller方法带有<code>@ResponseBody</code>或使用<code>@RestController</code>，Spring会使用**<code>HttpMessageConverter</code>**（如Jackson库）将返回的Java对象序列化成JSON或XML字符串。</li><li>如果返回的是一个逻辑视图名（如<code>&quot;userList&quot;</code>），Spring将启用**<code>ViewResolver</code>**，将其解析成一个具体的视图技术（如JSP或Thymeleaf），然后将数据模型填充到视图中，最终渲染成HTML。</li></ul></li><li><p><strong>最终响应：</strong> 无论是JSON还是HTML，最终都被写入<code>HttpServletResponse</code>对象中。</p></li><li><p><strong>返回到Tomcat：</strong> 响应对象返回给DispatcherServlet，然后依次返回给HandlerAdapter、拦截器（执行<code>afterCompletion</code>）、Servlet Filter链。</p></li><li><p><strong>返回到客户端：</strong> Tomcat将<code>HttpServletResponse</code>封装成原始的HTTP响应字节流，通过网络回传，依次经过Nginx、高防，最终到达用户的手机。手机浏览器解析响应，用户看到了期待已久的内容。</p></li></ol><h2 id="结语：复杂系统中的秩序之美"><a href="#结语：复杂系统中的秩序之美" class="headerlink" title="结语：复杂系统中的秩序之美"></a>结语：复杂系统中的秩序之美</h2><p>这一次从手机到Spring的旅行，仿佛一部交响乐，经历了序曲（DNS）、宏大的前奏（高防&#x2F;Nginx）、庄严的入场（Tomcat&#x2F;DispatcherServlet），以及核心的演奏（Controller&#x2F;Service）。</p><p>每一个阶段都有其不可替代的职责，每一项技术原理都体现了软件工程的智慧。我们所追求的，并非是单个环节的极致性能，而是在这多层、复杂的分布式系统中，建立起一种<strong>清晰的边界</strong>、<strong>稳定的秩序</strong>和<strong>优雅的协作</strong>。</p><p>正是这种“万物归位，各司其职”的哲学，才构建起了我们今日赖以生存的数字世界。每一次点击，都是对这种秩序之美的验证。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/resource/img/2025-10-18-23-13-24.png&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;万物皆有裂隙，那是光照进来的地方。—— 莱昂纳德·科恩&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在数字世界的舞台上，每一次简单的点击、每一次轻滑的屏幕，都意味着一次跨越山海的数字旅行。它始于用户手机的指尖，穿过无数的网线、光纤，最终抵达某地的服务器，并在一段代码框架内完成它的使命。&lt;/p&gt;
&lt;p&gt;这绝非一次平淡无奇的旅程。它涉及了网络通信的经典哲学、安全防护的严密艺术、负载均衡的调度智慧，以及应用框架的精巧设计。我们不妨剥开层层外壳，看看这短短的毫秒之间，究竟发生了哪些惊心动魄的故事，以及每一阶段的“幕后英雄”是如何恪尽职守的。&lt;/p&gt;
&lt;h2 id=&quot;旅程的起点——DNS的“地址簿”哲学&quot;&gt;&lt;a href=&quot;#旅程的起点——DNS的“地址簿”哲学&quot; class=&quot;headerlink&quot; title=&quot;旅程的起点——DNS的“地址簿”哲学&quot;&gt;&lt;/a&gt;旅程的起点——DNS的“地址簿”哲学&lt;/h2&gt;&lt;h3 id=&quot;阶段一：用户手机经过-DNS-解析到-IP&quot;&gt;&lt;a href=&quot;#阶段一：用户手机经过-DNS-解析到-IP&quot; class=&quot;headerlink&quot; title=&quot;阶段一：用户手机经过 DNS 解析到 IP&quot;&gt;&lt;/a&gt;阶段一：用户手机经过 DNS 解析到 IP&lt;/h3&gt;&lt;p&gt;当我们尝试访问一个域名，比如&lt;code&gt;www.example.com&lt;/code&gt;时，计算机世界的首要难题是：&lt;em&gt;它在哪里？&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;职责：&lt;/strong&gt; 将人类可读的域名转换为机器可识别的IP地址。&lt;br&gt;&lt;strong&gt;技术原理：&lt;/strong&gt; &lt;strong&gt;域名系统（DNS）&lt;/strong&gt;，一个全球分布式、层次化的数据库。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>电商算价模型：理解复杂促销背后的逻辑</title>
    <link href="https://noogel.xyz/2025/07/24/1.html"/>
    <id>https://noogel.xyz/2025/07/24/1.html</id>
    <published>2025-07-24T00:00:00.000Z</published>
    <updated>2025-07-27T14:17:51.218Z</updated>
    
    <content type="html"><![CDATA[<p>在当今竞争激烈的电商环境中，价格是吸引消费者、提升转化率并最终实现商业目标的核心要素。然而，电商平台的商品价格并非简单地由标价决定，它涉及到复杂的促销活动、会员权益、运费计算、税费等多重因素的动态组合。一个高效、准确且灵活的算价系统，是支撑电商业务顺畅运行、保障用户体验并实现精准营销的关键基础设施。</p><p>传统的价格计算往往是线性的，但在现代电商场景下，各种促销活动层出不穷，如限时秒杀、满减优惠、多件打折、优惠券、会员专属价、包邮等等。这些促销可能相互关联，也可能相互独立，它们在不同类型、不同优先级上作用于商品价格，使得最终的用户支付价格变得异常复杂。如何在一个统一的框架下，清晰地定义价格的演变路径，高效地应用各类促销规则，并最终计算出准确的结算价格，成为了每个电商平台面临的巨大挑战。</p><p>通过对京东等头部电商平台算价模型的深入剖析，我们可以从中汲取宝贵的经验，理解其如何通过分层、模块化的设计来应对算价的复杂性，并为我们构建或优化电商算价系统提供重要的启示。本文将基于对算价模型设计原理的理解，对电商算价的各个核心环节进行深入探讨。</p><span id="more"></span><hr><h2 id="核心价格定义"><a href="#核心价格定义" class="headerlink" title="核心价格定义"></a>核心价格定义</h2><p>在电商算价体系中，促销是影响最终价格的核心变量。为了有效地管理和应用这些促销，算价系统通常会对价格进行多维度的定义和分阶段的计算。一个典型的电商算价系统会定义以下两种关键价格：</p><ul><li><p><strong>销售价</strong>：这是商品的原始标价，也是 SKU（最小库存单位）在系统中配置的基础价格。它不受任何促销活动的影响，是所有价格计算的起点。在商品详情页展示的往往就是这个价格，或者经过少量“基础优惠”后的价格，但系统内部计算仍以原价为基准。</p></li><li><p><strong>结算价</strong>：这是用户在电商平台最终需要支付的金额，也是订单确认后，系统在入账和退款时所依据的最终金额。结算价是所有促销应用后的最终价格，它直接决定了用户的实际支付体验和商家的实际收入。</p></li></ul><p>此外需要注意的是，<strong>单价</strong>和<strong>金额</strong>是两个密切相关但含义不同的概念。</p><p><strong>单价</strong>指的是单个商品或服务所对应的价格。它表示的是每单位物品的价值。例如，一本书的价格是 ¥50，那么 ¥50 就是这本书的单价；一公斤苹果的价格是 ¥10，那么 ¥10 就是苹果的单价。单价通常是计算总金额的基础。</p><p><strong>金额</strong>指的是购买或销售一定数量的商品或服务所产生的总价值。它是通过将<strong>单价</strong>与所购买或销售的<strong>数量</strong>相乘得出的。例如，如果您购买了3本书，每本书的单价是 ¥50，那么总金额就是 $3 \times ¥50 &#x3D; ¥150$。同样地，如果您购买了2公斤苹果，每公斤的单价是 ¥10，那么总金额就是 $2 \times ¥10 &#x3D; ¥20$。</p><p>在更复杂的电商算价场景中，金额的计算还会考虑各种促销、折扣、运费和税费等因素，使得最终的结算金额与简单的“单价乘以数量”有所不同。</p><p><img src="/resource/img/2025-07-24-13-48-13.png"></p><p>这张京东结算页的金额构成截图，清晰地展示了<strong>商品金额</strong>、<strong>运费</strong>、<strong>PLUS专享立减</strong>、<strong>立减</strong>、<strong>国家补贴</strong>、<strong>优惠券</strong>以及<strong>以旧换新</strong>等信息，最终得出<strong>合计</strong>支付金额。</p><p>至于这个价格是如何从初始的商品金额，经过一系列的优惠、补贴和抵扣，最终计算出合计支付金额的，接下来我们将对电商算价模型原理，逐步展开介绍。</p><hr><h2 id="链式算价与水平算价"><a href="#链式算价与水平算价" class="headerlink" title="链式算价与水平算价"></a>链式算价与水平算价</h2><p>在电商促销的实际应用中，存在两种主要的算价模式：链式算价（或称叠加算价）和水平算价（或称平行算价）。这两种模式在促销生效的顺序和基础价格的选取上有所不同，直接影响最终价格。</p><ul><li><p><strong>链式算价（Chain Pricing &#x2F; Stacked Pricing）</strong>：</p><ul><li><strong>定义</strong>：在链式算价模式下，每一种促销都是基于<strong>上一个促销应用后的价格</strong>进行计算。也就是说，优惠是层层叠加、逐级递减的。</li><li><strong>特点</strong>：<ul><li>促销应用顺序至关重要。不同的应用顺序可能导致不同的最终价格。</li><li>每次计算都基于当前最新价格，使得价格的演变过程像一条链条。</li></ul></li><li><strong>举例</strong>：商品原价100元。先打9折（优惠10元，价格变为90元），再满90减10元（优惠10元，价格变为80元）。这里的“满90”是基于90元计算的。优惠券常采用这种模式，即券的门槛和优惠额度是基于商品已有的折扣价来计算的。</li></ul></li><li><p><strong>水平算价（Parallel Pricing）</strong>：</p><ul><li><strong>定义</strong>：在水平算价模式下，所有的促销都是基于<strong>同一个基础价格</strong>（通常是商品原价）进行计算。然后，系统会选择所有促销中对用户最有利的那个（或多个可叠加的）。</li><li><strong>特点</strong>：<ul><li>促销之间相对独立，不直接影响彼此的计算基础。</li><li>最终价格通常是原价减去所有有效且最优的优惠总和。</li><li>常见于各类单品折扣、秒杀等活动，每个活动都直接针对原价进行优惠。</li></ul></li><li><strong>举例</strong>：商品原价100元。促销A：打9折（优惠10元）。促销B：满100减15元（优惠15元）。系统会比较10元和15元，选择15元的优惠，最终价格为85元。如果两个促销允许叠加，则最终价格为75元。</li></ul></li></ul><p>根据我们之前的内容，京东（或类似的复杂电商平台）的算价模型并非单纯地采用链式或水平算价，而是巧妙地将两者进行了融合。通常情况下，<strong>促销、优惠券和红包&#x2F;代币之间是链式算价关系</strong>：即促销优惠先作用于商品价格，得到一个促销价；然后优惠券再基于这个促销价进行计算；最后红包或代币再作用于优惠券计算后的价格。而在<strong>促销内部，不同促销之间又存在互斥和叠加规则</strong>，例如店铺设置的促销和平台促销之间可以设置叠加。</p><p>需要注意的是，链式算价在实现全局最优算价时，成本往往较高；而水平算价则不容易把控优惠力度，容易突破商品的成本价。这种分阶段的、不同算价模式融合的设计，使得系统能够灵活应对各种复杂的促销场景，既保证了效率，又兼顾了业务逻辑的准确性。</p><hr><h2 id="算价规则与优化：同类型互斥、跨类型叠加"><a href="#算价规则与优化：同类型互斥、跨类型叠加" class="headerlink" title="算价规则与优化：同类型互斥、跨类型叠加"></a>算价规则与优化：同类型互斥、跨类型叠加</h2><p>算价规则是整个算价模型的大脑，它决定了如何从众多符合条件的促销中，选择并组合出最终的优惠方案。电商算价系统在处理促销规则时，通常遵循以下核心原则：</p><ul><li><p><strong>同一商品在同一促销类型只能享受一种促销方式</strong>：</p><p>  这意味着在一个特定的促销类型（例如，促销级中的“基础折扣”类型，或券级中的“优惠券”类型），如果一个商品同时满足多个促销的条件，系统必须选择其中一个最有利的。例如，一件商品同时符合“限时折扣8折”和“会员价90元”两个促销级优惠条件，系统会比较哪个更优惠（例如原价100元，8折后80元，会员价90元，则选择8折），并只应用其中一种。这种规则是为了避免重复优惠或逻辑冲突。</p></li><li><p><strong>同一商品在不同类型可以享受优惠叠加</strong>：</p><p>  这是电商算价的核心魅力所在，也是用户获得“多重优惠”体验的基础。它意味着一个商品首先可以享受促销级的优惠（如秒杀价），然后在这个优惠价格的基础上，还可以叠加享受券级的优惠（如优惠券、满减）。</p><p>  例如，一件商品先享受了“秒杀”优惠，从原价100元降至80元（促销级优惠）。然后，用户又有一张“满80减10元”的优惠券（券级优惠），最终商品价格变为70元。这种跨类型的叠加，是实现总优惠最大化的重要途径。</p></li></ul><p><strong>算价流程与规则的体现：</strong></p><p>整个算价流程严格按照这种分层叠加的规则进行：</p><ol><li><strong>准备阶段</strong>：在正式算价之前，系统会进行一系列准备工作，包括检查商品服务、赠品等附加项，确保所有影响价格的因素都已纳入考量。</li><li><strong>促销级优惠计算</strong>：<ul><li>系统将所有购买项及它们的<strong>原价</strong>送入优惠网关。</li><li>优惠网关根据内部规则（结合促销源数据和“同一类型互斥”原则），计算出每个购买项在促销级别中的最优促销组合。</li><li>将这些优惠应用到原价上，得到每个购买项的<strong>促销价</strong>。</li></ul></li><li><strong>券级优惠计算</strong>：<ul><li>将所有购买项及它们已经计算出的<strong>促销价</strong>再次送入优惠网关。</li><li>优惠网关根据券级优惠规则（如优惠券、满减、满免运费等，同样遵循“同一类型互斥”原则），计算出最优的券级优惠组合。</li><li>将这些优惠应用到促销价上，得到每个购买项的<strong>结算价</strong>。</li></ul></li></ol><p>这种两阶段算价的设计，正是“跨类型叠加”规则的具象化体现，即促销级优惠先作用于原价，得到促销价；券级优惠再作用于促销价，得到结算价。</p><hr><h2 id="京东结算页：优惠构成与计算方式"><a href="#京东结算页：优惠构成与计算方式" class="headerlink" title="京东结算页：优惠构成与计算方式"></a>京东结算页：优惠构成与计算方式</h2><p><img src="/resource/img/2025-07-24-14-28-38.png"></p><p>这张截图展示了京东购物车结算页面的详细算价逻辑，它清晰地揭示了如何从商品总价计算出最终的合计支付金额。我们可以看到各个优惠项是如何累加或作用的。</p><p>以下是对算价逻辑的详细解读：</p><ol><li><p><strong>商品总价：¥2,306.00</strong><br> 这是所有选中商品的原始价格总和。</p></li><li><p><strong>共减：-¥333.91</strong><br> 该金额是各项优惠（促销、优惠券、PLUS专享立减、国家补贴）的总计。</p></li><li><p><strong>促销：-¥50.00</strong><br> 具体为“单品满1件减50元”，针对第三件商品（小计329.00）进行了50元的优惠。</p></li><li><p><strong>优惠券：-¥229.95</strong><br> 这部分是多张优惠券叠加后的总抵扣金额，其详细构成如下：</p><ul><li><strong>“满500减70”：</strong> 针对订单中第二件商品（小计1599.00），满足500元门槛，优惠70元。</li><li><strong>“满600减50”：</strong> 针对订单中第二件商品（小计1599.00），满足600元门槛，优惠50元。</li><li><strong>“满299减30”：</strong> 针对订单第一件商品（小计378.00），满足299元门槛，优惠30元。</li><li><strong>“政府消费券 满1减9.5折，最高减500元”：</strong> 对满足“满1”条件的商品金额（小计1599.00）进行了9.5折优惠，实际减少了¥79.95。</li><li><strong>优惠券总计：</strong> ¥70.00 + ¥50.00 + ¥30.00 + ¥79.95 &#x3D; <strong>¥229.95</strong>，与优惠券总金额完全吻合。</li></ul></li><li><p><strong>PLUS专享立减：-¥12.50</strong><br> 该优惠金额与结算页截图一致，是PLUS会员的专属优惠。</p></li><li><p><strong>国家补贴：-¥41.46</strong><br> 该优惠金额也与结算页截图一致，是国家提供的补贴，下方明确显示“国家补贴 | 已减41.46”。</p></li><li><p><strong>全选3件，合计：¥1,972.09</strong><br> 此金额与最终合计支付金额完全吻合。</p></li></ol><p>从上述算价逻辑中可以看出，针对<strong>金额为 ¥1599.00 的商品</strong>，同时应用了三张优惠券（满500减70、满600减50、政府消费券）。这清晰地说明了这<strong>三张优惠券可以互相叠加</strong>。此外，<strong>这些优惠券的触发门槛金额是基于商品的原始总价。</strong></p><p><img src="/resource/img/2025-07-24-14-49-55.png"></p><p>这张图片明确表达了用户可以在京东购物时，<strong>进入优惠券选择页面，根据自己的需求和优惠券的适用规则，主动勾选或取消勾选不同的优惠券，从而灵活地决定最终要使用的优惠组合。</strong> 系统会提供推荐，但最终的选择权在用户手中，除非优惠券本身有互斥等限制。</p><hr><h2 id="算价规则优先级：用户选择-系统选择"><a href="#算价规则优先级：用户选择-系统选择" class="headerlink" title="算价规则优先级：用户选择 &gt; 系统选择"></a>算价规则优先级：用户选择 &gt; 系统选择</h2><p>虽然算价系统会默认根据规则计算出“最优”的促销组合，但在实际用户体验中，用户往往有自己选择或放弃某些促销的需求。例如，用户可能有一张优惠券，虽然不是当前订单能使用的最大优惠，但可能是他想优先使用的。因此，一个完善的算价系统需要支持用户的主动干预，并且这种用户选择的优先级通常高于系统的自动选择。</p><p><strong>优先级策略：</strong></p><p>系统会设计一套优先级机制来处理用户主动选择与系统自动选择之间的冲突：</p><ol><li><strong>用户主动使用</strong>：如果用户明确指定要使用某个优惠（例如勾选了某张优惠券），那么系统会优先尝试应用这个优惠。如果这个促销与系统自动选择的优惠在同一类型且互斥，用户的选择会覆盖系统的默认选择。</li><li><strong>用户主动不使用</strong>：同样，如果用户明确指定不使用某个优惠，系统将不会考虑该优惠。这通常用于用户希望保留某些优惠券以供未来使用，或避免某些优惠带来的不便（例如需要凑单）。</li><li><strong>系统自动选择</strong>：这是默认行为。当用户没有进行明确的选择时，系统会根据预设的“最优策略”来自动匹配和应用促销。</li></ol><hr><h2 id="背包问题：运用背包问题求解最优促销组合"><a href="#背包问题：运用背包问题求解最优促销组合" class="headerlink" title="背包问题：运用背包问题求解最优促销组合"></a>背包问题：运用背包问题求解最优促销组合</h2><p>在电商算价的“最优组合”选择中，当商品数量和促销种类繁多时，这个问题本质上会转化为一个经典的<strong>背包问题</strong>。</p><p><strong>问题抽象：</strong></p><p>我们可以将这个问题抽象为：“有 $n$ 种促销和 $m$ 种商品。每一种促销支持 $[1-m]$ 种商品，并提供 $k$ 元的优惠金额。要求在同一商品在同一促销类型只能使用一种促销的前提下，如何选择促销组合，使得总的促销金额最大化？”</p><p>这个抽象与经典的0&#x2F;1背包问题（每个物品只能选择一次）或多重背包问题（每个物品可以选择多次）有相似之处，但又因其“同一商品只能享受一种促销”的限制而更加复杂。它更接近于<strong>带约束条件的组合优化问题</strong>。</p><p><strong>解决方案思路：</strong></p><p>解决这类问题通常会采用以下方法：</p><ol><li><strong>穷举法（或枚举法）</strong>：对于促销组合数量较小的情况，可以尝试枚举所有可能的促销组合，然后计算每种组合的总优惠金额，选择最大值。但随着商品和促销数量的增加，这种方法的计算量会呈指数级增长，很快变得不可行。</li><li><strong>动态规划（Dynamic Programming）</strong>：将大问题分解为小问题。例如，可以先计算每个商品在当前类型能享受的最大优惠。然后，在选择跨商品促销时，通过构建状态转移方程来找到最优解。这需要仔细定义状态和转移方程，以处理“同一商品只能享受一种促销”的约束。</li></ol><p><strong>在电商算价中的应用：</strong></p><p>在实际的电商算价中，考虑到对性能和用户体验的要求，通常会采用优化过的算法：</p><ul><li><strong>分阶段优化</strong>：将背包问题分解到每个促销类型进行。例如，先在促销类型优惠中解决一次背包问题，确定商品的促销价。再在平台类型解决一次背包问题，确定商品的结算价。</li><li><strong>商品维度拆分</strong>：对于可以拆分到单个商品的促销（如单品折扣），先计算每个商品的最优单品优惠。对于跨商品的促销（如满减），再考虑如何组合这些商品以触发最大优惠。</li><li><strong>用户干预的影响</strong>：当用户主动选择或放弃某个促销时，这会成为算法的硬性约束。算法需要在这些约束下，再次求解最优的剩余促销组合。这相当于为背包问题增加了一个或多个强制选择&#x2F;排除的物品。</li></ul><p>例如提供一个简单的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">有促销 A B C D</span><br><span class="line">有商品 a b c d</span><br><span class="line"></span><br><span class="line">其中促销情况如下：</span><br><span class="line">A a-100,b-200,c-100 (总优惠400)</span><br><span class="line">B b-300 (总优惠300)</span><br><span class="line">C c-200 (总优惠200)</span><br><span class="line">D d-200 (总优惠200)</span><br></pre></td></tr></table></figure><p>这里的核心约束是：一个商品只能使用一种促销。<br>如果选择A，则a, b, c都被A覆盖，b和c不能再享受B和C。总优惠400。<br>如果选择B，则b被B覆盖，a和c可以分别享受A的部分优惠，或者享受C。<br>显然，如果选择B (b-300)，C (c-200)，D (d-200)，a可以享受A中a的部分(100)。<br>这种情况下，总优惠为 $300(B) + 200(C) + 200(D) &#x3D; 700$。<br>如果选择A，总优惠才400。<br>因此，结果是选择B、C、D。如果A可以拆分只作用于a，那么A的a-100也可以加入，最终结果是B、C、D和A（作用于a），总优惠将是 $300+200+200+100 &#x3D; 800$。这取决于A是否可以部分使用。<br>文中示例的预期结果是 B、C、D，这暗示了A促销要么是整体生效，要么就是其总优惠低于B+C+D。在这种情况下，系统会计算出 B+C+D 的组合比 A 更优。</p><p>这个“背包问题”的求解是算价系统智能化的核心体现，它旨在在满足所有业务规则和用户意愿的前提下，为用户提供最大化的优惠，从而提升用户满意度和转化率。</p><hr><h2 id="优惠网关：统一接口，屏蔽多源差异，确保模型内聚性"><a href="#优惠网关：统一接口，屏蔽多源差异，确保模型内聚性" class="headerlink" title="优惠网关：统一接口，屏蔽多源差异，确保模型内聚性"></a>优惠网关：统一接口，屏蔽多源差异，确保模型内聚性</h2><p>在复杂的电商生态系统中，优惠数据可能来源于多个不同的系统或服务：有的可能来自商品管理系统，有的来自会员系统，有的来自营销活动平台，还有的可能来自第三方优惠券平台。这些不同的促销源，其数据结构、调用方式、计算逻辑可能大相径庭。直接在算价模型中集成这些多样化的促销源，会导致算价逻辑高度耦合，难以维护和扩展。</p><p>为了解决这个问题，<strong>优惠网关（Promotion Gateway）</strong> 应运而生。</p><p><strong>优惠网关的作用：</strong></p><ul><li><strong>统一接口</strong>：优惠网关向上层算价模型提供一套统一、标准化的接口，无论底层有多少种优惠源，算价模型都通过这一个接口与它们交互。这极大地简化了算价模型的复杂度。</li><li><strong>屏蔽底层差异</strong>：优惠网关内部负责处理与各个具体促销源的对接逻辑，包括数据转换、请求发送、结果解析、错误处理等。它将这些底层细节封装起来，使得算价模型无需关心促销数据的具体来源和格式。</li><li><strong>保障算价模型的内聚性</strong>：通过将促销逻辑与核心算价逻辑解耦，优惠网关确保了算价模型自身的职责单一，即专注于价格计算和最优组合的选择。这样，即使未来新增或修改促销类型，也只需调整优惠网关内部的实现，而不会影响到核心算价模型。</li><li><strong>可扩展性</strong>：当需要引入新的促销类型或接入新的促销系统时，只需在优惠网关内部添加新的适配器或处理器，而无需改动算价模型的代码。这使得系统能够灵活应对业务变化。</li><li><strong>性能优化</strong>：优惠网关也可以承担一些性能优化的职责，例如批量请求处理、异步调用等，以提高整体算价的响应速度。</li></ul><p>通过优惠网关的抽象，整个算价体系变得更加清晰、模块化和可维护，是构建高可用、高性能电商算价系统的关键设计。</p><hr><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>电商算价系统是支撑现代电商运营的复杂而核心的组件。通过对京东式算价模型的深度剖析，我们可以总结出其成功的关键在于：</p><ol><li><strong>分阶段价格定义与流转</strong>：将价格清晰地定义为销售价、促销价和结算价，并在不同阶段应用不同类型的促销，使得价格的演变路径清晰可循。</li><li><strong>融合式促销策略</strong>：巧妙地结合链式算价和水平算价的优点，既能满足促销级折扣的平行计算需求，又能适应优惠券等需要基于前序价格进行计算的场景。</li><li><strong>精确的算价规则</strong>：明确“同类型互斥、跨类型叠加”的核心规则，有效管理促销之间的关系，避免冲突并最大化用户优惠。</li><li><strong>智能优化与用户干预并存</strong>：运用背包问题等算法求解最优促销组合，同时尊重用户的主动选择，实现了效率与用户体验的平衡。</li><li><strong>模块化与解耦</strong>：引入优惠网关作为统一接口，有效屏蔽了底层促销来源的复杂性，保障了算价模型的内聚性、可扩展性和可维护性。</li><li><strong>全面性考量</strong>：将物流运费等服务商品纳入算价体系，体现了系统设计的全面性和严谨性。</li></ol><p>一个设计精良的电商算价模型，不仅能确保价格计算的准确性，还能为商家提供灵活多变的营销工具，更重要的是，它能为消费者带来清晰透明、最大化优惠的购物体验。随着电商业务的不断演进和新营销模式的出现，算价模型也将持续面临挑战和优化需求，但其分层、模块化和智能化的大方向将长期不变，持续为电商行业的繁荣发展提供核心驱动力。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在当今竞争激烈的电商环境中，价格是吸引消费者、提升转化率并最终实现商业目标的核心要素。然而，电商平台的商品价格并非简单地由标价决定，它涉及到复杂的促销活动、会员权益、运费计算、税费等多重因素的动态组合。一个高效、准确且灵活的算价系统，是支撑电商业务顺畅运行、保障用户体验并实现精准营销的关键基础设施。&lt;/p&gt;
&lt;p&gt;传统的价格计算往往是线性的，但在现代电商场景下，各种促销活动层出不穷，如限时秒杀、满减优惠、多件打折、优惠券、会员专属价、包邮等等。这些促销可能相互关联，也可能相互独立，它们在不同类型、不同优先级上作用于商品价格，使得最终的用户支付价格变得异常复杂。如何在一个统一的框架下，清晰地定义价格的演变路径，高效地应用各类促销规则，并最终计算出准确的结算价格，成为了每个电商平台面临的巨大挑战。&lt;/p&gt;
&lt;p&gt;通过对京东等头部电商平台算价模型的深入剖析，我们可以从中汲取宝贵的经验，理解其如何通过分层、模块化的设计来应对算价的复杂性，并为我们构建或优化电商算价系统提供重要的启示。本文将基于对算价模型设计原理的理解，对电商算价的各个核心环节进行深入探讨。&lt;/p&gt;</summary>
    
    
    
    
    <category term="系统设计" scheme="https://noogel.xyz/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>从淘宝看促销：解析电商促销模型</title>
    <link href="https://noogel.xyz/2025/07/23/1.html"/>
    <id>https://noogel.xyz/2025/07/23/1.html</id>
    <published>2025-07-23T00:00:00.000Z</published>
    <updated>2025-07-24T03:03:17.490Z</updated>
    
    <content type="html"><![CDATA[<p>在当今竞争激烈的电商环境中，促销活动已不再仅仅是简单的价格打折，而是驱动用户增长、提升销售额、清理库存乃至品牌建设的核心战略工具。一个设计精良的促销系统，是电商平台能否灵活应对市场变化、实现精细化运营的关键。本文将以淘宝的视角为切入点，深入剖析促销系统的核心概念、内部关系，以期为读者提供一个全面而深入的理解。</p><h3 id="一、促销系统的核心概念与内在关系"><a href="#一、促销系统的核心概念与内在关系" class="headerlink" title="一、促销系统的核心概念与内在关系"></a><strong>一、促销系统的核心概念与内在关系</strong></h3><p><img src="/resource/img/2025-07-24-00-02-13.png"></p><p>要构建一个强大而灵活的促销系统，首先需要明确其基石——核心概念，以及这些概念之间如何相互作用、构成一个有机整体。</p><span id="more"></span><p><strong>1. 促销池 (Promotion Pool)：万策之源</strong><br>促销池是整个促销系统的“心脏”，它承载着所有已定义、待生效或已过期的促销活动。你可以将其想象成一个巨大的容器，容纳着各种形式和规则的优惠策略。所有关于促销的创建、查询、管理和应用，都离不开这个核心的概念。它不仅是促销活动的存储库，更是系统进行促销筛选和匹配的起点。</p><p><strong>2. 促销范围 (Promotion Scope)：精准打击的靶心</strong><br>促销范围定义了特定促销活动适用的商品、品类、店铺乃至用户群体。它是实现促销“精准打击”的关键。没有范围的限定，促销就如同“大水漫灌”，无法针对特定目标发挥最大效用，甚至可能导致成本失控。常见的促销范围包括：</p><ul><li><strong>SKU (Stock Keeping Unit)</strong>：最细粒度的商品唯一标识。</li><li><strong>商品品类 (Product Category)</strong>：例如“数码产品”、“服饰鞋包”。</li><li><strong>品牌 (Brand)</strong>：针对特定品牌的商品进行促销。</li><li><strong>店铺 (Store)</strong>：针对特定商家店铺内的所有商品进行促销。</li><li><strong>用户标签&#x2F;等级 (User Tags&#x2F;Levels)</strong>：例如“新用户专属”、“VIP会员特惠”。</li></ul><p>促销范围的明确界定，是后续进行促销匹配和计算的前提。</p><p><strong>3. 促销配置 (Promotion Configuration)：规则与条件的蓝图</strong><br>促销配置是促销活动的具体规则和属性的集合，它是促销活动得以生效的“蓝图”。其复杂度决定了促销策略的灵活度。一个完整的促销配置通常包含以下关键要素：</p><ul><li><strong>促销ID (Promotion ID) &#x2F; 促销Key (PromoKey)</strong>：促销的唯一标识，方便系统内部管理和用户外部引用。</li><li><strong>促销类型 (Promotion Type)</strong>：定义了促销的优惠形式，例如：<ul><li><strong>满减 (Full Reduction)</strong>：满足一定金额或数量即减免。</li><li><strong>立减 (Direct Reduction)</strong>：直接减免一定金额。</li><li><strong>折扣 (Discount)</strong>：按比例打折。</li><li><strong>限时抢购&#x2F;秒杀 (Time-limited Rush&#x2F;Flash Sale)</strong>：在特定时间段内以极低价格出售。</li><li><strong>捆绑促销 (Bundle Promotion)</strong>：多件商品组合购买优惠。</li></ul></li><li><strong>有效期 (Begin Time &#x2F; End Time)</strong>：促销活动生效和失效的时间段。</li><li><strong>促销级别 (Level)</strong>：区分促销是由平台发起、店铺发起还是基础配置，这通常与促销优先级和费用承担方相关。</li><li><strong>促销状态 (Status)</strong>：表示促销的生命周期状态，如“草稿”、“在线”、“下线”、“过期”。</li><li><strong>促销规则 (Rule)</strong>：这是最复杂也是最核心的部分，定义了触发优惠的具体条件和优惠计算方式。例如：满X件、满Y元、购买指定商品组合等。</li><li><strong>用户限制 (User Dimension)</strong>：限制每个用户参与促销的次数、领取优惠券的数量等，防止恶意刷单或滥用。</li><li><strong>优惠优先级 (Promotion Priority)</strong>：当多个促销同时满足条件时，确定哪个促销优先应用或如何进行叠加&#x2F;互斥。</li></ul><p>这些核心概念相互关联，构成了一个立体的促销模型：促销池是所有促销配置的集合，每个促销配置都定义了具体的促销类型、规则和生效时间，并通过促销范围精准地作用于特定的商品或用户。促销配置中的<strong>规则</strong>设计，是整个促销系统灵活性和表达能力的核心。在实际实现中，规则配置主要有两种方案：</p><p><strong>1. 方案一：自定义领域特定语言（DSL）</strong></p><p>自定义DSL是一种专门为特定领域问题设计的编程语言。在促销系统场景下，它表现为一套简洁、直观的指令集和语法，使得运营人员或配置工具能够以接近自然语言的方式来定义促销规则。</p><p>自定义DSL的核心在于抽象和简化。它将复杂的业务逻辑封装成一系列预定义的“指令”和“函数”，比如：</p><ul><li><strong>条件-执行指令（WHEN…THEN）</strong>：用于定义具体的触发条件和执行动作，例如 <code>WHEN HAS(SKU:XXX) THEN DOSCOUNT(80)</code>，明确表示“当某个SKU存在时，该商品打八折”。这种结构清晰地表达了“如果…就…”的业务逻辑。</li><li><strong>资源标识符</strong>：例如 <code>SKU:12312312313</code>、<code>CATEGORY:123123123213</code>，以统一的格式标识促销作用的实体。</li></ul><p>系统内部会包含一个DSL解析器和执行器。解析器将DSL文本转换为内部可执行的数据结构（如抽象语法树或指令序列），执行器则根据这些指令，结合当前的购物车数据、用户信息等“事实”，来计算并应用促销。</p><p><strong>2. 方案二：引入外部规则引擎（如Drools）</strong></p><p>引入外部规则引擎是将业务规则管理能力外包给一个成熟的、专用的软件系统。它将业务规则从应用程序代码中彻底剥离，并提供一套独立的规则定义、管理和执行机制。Drools是其中一个非常流行的开源选择。</p><p>规则引擎的核心理念是<strong>基于事实（Facts）进行模式匹配和规则触发</strong>。在促销系统中，购物车、商品、用户、订单等业务对象都是“事实”。规则引擎会持续评估这些事实，一旦满足某个规则的<code>WHEN</code>（条件）部分，就会触发其<code>THEN</code>（动作）部分。</p><p>集成Drools到促销系统的一般流程如下：</p><ol><li><p><strong>定义领域模型（Facts）</strong>：将促销所需的业务数据（如商品SKU、价格、数量、用户等级、购物车总价等）映射为Plain Old Java Objects (POJOs)，这些对象将在运行时作为“事实”被插入到规则引擎中。</p></li><li><p><strong>编写规则（Rules）</strong>：使用Drools Rule Language (DRL) 或决策表、决策树来编写促销规则。DRL规则语法强大，支持复杂的逻辑运算符、集合操作、内建函数等。例如：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rule &quot;满100减20&quot;</span><br><span class="line">    when</span><br><span class="line">        $cart : Cart(totalAmount &gt;= 100) // 购物车总金额大于等于100</span><br><span class="line">    then</span><br><span class="line">        $cart.applyDiscount(20); // 购物车应用20元优惠</span><br><span class="line">        update($cart); // 通知引擎事实已改变</span><br><span class="line">end</span><br></pre></td></tr></table></figure></li><li><p><strong>构建知识库（Knowledge Base）</strong>：将编写好的DRL文件编译成<code>KieBase</code>（知识库），这是一个包含了所有规则的运行时组件。</p></li><li><p><strong>创建会话（Session）</strong>：在应用程序运行时，创建<code>KieSession</code>（或<code>StatelessKieSession</code>），这是一个执行规则的上下文。</p></li><li><p><strong>插入事实</strong>：将当前请求的业务数据（购物车、用户等）作为事实插入到会话中。</p></li><li><p><strong>触发规则</strong>：调用<code>kieSession.fireAllRules()</code>，引擎会根据Rete算法高效地匹配所有规则并执行被触发的规则。</p></li><li><p><strong>获取结果</strong>：规则执行完毕后，从会话中提取被修改的事实对象或收集到的结果（如优惠金额列表），返回给业务逻辑层。</p></li></ol><h3 id="二、促销系统的关键系统设计"><a href="#二、促销系统的关键系统设计" class="headerlink" title="二、促销系统的关键系统设计"></a><strong>二、促销系统的关键系统设计</strong></h3><p>在理解了核心概念和规则配置方案后，接下来我们将深入探讨促销系统的关键设计模块和流程。</p><p><strong>1. 促销创建流程：从策略到配置</strong></p><p>创建促销是一个将营销策略转化为系统可执行配置的过程。该流程通常包括以下步骤：</p><ol><li><strong>策略制定与范围圈定</strong>：运营人员根据市场分析和营销目标，制定促销策略，并明确促销的目标商品或用户范围（如某个品类、一批SKU、新用户）。</li><li><strong>促销绑定与规则定义</strong>：针对已圈定的范围，选择合适的促销类型（如满减、折扣），并详细定义其触发条件和优惠力度。例如，指定“满2件8.8折”的规则，或“A商品减20元，B商品减30元”的减扣规则。这些规则的定义，将依据上述DSL或规则引擎方案进行配置。</li><li><strong>时效与状态管理</strong>：设置促销的生效和失效时间，以及初始状态（如“草稿”或“在线”）。</li><li><strong>元信息补充</strong>：录入促销描述、活动ID、费用承担方等辅助信息。</li><li><strong>提交与审核</strong>：完成配置后，提交系统进行校验和可能的审批流程，确保促销配置的合法性和准确性。</li></ol><p><strong>2. 促销筛选过程：实时匹配与优惠计算</strong></p><p>促销筛选是系统运行时最核心、最频繁的流程，它需要在用户浏览商品或提交订单时，快速准确地识别出所有适用的促销活动并计算优惠。</p><ol><li><strong>商品集合输入 (X)</strong>：用户购物车中的商品列表，或正在浏览的单个商品。</li><li><strong>在线促销检索 (Y)</strong>：系统首先从“促销池”中，根据商品集合 <code>X</code> 的基本信息（如商品ID、品类ID），快速筛选出所有<strong>可能相关且处于在线状态</strong>的促销配置集合 <code>Y</code>。这一步通常会利用缓存和索引进行优化，以提高检索效率。</li><li><strong>可用性计算（核心判决）</strong>：对 <code>Y</code> 中的每个促销 <code>y</code>，进行详细的可用性计算：<ul><li><strong>范围过滤 (X’ &#x3D; X ∩ y.scope_list)</strong>：将输入的商品集合 <code>X</code> 与当前促销 <code>y</code> 的适用范围 <code>y.scope_list</code> 进行交叉过滤，得到真正属于该促销范围的商品子集 <code>X&#39;</code>。不属于范围的商品将直接被排除。</li><li><strong>规则匹配 (y.rule)</strong>：将 <code>X&#39;</code> 应用到 <code>y.rule</code> 上。系统会判断 <code>X&#39;</code> 是否满足促销触发条件（例如，商品数量是否达到2件、总金额是否达到100元）。具体执行机制取决于采用的规则配置方案（DSL解析执行或Drools规则引擎）。</li><li><strong>优惠金额计算</strong>：如果规则匹配成功，系统将根据 <code>y.rule</code> 定义的优惠方式，精确计算出 <code>X&#39;</code> 中每个商品应享受的优惠金额，以及该促销活动的总优惠金额。</li></ul></li><li><strong>结果聚合与返回 (Y’)</strong>：将所有满足条件并计算出优惠的促销活动收集起来，形成一个促销列表 <code>Y&#39;</code>，返回给调用方。每个促销结果中，不仅包含总优惠金额，还需详细列出每个参与优惠的商品及其分摊到的具体优惠金额，这对于订单详情展示和后续财务分账至关重要。</li></ol><h3 id="三、从淘宝看促销"><a href="#三、从淘宝看促销" class="headerlink" title="三、从淘宝看促销"></a><strong>三、从淘宝看促销</strong></h3><img src="/resource/img/2025-07-24-00-41-43.png" width=260 /><p>在上面图片中，我们可以看到一个购物车的“金额明细”界面，其中明确展示了不同层级的优惠。</p><p>最显著的是 <strong>“店铺优惠 减 ¥34.19”</strong>。这与上文提到的“促销配置”中的“促销级别”概念紧密相关。店铺优惠通常是由商家（如“太力官方旗舰店”）自主设置的促销活动，其优惠力度和规则由店铺决定，属于<strong>店铺级别</strong>的促销。</p><p>具体到明细中，可以看到“太力官方旗舰店”下的商品享受了以下店铺级促销：</p><ul><li><strong>“超级立减”</strong>：小计 ¥7.90，减 ¥1.19。这是一种直接针对单个商品的折扣或立减优惠。</li><li><strong>“百亿补贴”</strong>：小计 ¥93.40，减 ¥3.00。虽然名为“百亿补贴”，但在这里它被归类到店铺名下，表明这部分补贴是由该店铺承担或与平台合作在店铺内生效的。</li><li><strong>“智能单品补贴”</strong>：小计 ¥93.40，减 ¥10.00。这同样是一种针对单个商品进行的补贴，可能通过智能算法匹配。</li><li><strong>“满45元减20元”</strong>：小计 ¥61.90，减 ¥20.00。这是一个典型的“满减”促销，商品金额达到45元即可减20元。</li></ul><p>这些优惠都是“店铺优惠”的组成部分，反映了促销系统能够支持不同商家在自身权限范围内配置和执行多样化促销策略的能力。这与“促销范围”中的“店铺”维度以及“促销类型”中的“满减”、“立减”等具体类型相符，体现了促销配置的灵活性。</p><p>值得注意的是，在当前的“金额明细”展示中，我们尚未看到优惠券类型优惠的详细拆解。在电商促销模型中，优惠券通常作为一种独立的促销类型存在，它拥有自身的领取、使用规则、有效期和适用范围。其在最终价格计算中的作用和叠加逻辑，将在后续的算价环节中进行详细介绍和体现。这进一步说明了促销系统需要处理多层级、多类型的优惠叠加与互斥，以最终得出用户实际支付金额的复杂性。</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a><strong>结语</strong></h3><p>促销系统是电商平台不可或缺的增长引擎。一个优秀的促销系统设计，不仅需要对各种促销类型有深刻的理解，更要能将复杂的业务逻辑抽象为清晰的领域模型，并通过健壮的技术架构实现高效的创建、筛选和应用。从核心概念的明确到灵活的规则配置（无论是DSL还是规则引擎），再到高效的筛选流程，每一步都至关重要。只有这样，促销系统才能真正成为助力电商企业实现持续增长的强大武器。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在当今竞争激烈的电商环境中，促销活动已不再仅仅是简单的价格打折，而是驱动用户增长、提升销售额、清理库存乃至品牌建设的核心战略工具。一个设计精良的促销系统，是电商平台能否灵活应对市场变化、实现精细化运营的关键。本文将以淘宝的视角为切入点，深入剖析促销系统的核心概念、内部关系，以期为读者提供一个全面而深入的理解。&lt;/p&gt;
&lt;h3 id=&quot;一、促销系统的核心概念与内在关系&quot;&gt;&lt;a href=&quot;#一、促销系统的核心概念与内在关系&quot; class=&quot;headerlink&quot; title=&quot;一、促销系统的核心概念与内在关系&quot;&gt;&lt;/a&gt;&lt;strong&gt;一、促销系统的核心概念与内在关系&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/resource/img/2025-07-24-00-02-13.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;要构建一个强大而灵活的促销系统，首先需要明确其基石——核心概念，以及这些概念之间如何相互作用、构成一个有机整体。&lt;/p&gt;</summary>
    
    
    
    
    <category term="系统设计" scheme="https://noogel.xyz/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>折腾 Docker 管理：一个自力更生的 DinD 工具是怎么来的</title>
    <link href="https://noogel.xyz/2025/06/02/1.html"/>
    <id>https://noogel.xyz/2025/06/02/1.html</id>
    <published>2025-06-02T00:00:00.000Z</published>
    <updated>2025-07-24T08:04:14.760Z</updated>
    
    <content type="html"><![CDATA[<p>说起来，玩 Docker 的朋友估计都有同样的感受：这玩意儿好用是好用，但管起来真有点头疼。市面上不是没有工具，像 Portainer 这种，功能是强大，可总觉得有点“重”。对于我这种只想简单管理几个服务、又不想折腾太多配置的人来说，它就像是开着一辆大卡车去买菜，有点过了。而且，它那套数据备份机制，说实话，我一直觉得不太顺手，总担心哪天数据丢了咋办。</p><p>正是因为这些小烦恼，心里就一直琢磨着，能不能自己搞一个更轻便、更好用的 Docker 管理工具呢？毕竟，自己的需求自己最清楚。加上这几年 AI 编程发展得挺快，就想着是不是能借力 AI，把这个想法落地。说干就干，断断续续地折腾了一阵子，还真捣鼓出来一个“Docker in Docker”的维护工具。为啥是 Docker in Docker 呢？因为我觉得这样管理起来更方便，整个工具本身也是一个 Docker 容器，便于部署和迁移，而且特别符合我对“轻量”的追求。</p><p><img src="/resource/img/2025-07-24-15-31-32.png"></p><span id="more"></span><hr><h3 id="从“麻烦”到“方便”：这工具到底解决了啥？"><a href="#从“麻烦”到“方便”：这工具到底解决了啥？" class="headerlink" title="从“麻烦”到“方便”：这工具到底解决了啥？"></a>从“麻烦”到“方便”：这工具到底解决了啥？</h3><p>一开始，我的出发点就很简单：让管理 Docker 容器变得像管理文件一样方便。所以，这个工具的核心思想就是基于 <strong>Docker Compose</strong> 来维护服务。Compose 文件嘛，大家都知道，就是用 YAML 格式描述你的服务栈，简单明了。把管理重点放在 Compose 文件上，就天然地实现了像文件系统一样的管理方式。</p><p><img src="/resource/img/2025-07-24-15-47-55.png"></p><p>下面，我跟大家聊聊，这个工具目前都能干点啥，解决了我的哪些痛点：</p><h4 id="1-Compose-文件管理：就像管理普通文件一样"><a href="#1-Compose-文件管理：就像管理普通文件一样" class="headerlink" title="1. Compose 文件管理：就像管理普通文件一样"></a>1. Compose 文件管理：就像管理普通文件一样</h4><p>这是我觉得最核心的功能。以前，Compose 文件散落在各个地方，管理起来比较乱。现在，我把所有的 Compose 文件都集中管理起来。</p><ul><li><strong>编辑、启动、停止：</strong> 你可以直接在界面上看到你的所有 Compose 项目，点一点就能编辑 YAML 文件，保存后直接启动、停止。再也不用每次都敲 <code>docker-compose up -d</code> 或者 <code>docker-compose down</code> 了。特别是修改配置后，直接在界面上改，保存即生效，这效率一下就上来了。</li><li><strong>版本控制和备份：</strong> 因为是基于文件系统来管理 Compose 文件，所以这个工具和 NAS（网络附加存储）简直是绝配。NAS 通常都有非常成熟的快照和备份功能。这意味着，我的所有 Docker 服务配置，都像普通文件一样，可以轻松地做快照，做增量备份。就算哪天不小心改错了 Compose 文件，或者机器硬盘挂了，也能非常方便地恢复到之前的状态。这点对数据安全来说，简直是福音。想想以前，如果 Portainer 的数据损坏了，那种抓狂的感觉……现在完全不用担心了。</li></ul><h4 id="2-容器日志检查：一眼看穿问题所在"><a href="#2-容器日志检查：一眼看穿问题所在" class="headerlink" title="2. 容器日志检查：一眼看穿问题所在"></a>2. 容器日志检查：一眼看穿问题所在</h4><p>服务跑起来了，最怕的就是出问题。出问题了，第一个想到的就是看日志。</p><ul><li><strong>实时查看日志：</strong> 这个工具可以直接查看运行中容器的实时日志。你不需要 SSH 登录服务器，也不用敲 <code>docker logs</code> 命令，直接在网页上就能看到日志输出。这对于快速排查问题来说，简直是太方便了。特别是有些服务日志刷得飞快，能实时看到，效率高很多。</li><li><strong>筛选和搜索：</strong> 当然，日志多了也容易眼花。我还在考虑加上一些日志筛选和搜索功能，比如按关键词搜索、按时间段过滤，这样就能更快地定位到关键信息。目前虽然还比较基础，但已经比没有好太多了。</li></ul><h4 id="3-镜像管理：瘦身和加速下载两不误"><a href="#3-镜像管理：瘦身和加速下载两不误" class="headerlink" title="3. 镜像管理：瘦身和加速下载两不误"></a>3. 镜像管理：瘦身和加速下载两不误</h4><p>Docker 玩久了，镜像会越来越多，硬盘空间也会越来越紧张。</p><ul><li><strong>拉取和删除镜像：</strong> 这个工具可以很方便地拉取新的镜像，也能删除不再需要的镜像。界面上能清晰地看到本地有哪些镜像，占用了多少空间。定期清理一下，保持系统“身材”，挺重要的。</li><li><strong>代理设置：</strong> 这个功能真是解决了一个大痛点！在国内，大家拉取 Docker 镜像经常会遇到网络问题，慢得让人抓狂，甚至直接超时。我把代理设置功能集成进来了，你可以直接配置 Docker Daemon 的代理，这样以后拉取镜像就快多了，再也不用眼巴巴地看着进度条了。对于经常需要拉取新镜像的朋友来说，这简直是救星。</li></ul><h4 id="4-运行统计：对资源使用情况心里有数"><a href="#4-运行统计：对资源使用情况心里有数" class="headerlink" title="4. 运行统计：对资源使用情况心里有数"></a>4. 运行统计：对资源使用情况心里有数</h4><p>虽然是个轻量工具，但对系统资源的监控也不能少。</p><ul><li><strong>CPU、内存、网络使用：</strong> 工具能显示各个容器的 CPU、内存占用情况，以及网络流量。这样你就能大致了解哪些服务是“耗电大户”，哪些服务跑得比较轻。对于优化资源分配，或者判断服务是否正常运行，都有很大帮助。虽然不是专业的监控工具，但对于个人使用来说，足够了。</li></ul><h4 id="5-最近活动：一目了然的操作记录"><a href="#5-最近活动：一目了然的操作记录" class="headerlink" title="5. 最近活动：一目了然的操作记录"></a>5. 最近活动：一目了然的操作记录</h4><p>谁操作了什么，什么时候操作的，这些信息有时候挺重要的。</p><ul><li><strong>操作日志：</strong> 工具会记录一些最近的操作，比如哪个 Compose 项目被启动了，哪个镜像被删除了等等。这样你就能知道系统最近发生了什么，也方便追溯一些异常操作。</li></ul><h4 id="6-接入群晖-SSO-登录：为了方便，也为了安全"><a href="#6-接入群晖-SSO-登录：为了方便，也为了安全" class="headerlink" title="6. 接入群晖 SSO 登录：为了方便，也为了安全"></a>6. 接入群晖 SSO 登录：为了方便，也为了安全</h4><p>因为我自己是群晖 NAS 用户，经常会用到群晖的 SSO（单点登录）功能。为了方便，也为了安全性，我把这个工具接入了群晖 SSO。</p><ul><li><strong>无缝登录：</strong> 这样一来，我可以直接用群晖账号登录这个 Docker 管理工具，不用再单独记住一套账号密码。方便不说，安全性也提高了不少，毕竟群晖的账号通常都会设置两步验证。</li></ul><hr><h3 id="AI-辅助编程：这工具咋来的？"><a href="#AI-辅助编程：这工具咋来的？" class="headerlink" title="AI 辅助编程：这工具咋来的？"></a>AI 辅助编程：这工具咋来的？</h3><p>讲到这里，估计有朋友会好奇，这些功能都是怎么实现的？老实说，我不是专业的全栈开发者，很多技术点我之前都不是很熟悉。这次能够把这个工具落地，<strong>AI 辅助编程</strong>功不可没。</p><p>可以说，这个工具 90% 以上的代码，都是在 AI 的帮助下完成的。一开始，我只是把我的想法和需求告诉 AI，比如“我需要一个网页界面，可以上传 Docker Compose 文件”，“我需要能实时查看容器日志”。AI 会根据我的描述，生成一些代码片段，或者提供一些实现思路。</p><p>在开发过程中，可以直接截图沟通，粘贴错误代码、错误运行日志，或者进行功能沟通、页面拆分等，尽量不要直接手动修改代码。实际发现手动修改后会影响 AI 对代码库的理解。有时候，AI 提供的代码可能不是最完美的，甚至会有一些小错误，但它提供了一个非常好的起点。</p><p>这种开发模式，让一个本来对前端都不算精通的人，也能独立开发出一些实用的工具。它大大降低了开发的门槛，让更多有想法的人有机会把想法变成现实。让 AI 根据我的需求来创建，先上一个万能模板，后续可以直接修改关键信息让 AI 生成不同的项目。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">你是一位产品经理+UI设计师+全栈工程师，同时精通UI设计，基于当前 docker compose html 页面进行全面修改：</span><br><span class="line">1、使用FontAwesome等开源图标库，让原型显得更精美和接近真实i0S/Android设计规范的界面； </span><br><span class="line">2、引入tailwind css来完成，而不是变成style样式，图片使用unsplash；</span><br><span class="line">3、结合现有页面功能，美化界面展示样式，对于按钮弹窗和列表进行优化，考虑后端接口响应速度慢优化操作体验；</span><br><span class="line">4、以设计师的视角去输出完整的UI/UX，以产品经理的视角去规划APP的功能、页面和交互,要求移动设备自适应；</span><br><span class="line">5、使用 flask 模板 + Python，输出 index.html，可以通过多个模板页面，内容完整。</span><br></pre></td></tr></table></figure><h3 id="未来展望：还有哪些可以折腾的？"><a href="#未来展望：还有哪些可以折腾的？" class="headerlink" title="未来展望：还有哪些可以折腾的？"></a>未来展望：还有哪些可以折腾的？</h3><p>虽然这个工具已经解决了我的不少痛点，但肯定还有很多可以改进和扩展的地方。</p><ul><li><strong>更完善的监控：</strong> 比如可以加入更多的容器性能指标，做成图表展示，让资源使用情况更直观。</li><li><strong>模板功能：</strong> 可以预设一些常用的 Compose 模板，这样创建新服务的时候就更快了。</li><li><strong>Web Shell：</strong> 如果能直接在网页上提供一个容器的 Shell 界面，那排查问题就更方便了。</li></ul><p>当然，所有这些，都会继续秉承“轻量”、“易用”的原则。我还是希望它能保持简洁，而不是变成一个大而全、功能臃肿的工具。</p><hr><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>折腾这个 Docker 管理工具，从最开始的一个小念头，到现在能基本满足我的日常需求，整个过程还是挺有意思的。它让我体会到了“自己动手，丰衣足食”的乐趣，也让我看到了 AI 辅助编程的巨大潜力。目前这个工具仅仅应用在我的 NAS 上管理众多的 docker 服务，后续优化后再考虑开源出来。</p><p>这个工具可能不像那些专业的商业产品那么光鲜亮丽，但它是我根据自己的实际需求，一点点打磨出来的。它简单、实用，对我来说，这就够了。如果你也有类似的烦恼，或者对这种“轻量级”的 Docker 管理方式感兴趣，也许我的这些折腾能给你一些启发。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;说起来，玩 Docker 的朋友估计都有同样的感受：这玩意儿好用是好用，但管起来真有点头疼。市面上不是没有工具，像 Portainer 这种，功能是强大，可总觉得有点“重”。对于我这种只想简单管理几个服务、又不想折腾太多配置的人来说，它就像是开着一辆大卡车去买菜，有点过了。而且，它那套数据备份机制，说实话，我一直觉得不太顺手，总担心哪天数据丢了咋办。&lt;/p&gt;
&lt;p&gt;正是因为这些小烦恼，心里就一直琢磨着，能不能自己搞一个更轻便、更好用的 Docker 管理工具呢？毕竟，自己的需求自己最清楚。加上这几年 AI 编程发展得挺快，就想着是不是能借力 AI，把这个想法落地。说干就干，断断续续地折腾了一阵子，还真捣鼓出来一个“Docker in Docker”的维护工具。为啥是 Docker in Docker 呢？因为我觉得这样管理起来更方便，整个工具本身也是一个 Docker 容器，便于部署和迁移，而且特别符合我对“轻量”的追求。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/resource/img/2025-07-24-15-31-32.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="项目" scheme="https://noogel.xyz/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>FUST 与 DeepSeek：构建智能问答系统的实践探索</title>
    <link href="https://noogel.xyz/2025/04/28/1.html"/>
    <id>https://noogel.xyz/2025/04/28/1.html</id>
    <published>2025-04-28T00:00:00.000Z</published>
    <updated>2025-07-27T15:29:54.023Z</updated>
    
    <content type="html"><![CDATA[<p>近年来，随着大型语言模型的快速发展，智能问答系统已经成为企业提升用户体验、降低客服成本的重要工具。本文将介绍如何利用知乎开源的FUST微服务框架和DeepSeek API，搭建一个高性能、可扩展的智能问答系统。</p><p>FUST 谐音 Fast，是知乎开发的一款基于Spring Boot的微服务开发框架，旨在帮助开发者快速构建高质量的微服务应用。它集成了主流组件，提供标准化的开发范式，并在知乎的大规模生产环境经受了考验。</p><p>我们将通过实现一个名为”Deep QA”的项目，展示如何将FUST框架与DeepSeek API结合，构建一个功能完善的智能问答系统。</p><p><img src="/resource/img/2025-07-24-20-22-51.png"></p><span id="more"></span><h2 id="二、技术栈概述"><a href="#二、技术栈概述" class="headerlink" title="二、技术栈概述"></a>二、技术栈概述</h2><h3 id="2-1-FUST框架"><a href="#2-1-FUST框架" class="headerlink" title="2.1 FUST框架"></a>2.1 FUST框架</h3><p>FUST是基于Spring Boot 3.x开发的微服务框架，具有以下优势：</p><ul><li><strong>开箱即用</strong>：集成主流组件，提供标准化的开发范式</li><li><strong>高性能</strong>：基于高性能的Spring Boot 3.x和Armeria构建</li><li><strong>可观测性</strong>：内置完整的监控和追踪方案</li><li><strong>灵活扩展</strong>：提供丰富的扩展点，满足各种定制需求</li><li><strong>生产验证</strong>：在知乎大规模生产环境经受考验</li></ul><h3 id="2-2-DeepSeek-API"><a href="#2-2-DeepSeek-API" class="headerlink" title="2.2 DeepSeek API"></a>2.2 DeepSeek API</h3><p>DeepSeek提供了一系列强大的语言模型API，包括：</p><ul><li><strong>deepseek-chat</strong>：通用对话模型</li><li><strong>deepseek-coder</strong>：代码生成和理解模型</li></ul><h2 id="三、项目架构"><a href="#三、项目架构" class="headerlink" title="三、项目架构"></a>三、项目架构</h2><p>Deep QA采用经典的多模块微服务架构，主要包含以下两个核心模块：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">deep-qa/</span><br><span class="line">├── deep-qa-api/                  # HTTP API模块</span><br><span class="line">│   └── src/</span><br><span class="line">│       ├── main/java/com/deepqa/api/</span><br><span class="line">│       │   ├── config/           # 配置类</span><br><span class="line">│       │   ├── controller/       # 控制器</span><br><span class="line">│       │   └── dto/              # 数据传输对象</span><br><span class="line">│       └── main/resources/</span><br><span class="line">│           ├── static/           # 静态资源</span><br><span class="line">│           ├── templates/        # Thymeleaf模板</span><br><span class="line">│           └── application.properties # 应用配置</span><br><span class="line">├── deep-qa-business/             # 业务逻辑模块</span><br><span class="line">│   └── src/</span><br><span class="line">│       └── main/java/com/deepqa/business/</span><br><span class="line">│           ├── client/           # 外部服务客户端</span><br><span class="line">│           ├── dao/              # 数据访问对象</span><br><span class="line">│           ├── model/            # 数据模型</span><br><span class="line">│           └── service/          # 业务服务</span><br><span class="line">│               └── impl/         # 服务实现</span><br><span class="line">└── proto/                        # Protocol Buffers定义</span><br><span class="line">    ├── buf.yaml                  # Buf模块配置</span><br><span class="line">    └── hello.proto               # 示例服务Proto定义</span><br></pre></td></tr></table></figure><p>这种模块化设计有以下优势：</p><ol><li><strong>关注点分离</strong>：API层负责处理HTTP请求和响应，业务层负责核心业务逻辑</li><li><strong>代码复用</strong>：业务逻辑可以被不同的接口层（HTTP、gRPC）复用</li><li><strong>便于测试</strong>：各层可以独立测试</li><li><strong>维护简单</strong>：模块边界清晰，降低了代码耦合度</li></ol><h2 id="四、环境准备"><a href="#四、环境准备" class="headerlink" title="四、环境准备"></a>四、环境准备</h2><p>在开始项目开发前，需要准备以下环境：</p><ol><li><strong>JDK 17+</strong></li><li><strong>Maven 3.8+</strong></li><li><strong>MySQL 5.7+</strong></li><li><strong>Redis 6.0+</strong></li><li><strong>DeepSeek API密钥</strong></li></ol><p>由于FUST框架尚未发布到Maven中央仓库，需要先将其发布到本地Maven仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 克隆FUST仓库</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/zhihu/fust.git</span><br><span class="line"><span class="built_in">cd</span> fust</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发布到本地Maven仓库</span></span><br><span class="line">./gradlew publishToMavenLocal</span><br></pre></td></tr></table></figure><h2 id="五、项目实现"><a href="#五、项目实现" class="headerlink" title="五、项目实现"></a>五、项目实现</h2><h3 id="5-1-项目配置"><a href="#5-1-项目配置" class="headerlink" title="5.1 项目配置"></a>5.1 项目配置</h3><p>首先，我们来看父项目的<code>pom.xml</code>配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zhihu.fust<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fust-boot-bom<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>deep-qa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.deepqa<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 依赖配置... --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>deep-qa-business<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>deep-qa-api<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意这里使用了FUST框架的<code>fust-boot-bom</code>作为父项目，这样就可以统一管理FUST相关依赖的版本。</p><h3 id="5-2-数据模型设计"><a href="#5-2-数据模型设计" class="headerlink" title="5.2 数据模型设计"></a>5.2 数据模型设计</h3><p>在<code>deep-qa-business</code>模块中，我们定义了以下主要数据模型：</p><h4 id="5-2-1-聊天历史模型"><a href="#5-2-1-聊天历史模型" class="headerlink" title="5.2.1 聊天历史模型"></a>5.2.1 聊天历史模型</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Table(name = TABLE_NAME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatHistoryModel</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TABLE_NAME</span> <span class="operator">=</span> <span class="string">&quot;t_chat_history&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 主键ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@DbAutoColumn</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime createdAt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@DbAutoColumn</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime updatedAt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Long userId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 会话ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String sessionId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 角色(user/assistant)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String role;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否包含图片</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Boolean hasImage;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 图片URL</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String imageUrl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们使用了<code>@DbAutoColumn</code>注解来标记自动填充的字段，FUST框架会自动处理这些字段的创建和更新。</p><h3 id="5-3-数据访问层"><a href="#5-3-数据访问层" class="headerlink" title="5.3 数据访问层"></a>5.3 数据访问层</h3><p>数据访问层使用MyBatis实现，FUST框架提供了<code>TemplateDao</code>接口，简化了常见的CRUD操作。以<code>ChatHistoryDao</code>为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ChatHistoryDao</span> <span class="keyword">extends</span> <span class="title class_">TemplateDao</span>&lt;ChatHistoryModel&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过用户ID和会话ID查询对话记录</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Select(&#123;&quot;SELECT * FROM &quot;, ChatHistoryModel.TABLE_NAME,</span></span><br><span class="line"><span class="meta">            &quot; WHERE user_id = #&#123;userId&#125; AND session_id = #&#123;sessionId&#125; ORDER BY created_at ASC&quot;&#125;)</span></span><br><span class="line">    <span class="meta">@ResultMap(&quot;ChatHistoryModel&quot;)</span></span><br><span class="line">    List&lt;ChatHistoryModel&gt; <span class="title function_">findByUserIdAndSessionId</span><span class="params">(<span class="meta">@Param(&quot;userId&quot;)</span> Long userId, <span class="meta">@Param(&quot;sessionId&quot;)</span> String sessionId)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除会话记录</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Delete(&#123;&quot;DELETE FROM &quot;, ChatHistoryModel.TABLE_NAME, &quot; WHERE user_id = #&#123;userId&#125; AND session_id = #&#123;sessionId&#125;&quot;&#125;)</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">deleteByUserIdAndSessionId</span><span class="params">(<span class="meta">@Param(&quot;userId&quot;)</span> Long userId, <span class="meta">@Param(&quot;sessionId&quot;)</span> String sessionId)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按创建时间获取用户最近的会话列表（分组查询不同会话）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Select(&#123;&quot;SELECT DISTINCT session_id FROM &quot;, ChatHistoryModel.TABLE_NAME,</span></span><br><span class="line"><span class="meta">            &quot; WHERE user_id = #&#123;userId&#125; ORDER BY MAX(created_at) DESC LIMIT #&#123;limit&#125;&quot;&#125;)</span></span><br><span class="line">    List&lt;String&gt; <span class="title function_">findRecentSessionsByUserId</span><span class="params">(<span class="meta">@Param(&quot;userId&quot;)</span> Long userId, <span class="meta">@Param(&quot;limit&quot;)</span> <span class="type">int</span> limit)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过继承<code>TemplateDao</code>，我们自动获得了常见的CRUD操作，同时还可以根据业务需求自定义其他查询方法。</p><h3 id="5-4-业务服务层"><a href="#5-4-业务服务层" class="headerlink" title="5.4 业务服务层"></a>5.4 业务服务层</h3><p>业务服务层是应用的核心，负责实现业务逻辑。以<code>ChatService</code>接口及其实现类为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ChatService</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ChatHistoryModel <span class="title function_">sendMessage</span><span class="params">(Long userId, String sessionId, String message)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取聊天历史</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;ChatHistoryModel&gt; <span class="title function_">getChatHistory</span><span class="params">(Long userId, String sessionId)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取用户会话列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;String&gt; <span class="title function_">getUserSessions</span><span class="params">(Long userId, <span class="type">int</span> limit)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建新会话</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">createNewSession</span><span class="params">(Long userId)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除会话</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">deleteSession</span><span class="params">(Long userId, String sessionId)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类<code>ChatServiceImpl</code>负责具体的业务逻辑实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">ChatService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ChatHistoryDao chatHistoryDao;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ConfigService configService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DeepSeekClient deepSeekClient;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ChatHistoryModel <span class="title function_">sendMessage</span><span class="params">(Long userId, String sessionId, String message)</span> &#123;</span><br><span class="line">        <span class="comment">// 保存用户消息</span></span><br><span class="line">        <span class="type">ChatHistoryModel</span> <span class="variable">userMessage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChatHistoryModel</span>();</span><br><span class="line">        userMessage.setUserId(userId);</span><br><span class="line">        userMessage.setSessionId(sessionId);</span><br><span class="line">        userMessage.setRole(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        userMessage.setContent(message);</span><br><span class="line">        userMessage.setHasImage(<span class="literal">false</span>);</span><br><span class="line">        chatHistoryDao.create(userMessage);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取用户DeepSeek配置</span></span><br><span class="line">        <span class="type">ConfigModel</span> <span class="variable">config</span> <span class="operator">=</span> configService.getUserConfig(userId);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取历史对话记录用于上下文</span></span><br><span class="line">            List&lt;ChatHistoryModel&gt; historyList = chatHistoryDao.findByUserIdAndSessionId(userId, sessionId);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将历史转换为DeepSeek API需要的格式 (限制最近10条消息)</span></span><br><span class="line">            List&lt;Map&lt;String, String&gt;&gt; conversationHistory = <span class="keyword">new</span> <span class="title class_">java</span>.util.ArrayList&lt;&gt;();</span><br><span class="line">            <span class="type">int</span> <span class="variable">startIndex</span> <span class="operator">=</span> Math.max(<span class="number">0</span>, historyList.size() - <span class="number">10</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt; historyList.size(); i++) &#123;</span><br><span class="line">                <span class="type">ChatHistoryModel</span> <span class="variable">historyItem</span> <span class="operator">=</span> historyList.get(i);</span><br><span class="line">                <span class="keyword">if</span> (!<span class="string">&quot;user&quot;</span>.equals(historyItem.getRole()) &amp;&amp; !<span class="string">&quot;assistant&quot;</span>.equals(historyItem.getRole())) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                Map&lt;String, String&gt; messageMap = <span class="keyword">new</span> <span class="title class_">java</span>.util.HashMap&lt;&gt;();</span><br><span class="line">                messageMap.put(<span class="string">&quot;role&quot;</span>, historyItem.getRole());</span><br><span class="line">                messageMap.put(<span class="string">&quot;content&quot;</span>, historyItem.getContent());</span><br><span class="line">                conversationHistory.add(messageMap);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 调用DeepSeek API获取回复</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">aiReply</span> <span class="operator">=</span> deepSeekClient.generateResponse(config, message, conversationHistory);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 保存AI回复</span></span><br><span class="line">            <span class="type">ChatHistoryModel</span> <span class="variable">aiMessage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChatHistoryModel</span>();</span><br><span class="line">            aiMessage.setUserId(userId);</span><br><span class="line">            aiMessage.setSessionId(sessionId);</span><br><span class="line">            aiMessage.setRole(<span class="string">&quot;assistant&quot;</span>);</span><br><span class="line">            aiMessage.setContent(aiReply);</span><br><span class="line">            aiMessage.setHasImage(<span class="literal">false</span>);</span><br><span class="line">            chatHistoryDao.create(aiMessage);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> aiMessage;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;Failed to get response from DeepSeek API&quot;</span>, e);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 保存错误消息</span></span><br><span class="line">            <span class="type">ChatHistoryModel</span> <span class="variable">errorMessage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChatHistoryModel</span>();</span><br><span class="line">            errorMessage.setUserId(userId);</span><br><span class="line">            errorMessage.setSessionId(sessionId);</span><br><span class="line">            errorMessage.setRole(<span class="string">&quot;assistant&quot;</span>);</span><br><span class="line">            errorMessage.setContent(<span class="string">&quot;抱歉，AI助手暂时无法回复。错误信息: &quot;</span> + e.getMessage());</span><br><span class="line">            errorMessage.setHasImage(<span class="literal">false</span>);</span><br><span class="line">            chatHistoryDao.create(errorMessage);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> errorMessage;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 其他方法实现...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个实现中，我们可以看到：</p><ol><li>保存用户消息到数据库</li><li>获取历史对话作为上下文</li><li>调用DeepSeek API获取AI回复</li><li>保存AI回复到数据库</li><li>异常处理机制</li></ol><h3 id="5-5-DeepSeek-API集成"><a href="#5-5-DeepSeek-API集成" class="headerlink" title="5.5 DeepSeek API集成"></a>5.5 DeepSeek API集成</h3><p>我们通过<code>DeepSeekClient</code>类与DeepSeek API进行交互：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeepSeekClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LoggerFactory.getLogger(DeepSeekClient.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送消息到DeepSeek API获取回复</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">generateResponse</span><span class="params">(ConfigModel config, String prompt, List&lt;Map&lt;String, String&gt;&gt; history)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">DeepSeekApi</span> <span class="variable">deepSeekApi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeepSeekApi</span>(config.getServerUrl(), config.getApiKey());</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 构建选项</span></span><br><span class="line">            Map&lt;String, Object&gt; options = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            options.put(<span class="string">&quot;temperature&quot;</span>, config.getTemperature());</span><br><span class="line">            options.put(<span class="string">&quot;top_p&quot;</span>, config.getTopP());</span><br><span class="line">            options.put(<span class="string">&quot;context_window&quot;</span>, config.getContextSize());</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> deepSeekApi.generateCompletion(config.getModelName(), prompt, history, options);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">&quot;Error calling DeepSeek API&quot;</span>, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;调用AI服务出错: &quot;</span> + e.getMessage();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取可用模型列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">getAvailableModels</span><span class="params">(String serverUrl, String apiKey)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">DeepSeekApi</span> <span class="variable">deepSeekApi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeepSeekApi</span>(serverUrl, apiKey);</span><br><span class="line">            List&lt;DeepSeekApi.Model&gt; models = deepSeekApi.listModels();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> models.stream()</span><br><span class="line">                    .map(DeepSeekApi.Model::getName)</span><br><span class="line">                    .collect(Collectors.toList());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">&quot;Error fetching DeepSeek models&quot;</span>, e);</span><br><span class="line">            <span class="keyword">return</span> List.of(<span class="string">&quot;deepseek-chat&quot;</span>, <span class="string">&quot;deepseek-coder&quot;</span>, <span class="string">&quot;deepseek-lite&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试与DeepSeek API的连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">testConnection</span><span class="params">(String serverUrl, String apiKey)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">DeepSeekApi</span> <span class="variable">deepSeekApi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeepSeekApi</span>(serverUrl, apiKey);</span><br><span class="line">            <span class="keyword">return</span> deepSeekApi.testConnection();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">&quot;Failed to connect to DeepSeek API: &#123;&#125;&quot;</span>, serverUrl, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个客户端类提供了三个主要功能：生成回复、获取可用模型列表和测试连接。</p><h3 id="5-6-Web控制器层"><a href="#5-6-Web控制器层" class="headerlink" title="5.6 Web控制器层"></a>5.6 Web控制器层</h3><p>Web控制器层负责处理HTTP请求和响应，项目中主要有三个控制器：<code>ChatController</code>、<code>ConfigController</code>和<code>HomeController</code>。以<code>ChatController</code>为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/chat&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_SESSIONS_COUNT</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SESSION_TITLE_LENGTH</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ChatService chatService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ChatController</span><span class="params">(ChatService chatService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.chatService = chatService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/send&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseDTO&lt;ChatMessageDTO&gt; <span class="title function_">sendMessage</span><span class="params">(<span class="meta">@RequestBody</span> SendMessageRequestDTO request)</span> &#123;</span><br><span class="line">        <span class="comment">// 简单验证</span></span><br><span class="line">        <span class="keyword">if</span> (request.getMessage() == <span class="literal">null</span> || request.getMessage().trim().isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> ResponseDTO.error(<span class="string">&quot;消息内容不能为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟用户认证 (实际应从会话或令牌中获取用户ID)</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果没有会话ID，创建新会话</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sessionId</span> <span class="operator">=</span> request.getSessionId();</span><br><span class="line">        <span class="keyword">if</span> (sessionId == <span class="literal">null</span> || sessionId.trim().isEmpty()) &#123;</span><br><span class="line">            sessionId = chatService.createNewSession(userId);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 发送消息并获取回复</span></span><br><span class="line">        <span class="type">ChatHistoryModel</span> <span class="variable">response</span> <span class="operator">=</span> chatService.sendMessage(userId, sessionId, request.getMessage());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 转换为DTO</span></span><br><span class="line">        <span class="type">ChatMessageDTO</span> <span class="variable">messageDTO</span> <span class="operator">=</span> convertToDTO(response);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ResponseDTO.success(messageDTO);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取会话历史记录</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/history/&#123;sessionId&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseDTO&lt;List&lt;ChatMessageDTO&gt;&gt; <span class="title function_">getChatHistory</span><span class="params">(<span class="meta">@PathVariable</span> String sessionId)</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟用户认证</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">        </span><br><span class="line">        List&lt;ChatHistoryModel&gt; history = chatService.getChatHistory(userId, sessionId);</span><br><span class="line">        List&lt;ChatMessageDTO&gt; historyDTO = history.stream()</span><br><span class="line">                .map(<span class="built_in">this</span>::convertToDTO)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ResponseDTO.success(historyDTO);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 其他API方法...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将ChatHistoryModel转换为ChatMessageDTO</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ChatMessageDTO <span class="title function_">convertToDTO</span><span class="params">(ChatHistoryModel model)</span> &#123;</span><br><span class="line">        <span class="type">ChatMessageDTO</span> <span class="variable">dto</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChatMessageDTO</span>();</span><br><span class="line">        dto.setId(model.getId().toString());</span><br><span class="line">        dto.setRole(model.getRole());</span><br><span class="line">        dto.setContent(model.getContent());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (model.getCreatedAt() != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">DateTimeFormatter</span> <span class="variable">formatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">            dto.setTime(model.getCreatedAt().format(formatter));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (model.getHasImage() &amp;&amp; model.getImageUrl() != <span class="literal">null</span>) &#123;</span><br><span class="line">            dto.setHasImage(<span class="literal">true</span>);</span><br><span class="line">            dto.setImageUrl(model.getImageUrl());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dto.setHasImage(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dto;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FUST框架提供了统一的响应格式<code>ResponseDTO</code>，让API接口返回的数据更加规范和一致。</p><h3 id="5-7-应用启动类"><a href="#5-7-应用启动类" class="headerlink" title="5.7 应用启动类"></a>5.7 应用启动类</h3><p>最后，我们看一下应用的入口类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@Import(ServiceConfiguration.class)</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;com.deepqa.api&quot;, &quot;com.deepqa.business&quot;&#125;)</span></span><br><span class="line"><span class="meta">@EntityScan(basePackages = &#123;&quot;com.deepqa.business.model&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeepQAMain</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 设置默认环境变量</span></span><br><span class="line">        <span class="keyword">if</span> (System.getProperty(<span class="string">&quot;env.name&quot;</span>) == <span class="literal">null</span> &amp;&amp; System.getenv(<span class="string">&quot;ENV_NAME&quot;</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.setProperty(<span class="string">&quot;env.name&quot;</span>, <span class="string">&quot;dev&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        TelemetryInitializer.init();</span><br><span class="line">        <span class="type">SpringApplication</span> <span class="variable">application</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpringApplication</span>(DeepQAMain.class);</span><br><span class="line">        application.setAdditionalProfiles(<span class="string">&quot;api&quot;</span>);</span><br><span class="line">        application.run(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里调用了<code>TelemetryInitializer.init()</code>，这是FUST框架提供的遥测初始化方法，用于收集应用指标和监控数据。</p><h2 id="六、项目部署与运行"><a href="#六、项目部署与运行" class="headerlink" title="六、项目部署与运行"></a>六、项目部署与运行</h2><p>FUST框架提供了一系列脚本来简化项目的构建和运行过程。本文 demo 项目代码地址访问 <strong><a href="https://gitee.com/noogel/deep-qa">deep-qa</a></strong>。</p><h3 id="6-1-项目构建"><a href="#6-1-项目构建" class="headerlink" title="6.1 项目构建"></a>6.1 项目构建</h3><p>首先，编译Maven项目：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean package</span><br></pre></td></tr></table></figure><p>然后，使用构建脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash build.sh</span><br></pre></td></tr></table></figure><h3 id="6-2-项目运行"><a href="#6-2-项目运行" class="headerlink" title="6.2 项目运行"></a>6.2 项目运行</h3><p>根据不同的环境，使用不同的环境配置脚本：</p><h4 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用开发环境配置</span></span><br><span class="line"><span class="built_in">source</span> ./dev-env.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后运行HTTP服务</span></span><br><span class="line">bash run.sh deep-qa-api/target</span><br></pre></td></tr></table></figure><h4 id="生产环境"><a href="#生产环境" class="headerlink" title="生产环境"></a>生产环境</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置生产环境数据库密码（敏感信息不要硬编码）</span></span><br><span class="line"><span class="built_in">export</span> DB_USER=<span class="string">&quot;production_username&quot;</span></span><br><span class="line"><span class="built_in">export</span> DB_PASSWORD=<span class="string">&quot;production_password&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用生产环境配置</span></span><br><span class="line"><span class="built_in">source</span> ./prod-env.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后运行HTTP服务</span></span><br><span class="line">bash run.sh deep-qa-api/target</span><br></pre></td></tr></table></figure><h3 id="6-3-服务访问"><a href="#6-3-服务访问" class="headerlink" title="6.3 服务访问"></a>6.3 服务访问</h3><p>API服务启动后，可以通过以下URL访问：</p><ul><li><p>HTTP API: <code>http://localhost:8080/api/chat/send</code></p></li><li><p>示例调用:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST <span class="string">&quot;http://localhost:8080/api/chat/send&quot;</span> \</span><br><span class="line">  -H <span class="string">&quot;Content-Type: application/json&quot;</span> \</span><br><span class="line">  -d <span class="string">&#x27;&#123;&quot;message&quot;:&quot;你好，请介绍一下你自己&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="七、FUST框架的企业级优势"><a href="#七、FUST框架的企业级优势" class="headerlink" title="七、FUST框架的企业级优势"></a>七、FUST框架的企业级优势</h2><p>通过Deep QA项目的实现，我们可以看到FUST框架在企业级开发中的一些显著优势：</p><h3 id="7-1-结构化的项目组织"><a href="#7-1-结构化的项目组织" class="headerlink" title="7.1 结构化的项目组织"></a>7.1 结构化的项目组织</h3><p>FUST框架提供了清晰的项目结构和模块划分，使得代码组织更加合理，便于团队协作和维护。</p><h3 id="7-2-统一的异常处理"><a href="#7-2-统一的异常处理" class="headerlink" title="7.2 统一的异常处理"></a>7.2 统一的异常处理</h3><p>FUST提供了全局异常处理机制和统一的响应格式，使得API接口的错误处理更加规范和一致。</p><h3 id="7-3-内置的可观测性"><a href="#7-3-内置的可观测性" class="headerlink" title="7.3 内置的可观测性"></a>7.3 内置的可观测性</h3><p>通过<code>TelemetryInitializer</code>，FUST框架提供了内置的监控和跟踪功能，便于问题排查和性能优化。</p><h3 id="7-4-灵活的环境配置"><a href="#7-4-灵活的环境配置" class="headerlink" title="7.4 灵活的环境配置"></a>7.4 灵活的环境配置</h3><p>FUST框架支持通过环境变量或系统属性来配置不同的运行环境，使得应用可以在不同环境中无缝切换。</p><h3 id="7-5-高性能的服务框架"><a href="#7-5-高性能的服务框架" class="headerlink" title="7.5 高性能的服务框架"></a>7.5 高性能的服务框架</h3><p>FUST基于高性能的Armeria服务器构建，提供了出色的性能和吞吐能力，特别适合高并发场景。</p><h3 id="7-6-多协议支持"><a href="#7-6-多协议支持" class="headerlink" title="7.6 多协议支持"></a>7.6 多协议支持</h3><p>FUST同时支持HTTP和gRPC协议，使得服务可以同时为不同类型的客户端提供接口。</p><h3 id="7-7-企业级数据库访问"><a href="#7-7-企业级数据库访问" class="headerlink" title="7.7 企业级数据库访问"></a>7.7 企业级数据库访问</h3><p>FUST提供了对MyBatis的增强支持，简化了数据库访问层的开发，提高了代码的可维护性。</p><h2 id="八、总结与展望"><a href="#八、总结与展望" class="headerlink" title="八、总结与展望"></a>八、总结与展望</h2><p>通过本文，我们详细介绍了如何使用FUST框架和DeepSeek API构建一个功能完整的智能问答系统。这个系统具有以下特点：</p><ol><li><strong>模块化架构</strong>：清晰的模块划分和责任分配</li><li><strong>扩展性强</strong>：可以方便地添加新功能和扩展现有功能</li><li><strong>高性能</strong>：基于FUST和Armeria的高性能服务框架</li><li><strong>可靠稳定</strong>：完善的异常处理和错误恢复机制</li><li><strong>可观测性</strong>：内置的监控和跟踪功能</li></ol><p>未来，我们可以考虑在以下方面进行扩展和优化：</p><ol><li><strong>多模态支持</strong>：支持图像识别和处理</li><li><strong>用户认证与权限管理</strong>：完善用户管理功能</li><li><strong>多语言支持</strong>：支持更多语言和地区</li><li><strong>对话记忆优化</strong>：改进对话上下文管理</li><li><strong>模型微调</strong>：根据特定领域需求对模型进行微调</li></ol><h2 id="九、参考资料"><a href="#九、参考资料" class="headerlink" title="九、参考资料"></a>九、参考资料</h2><ol><li><a href="https://zhihu.github.io/fust/guide/">FUST框架官方文档</a></li><li><a href="https://deepseek.com/developer">DeepSeek API文档</a></li><li><a href="https://spring.io/projects/spring-boot">Spring Boot官方文档</a></li><li><a href="https://mybatis.org/mybatis-3/">MyBatis官方文档</a></li><li><a href="https://armeria.dev/">Armeria服务器文档</a></li></ol><p>通过本文的学习，相信读者已经对如何使用FUST框架构建企业级应用有了深入的理解，并能够将这些知识应用到自己的项目中。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;近年来，随着大型语言模型的快速发展，智能问答系统已经成为企业提升用户体验、降低客服成本的重要工具。本文将介绍如何利用知乎开源的FUST微服务框架和DeepSeek API，搭建一个高性能、可扩展的智能问答系统。&lt;/p&gt;
&lt;p&gt;FUST 谐音 Fast，是知乎开发的一款基于Spring Boot的微服务开发框架，旨在帮助开发者快速构建高质量的微服务应用。它集成了主流组件，提供标准化的开发范式，并在知乎的大规模生产环境经受了考验。&lt;/p&gt;
&lt;p&gt;我们将通过实现一个名为”Deep QA”的项目，展示如何将FUST框架与DeepSeek API结合，构建一个功能完善的智能问答系统。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/resource/img/2025-07-24-20-22-51.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="项目" scheme="https://noogel.xyz/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>畅文全索：文档检索系统的探索与实践</title>
    <link href="https://noogel.xyz/2025/04/18/1.html"/>
    <id>https://noogel.xyz/2025/04/18/1.html</id>
    <published>2025-04-18T00:00:00.000Z</published>
    <updated>2025-07-23T18:20:05.316Z</updated>
    
    <content type="html"><![CDATA[<p>在日常的信息处理中，有效管理和查找文档是许多人面临的实际需求。无论是个人积累的资料，还是团队共享的文档，一个可靠的检索工具都能提供帮助。本文将介绍 <strong>畅文全索（xyz-search）</strong>，一个基于 <strong>Spring Boot</strong> 和 <strong>ElasticSearch</strong> 开发的文档检索系统，旨在为用户提供一种相对便捷的文档内容查找方案。</p><h3 id="💡-项目概述：畅文全索的功能定位"><a href="#💡-项目概述：畅文全索的功能定位" class="headerlink" title="💡 项目概述：畅文全索的功能定位"></a>💡 项目概述：畅文全索的功能定位</h3><p>畅文全索被定位为一个辅助性的全文检索系统。它基于 <strong>Spring Boot</strong> 和 <strong>ElasticSearch</strong> 构建，尝试支持多种文件格式的全文内容检索。通过整合 <strong>Spring AI</strong> 功能，系统也具备了初步的智能搜索和内容分析能力，以期为用户提供更精准的检索体验。</p><p>本系统适用于个人文档管理或小型数字文档集合的检索场景，可处理一定规模的文档数据。它旨在为用户提供一个可行的文档检索和管理工具。</p><p>你可以在 <strong><a href="https://github.com/noogel/xyz-search">GitHub</a></strong> 上找到畅文全索的开源代码。</p><img src="/resource/img/2025-07-24-02-16-25.png" alt="" width=90% /><span id="more"></span><h3 id="✨-主要功能：畅文全索的特点"><a href="#✨-主要功能：畅文全索的特点" class="headerlink" title="✨ 主要功能：畅文全索的特点"></a>✨ 主要功能：畅文全索的特点</h3><p>畅文全索在功能设计上，尝试涵盖了文档检索的一些核心需求：</p><h4 id="📄-多种文档格式支持"><a href="#📄-多种文档格式支持" class="headerlink" title="📄 多种文档格式支持"></a>📄 多种文档格式支持</h4><p>系统在文档兼容性方面进行了一些尝试，目前支持多种常见文档格式的解析和索引：</p><ul><li><strong>办公文档</strong>：PDF、Word (docx)、Excel (xlsx)、PowerPoint</li><li><strong>电子书</strong>：EPUB (支持内容解析与索引)</li><li><strong>图像识别</strong>：通过集成 <strong>PaddleOCR</strong>，可提取图片中的文本信息。</li><li><strong>多媒体</strong>：支持部分视频元数据索引。</li><li><strong>网页与文本</strong>：支持 HTML 和纯文本文件 (TXT, MD, JSON 等)。</li></ul><h4 id="🔎-基础检索能力"><a href="#🔎-基础检索能力" class="headerlink" title="🔎 基础检索能力"></a>🔎 基础检索能力</h4><p>畅文全索的检索功能基于 ElasticSearch，提供了一些常用的搜索特性：</p><ul><li><strong>全文索引</strong>：采用 ElasticSearch 作为底层索引技术。</li><li><strong>中文分词</strong>：支持中文文本的分词处理。</li><li><strong>索引更新</strong>：具备基本的实时索引更新机制。</li><li><strong>属性过滤</strong>：支持文件属性的过滤检索。</li><li><strong>结果高亮</strong>：对搜索结果中的关键词进行高亮显示。</li></ul><h4 id="🤖-AI-功能的引入"><a href="#🤖-AI-功能的引入" class="headerlink" title="🤖 AI 功能的引入"></a>🤖 AI 功能的引入</h4><p>系统引入了 AI 相关功能，尝试提升检索的智能化程度：</p><ul><li><strong>Spring AI 集成</strong>：利用 Spring AI 框架进行功能扩展。</li><li><strong>语言模型辅助</strong>：尝试基于大语言模型进行内容理解。</li><li><strong>对话式检索</strong>：支持初步的自然语言对话式检索模式。</li><li><strong>Ollama 模型支持</strong>：可配置本地部署 Ollama 模型。</li></ul><h4 id="📚-电子书管理辅助"><a href="#📚-电子书管理辅助" class="headerlink" title="📚 电子书管理辅助"></a>📚 电子书管理辅助</h4><p>对于电子书爱好者，系统也提供了一些辅助管理功能：</p><ul><li><strong>OPDS 协议支持</strong>：兼容 OPDS 电子书协议。</li><li><strong>EPUB 阅读</strong>：内置简易的在线 EPUB 阅读器。</li></ul><h4 id="💻-界面设计与操作"><a href="#💻-界面设计与操作" class="headerlink" title="💻 界面设计与操作"></a>💻 界面设计与操作</h4><p>系统提供了基本的 Web 界面，以方便用户操作：</p><ul><li><strong>Web 界面</strong>：提供一个简洁的 Web 交互界面。</li><li><strong>文档上传</strong>：支持文件上传功能。</li><li><strong>文件采集</strong>：可设置自动采集指定目录下的文件。</li><li><strong>移动端适配</strong>：界面设计考虑了响应式布局。</li></ul><p>系统以 <strong>Spring Boot</strong> 作为主要开发框架，提供了 Web 界面和各类 API 接口。内部功能模块包括搜索、索引、AI 和文件服务。数据存储方面，主要依赖 <strong>ElasticSearch</strong> 进行全文索引，<strong>SQLite</strong> 用于系统配置数据，而 AI 功能则通过 <strong>Spring AI</strong> 实现。文件存储则独立进行管理。</p><hr><h3 id="🚀-部署指引：如何启动畅文全索"><a href="#🚀-部署指引：如何启动畅文全索" class="headerlink" title="🚀 部署指引：如何启动畅文全索"></a>🚀 部署指引：如何启动畅文全索</h3><p>以下是使用 Docker 快速启动畅文全索的基本步骤：</p><p><strong>通过预构建 Docker 镜像启动：</strong></p><ol><li><p><strong>拉取镜像：</strong></p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull noogel/xyz-search:latest</span><br></pre></td></tr></table></figure></li><li><p><strong>运行容器：</strong></p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name xyzSearch --network xyz-bridge-net -p 8081:8081 \</span><br><span class="line">-v /path/to/searchData:/usr/share/xyz-search/data \</span><br><span class="line">-v /path/to/share:/data/share \</span><br><span class="line">noogel/xyz-search:latest</span><br></pre></td></tr></table></figure><p> 请将示例路径 <code>/path/to/searchData</code> 和 <code>/path/to/share</code> 替换为实际的文件存储位置。</p></li></ol><p>系统默认配置如下：</p><ul><li><strong>管理员账号</strong>：<code>xyz</code></li><li><strong>初始密码</strong>：<code>search</code></li><li><strong>访问地址</strong>：<a href="http://localhost:8081/">http://localhost:8081</a></li></ul><blockquote><p><strong>注意</strong>：系统初始密码可在配置页面修改。当前版本账号不支持修改。建议在较为受控的网络环境中使用。</p></blockquote><hr><h3 id="🔧-配置说明：定制化选项"><a href="#🔧-配置说明：定制化选项" class="headerlink" title="🔧 配置说明：定制化选项"></a>🔧 配置说明：定制化选项</h3><p>系统启动后，用户可在 Web 界面进行必要的参数调整：</p><ul><li><strong>索引目录</strong>：指定需要进行索引的文档主目录，并可设置排除的子目录。</li><li><strong>文件自动采集</strong>：配置监控源目录、目标存储目录、文件类型过滤规则以及是否自动删除源文件。</li><li><strong>OPDS 服务根目录</strong>：建议配置为 Calibre 库目录。</li><li><strong>文件存储路径</strong>：包括手动上传和标记删除文件的存储路径。</li><li><strong>通知邮件配置</strong>：用于系统访问通知的邮件设置。</li><li><strong>OCR 服务</strong>：配置 PaddleOCR 服务地址。</li><li><strong>外部搜索链接</strong>：自定义文档详情页的外部搜索链接，如豆瓣、京东、谷歌。</li><li><strong>AI 对话检索</strong>：配置 AI 功能的启用状态，以及 Ollama、Elasticsearch 和 Qdrant 等相关服务的参数。</li></ul><hr><h3 id="🐳-Docker-Compose-部署：集成服务"><a href="#🐳-Docker-Compose-部署：集成服务" class="headerlink" title="🐳 Docker Compose 部署：集成服务"></a>🐳 Docker Compose 部署：集成服务</h3><p>对于偏好使用 Docker Compose 的用户，我们也提供了相应的配置，可以方便地部署包含 Elasticsearch、Qdrant 等服务的完整环境：</p><p>创建一个 <code>docker-compose.yml</code> 文件，并添加以下内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">xyz-search:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">noogel/xyz-search:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">xyzSearch</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8081:8081&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./searchData:/usr/share/xyz-search/data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./share:/data/share</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">xyz-net</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">xyz-net:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></table></figure><p>在 <code>docker-compose.yml</code> 所在目录执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>这将启动畅文全索服务。如需部署完整的服务栈（包含 Elasticsearch、Qdrant 和 PaddleOCR），请参考项目仓库中的详细 <code>docker-compose.yml</code> 配置。</p><h3 id="📊-开发计划与贡献"><a href="#📊-开发计划与贡献" class="headerlink" title="📊 开发计划与贡献"></a>📊 开发计划与贡献</h3><p>畅文全索仍在持续改进中。目前已完成的功能包括 RAG 检索增强模型优化和中文分词准确率改进。未来的开发计划包括：</p><ul><li>全新的响应式搜索界面</li><li>多用户系统支持</li><li>支持更多文档格式</li></ul><p>我们欢迎对本项目感兴趣的开发者参与贡献，无论是功能开发、文档完善、Bug 修复，还是性能优化建议，都将为项目的进步提供帮助。</p><hr><h3 id="📄-许可证"><a href="#📄-许可证" class="headerlink" title="📄 许可证"></a>📄 许可证</h3><p>本项目遵循 <strong>GNU General Public License v3.0</strong> 许可证。</p><hr><p>希望以上内容能为您提供关于畅文全索的基本信息。如果您有进一步的疑问或建议，欢迎交流。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在日常的信息处理中，有效管理和查找文档是许多人面临的实际需求。无论是个人积累的资料，还是团队共享的文档，一个可靠的检索工具都能提供帮助。本文将介绍 &lt;strong&gt;畅文全索（xyz-search）&lt;/strong&gt;，一个基于 &lt;strong&gt;Spring Boot&lt;/strong&gt; 和 &lt;strong&gt;ElasticSearch&lt;/strong&gt; 开发的文档检索系统，旨在为用户提供一种相对便捷的文档内容查找方案。&lt;/p&gt;
&lt;h3 id=&quot;💡-项目概述：畅文全索的功能定位&quot;&gt;&lt;a href=&quot;#💡-项目概述：畅文全索的功能定位&quot; class=&quot;headerlink&quot; title=&quot;💡 项目概述：畅文全索的功能定位&quot;&gt;&lt;/a&gt;💡 项目概述：畅文全索的功能定位&lt;/h3&gt;&lt;p&gt;畅文全索被定位为一个辅助性的全文检索系统。它基于 &lt;strong&gt;Spring Boot&lt;/strong&gt; 和 &lt;strong&gt;ElasticSearch&lt;/strong&gt; 构建，尝试支持多种文件格式的全文内容检索。通过整合 &lt;strong&gt;Spring AI&lt;/strong&gt; 功能，系统也具备了初步的智能搜索和内容分析能力，以期为用户提供更精准的检索体验。&lt;/p&gt;
&lt;p&gt;本系统适用于个人文档管理或小型数字文档集合的检索场景，可处理一定规模的文档数据。它旨在为用户提供一个可行的文档检索和管理工具。&lt;/p&gt;
&lt;p&gt;你可以在 &lt;strong&gt;&lt;a href=&quot;https://github.com/noogel/xyz-search&quot;&gt;GitHub&lt;/a&gt;&lt;/strong&gt; 上找到畅文全索的开源代码。&lt;/p&gt;
&lt;img src=&quot;/resource/img/2025-07-24-02-16-25.png&quot; alt=&quot;&quot; width=90% /&gt;</summary>
    
    
    
    
    <category term="项目" scheme="https://noogel.xyz/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>2022-2024 已读书单</title>
    <link href="https://noogel.xyz/2024/12/31/1.html"/>
    <id>https://noogel.xyz/2024/12/31/1.html</id>
    <published>2024-12-31T00:00:00.000Z</published>
    <updated>2025-07-24T09:54:02.933Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2024-书单"><a href="#2024-书单" class="headerlink" title="2024 书单"></a>2024 书单</h2><ul><li>《最好的告别》阿图·葛文德（12 月）</li><li>《蛤蟆先生去看心理医生》罗伯特·戴博德（8 月）</li><li>《我在北京送快递》胡安焉（8 月）</li><li>《哪有什么感同身受：16 张生存素描》（8 月）</li><li>《读懂一本书：樊登读书法》樊登（7 月）</li><li>《我的阿勒泰》李娟（7 月）</li><li>《低风险创业》樊登（6 月）</li><li>《好好思考》成甲（3 月）</li><li>《醉汉的脚步》列纳德·蒙洛迪诺</li><li>《毛泽东选集》</li><li>《毛泽东传》</li></ul><hr><h2 id="2023-书单"><a href="#2023-书单" class="headerlink" title="2023 书单"></a>2023 书单</h2><ul><li>《太白金星有点烦》马伯庸（12 月）</li><li>《生死疲劳》莫言（11 月）</li><li>《奇特的一生》（10 月）</li><li>《长安的荔枝》马伯庸（10 月）</li><li>《小米创业思考》雷军（9 月）</li><li>《可复制的领导力》樊登（9 月）</li><li>《卓有成效的管理者》彼得·德鲁克（9 月）</li><li>《新摄影笔记》（8 月）</li><li>《可复制的沟通力》樊登（7 月）</li><li>《5000 天后的世界》凯文凯利（6 月）</li><li>《我在通用汽车的岁月》斯隆</li><li>《一本书读懂财报》肖星</li></ul><h2 id="2022-书单"><a href="#2022-书单" class="headerlink" title="2022 书单"></a>2022 书单</h2><p>《黑客与画家》（7 月）<br>《垃圾回收的算法与实现》（3 月）<br>《软件架构设计：大型网站技术架构与业务架构融合之道》（3 月）<br>《MacTalk·人生元编程》池建强（3 月）<br>《戒糖：改变一生的科学饮食法》（1 月）<br>《传习录》王阳明<br>《高效能人士的七个习惯》<br>《GraalVM与Java静态编译：原理与应用》林子熠</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;2024-书单&quot;&gt;&lt;a href=&quot;#2024-书单&quot; class=&quot;headerlink&quot; title=&quot;2024 书单&quot;&gt;&lt;/a&gt;2024 书单&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;《最好的告别》阿图·葛文德（12 月）&lt;/li&gt;
&lt;li&gt;《蛤蟆先生去看心理医生》罗伯特</summary>
      
    
    
    
    
    <category term="书单" scheme="https://noogel.xyz/tags/%E4%B9%A6%E5%8D%95/"/>
    
  </entry>
  
  <entry>
    <title>软件系统复杂性治理方法</title>
    <link href="https://noogel.xyz/2024/02/13/1.html"/>
    <id>https://noogel.xyz/2024/02/13/1.html</id>
    <published>2024-02-13T00:00:00.000Z</published>
    <updated>2025-07-23T07:30:58.916Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/resource/img/2024-02-14-23-36-09.png"></p><p>本文讨论了软件复杂性及其产生原因，介绍了如何度量软件复杂性，及 SOLID 软件设计原则，并探讨管理复杂性的方法，包括使用代码重构、设计模式、领域驱动设计等。通过遵循这些原则和方法，开发人员可以降低软件复杂性，提高代码质量和可维护性。这篇文章内容涵盖了软件开发的道与术，希望能对你所有帮助，欢迎评论交流～</p><ol><li>什么是软件复杂性</li><li>软件复杂性产生原因</li><li>如何度量软件复杂性</li><li>SOLID 软件设计原则</li><li>管理复杂性的方法</li></ol><span id="more"></span><h2 id="什么是软件复杂性"><a href="#什么是软件复杂性" class="headerlink" title="什么是软件复杂性"></a>什么是软件复杂性</h2><p>软件系统复杂性指的是系统内部组件、模块、包、类、方法之间的交互关系以及整体设计的复杂程度。这种复杂度可能源自于多方面因素，包括但不限于代码规模、结构的混乱程度、各个模块之间的耦合度、算法的复杂性以及系统中存在的条件分支和循环等。</p><p>系统复杂度的高低直接影响着软件的可理解性、可维护性和可扩展性。高复杂度的系统通常意味着更难以理解和修改，也更容易引入错误。此外，复杂度过高还会增加软件开发和维护的成本。</p><p>所以说理解和管理软件系统复杂度至关重要。通过采用适当的设计原则、模式和工程实践，以及持续的重构和优化，可以有效地控制和降低软件系统的复杂度，从而提高系统的可维护性、可理解性和可靠性。</p><p>以下是两个相同功能的示例代码段，通过对比可以观察下复杂性差异：</p><p><strong>多层嵌套条件语句</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processOrder</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (order != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (order.isValid()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (order.getPaymentStatus() == PaymentStatus.PAID) &#123;</span><br><span class="line">                <span class="keyword">if</span> (order.getShippingStatus() == ShippingStatus.SHIPPED) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (order.getShippingAddress() != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 执行订单处理操作</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 发送错误消息：缺少配送地址</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 发送错误消息：订单未发货</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 发送错误消息：订单未支付</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 发送错误消息：无效订单</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 发送错误消息：订单为空</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通过早期返回重构</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processOrder</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (order == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 发送错误消息：订单为空</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!order.isValid()) &#123;</span><br><span class="line">        <span class="comment">// 发送错误消息：无效订单</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (order.getPaymentStatus() != PaymentStatus.PAID) &#123;</span><br><span class="line">        <span class="comment">// 发送错误消息：订单未支付</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (order.getShippingStatus() != ShippingStatus.SHIPPED) &#123;</span><br><span class="line">        <span class="comment">// 发送错误消息：订单未发货</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (order.getShippingAddress() == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 发送错误消息：缺少配送地址</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行订单处理操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面两段代码，通过对比可以发现第一段代码展示了典型的深度嵌套条件语句，可读性差、扩展性差。第二段重构后的代码使用了早期返回的方式，将每个条件检查分开处理，遇到不满足条件的情况就提前返回错误消息。这样可以减少嵌套的条件语句，提高代码的可读性和可维护性。</p><p>第二段代码是对第一段代码的改进，但也是存在一定的可读性和扩展性差的问题的，提前返回是一种断路思考方式，不利于记忆，如果方法比较长，或者后期叠代码使方法变得很长，是不太容易梳理出”什么情况下会执行订单处理操作”，你需要记住各种断路情况。</p><p><img src="/resource/img/2024-02-14-23-31-35.png"></p><h2 id="系统复杂性产生的原因"><a href="#系统复杂性产生的原因" class="headerlink" title="系统复杂性产生的原因"></a>系统复杂性产生的原因</h2><p>复杂性是系统的固有属性，它来源于系统的规模、结构、功能、行为等多个方面，有外在和内在两方面原因，下面列举几点：</p><p><strong>需求变更</strong><br>随着时间的推移，产品需求会不断变化。这些变化可能需要对现有系统进行修改或添加新功能，从而增加了软件系统的复杂性。</p><p><strong>技术选型</strong><br>选择不合适的技术栈或架构模式可能会导致系统的过度复杂化。有时为了解决一个小问题可能会引入大量不必要的技术组件，使系统变得更加复杂。</p><p><strong>规模扩大</strong><br>随着业务的发展，软件系统可能需要处理更多种类的数据和用户，这会导致系统规模的扩大，系统的元素和关系会随着规模的增大而增多。</p><p><strong>不完善的设计</strong><br>缺乏清晰的系统设计和架构规划可能导致系统出现混乱和复杂性。如果最初的设计没有考虑到系统的未来发展，系统将很快变得难以管理和理解。</p><p>巨著《人月神话》中提出了两个重要概念：</p><ul><li>本质复杂度：是指由软件系统所需解决的问题本身所固有的复杂性。它是由问题的本质属性和要求所决定的，与软件实现的细节无关。</li><li>偶然复杂度：是指由软件实现过程中引入的额外复杂性。它是由设计决策、技术选择、代码结构等因素所导致的。</li></ul><p>偶然复杂度不是待求解问题的本质，相对而言， 本质复杂度和待求解问题的本质有关，是无法避免的。偶然复杂度一般是在选用求解问题的方法时所引入的。上面列举的四点，其中技术选型不当和不完善的设计都是因为开发人员经验和预判不足而产生的，属于偶然复杂度；而需求变更和规模扩大则是待求解问题逐渐变多变复杂而产生的，属于本质复杂度。</p><h2 id="如何度量软件复杂性"><a href="#如何度量软件复杂性" class="headerlink" title="如何度量软件复杂性"></a>如何度量软件复杂性</h2><p>之前写过一篇简单介绍过 <a href="/2021/10/22/1.html">软件架构与系统复杂性</a>，下面主要介绍软件系统复杂度度量方式。</p><p><strong>圈复杂度（Cyclomatic Complexity）</strong><br>圈复杂度是一种用来衡量代码复杂性的指标，它通过计算代码中独立路径的数量来评估代码的复杂程度。通俗地说，圈复杂度越高，代码的可读性和维护性就越差。</p><p><strong>时间空间复杂度</strong><br>时间复杂度是用于衡量程序在执行过程中所需的时间资源的多少，而空间复杂度则衡量程序在执行过程中所需的内存资源的多少。</p><p><strong>代码行数</strong><br>代码行数是衡量软件规模和复杂度的一种指标。通常情况下，代码行数越多，系统的复杂度也越高。然而，这并不是绝对的，因为有时候简洁的代码可能实现了复杂的功能。</p><p><strong>嵌套层数</strong><br>嵌套层数指的是代码中条件语句、循环语句和函数调用的嵌套深度。如果嵌套层数过多，会导致代码逻辑混乱，增加代码的理解和维护难度。</p><p><strong>组件的相互依赖关系</strong><br>软件系统中各个组件之间的相互依赖关系也是衡量复杂度的重要标准。如果组件之间的依赖关系错综复杂，那么系统的修改和扩展将变得困难。</p><h2 id="SOLID-软件设计原则"><a href="#SOLID-软件设计原则" class="headerlink" title="SOLID 软件设计原则"></a>SOLID 软件设计原则</h2><p>通常来说，要想构建一个好的软件系统，应该从写整洁的代码开始做起。毕竟，如果建筑所使用的砖头质量不佳，那么架构所能起到的作用也会很有限。反之亦然，如果建筑的架构设计不佳，那么其所用的砖头质量再好也没有用。SOLID 是一组软件设计原则，旨在帮助开发人员设计可维护、可扩展和易于理解的软件架构。下面简要介绍每个原则：</p><ol><li><p>单一职责原则（Single Responsibility Principle，SRP）：一个类应该只有一个引起它变化的原因。这意味着一个类应该只负责一项明确定义的职责或功能，这样可以使类更加内聚，易于理解和修改。</p></li><li><p>开放封闭原则（Open-Closed Principle，OCP）：软件实体（类、模块、函数等）应该对扩展开放，对修改封闭。这意味着在修改现有代码时，应该通过扩展现有代码的行为来实现变化，而不是直接修改已有的代码。</p></li><li><p>里氏替换原则（Liskov Substitution Principle，LSP）：子类应该能够替换其父类并且不会破坏系统的正确性。这意味着子类应该能够在不改变程序正确性的前提下，替代父类的行为。这样可以确保代码的可靠性和可扩展性。</p></li><li><p>接口隔离原则（Interface Segregation Principle，ISP）：客户端不应该依赖于它不需要的接口。这意味着接口应该尽量小而专注，而不是大而笼统。通过定义精确的接口，可以避免客户端依赖无关的接口，提高系统的灵活性和可维护性。</p></li><li><p>依赖倒置原则（Dependency Inversion Principle，DIP）：高层模块不应该依赖于低层模块，而是应该依赖于抽象。这意味着应该通过抽象来解耦模块之间的依赖关系，使得系统更加灵活和可扩展。</p></li></ol><p><strong>这些原则共同强调了代码的高内聚性、低耦合性和可扩展性。遵循这些原则可以提高代码的可维护性、可测试性和可重用性，从而使软件架构更加健壮和可靠。你可能会说道理我都懂但是做不到，王阳明在《传习录》中说，“未有知而不行者，知而不行，只是未知”，如果不能在开发中深切体会这些原则的精髓那便是不懂，是需要在日常开发中不断思考和体会的。</strong></p><p><img src="/resource/img/2024-02-14-23-33-00.png"></p><h2 id="控制和管理复杂性的方法"><a href="#控制和管理复杂性的方法" class="headerlink" title="控制和管理复杂性的方法"></a>控制和管理复杂性的方法</h2><p>如果你读到这里，说明看过了很多 “大泥球” 代码，想找到其中的破解之道，下面会抽丝剥茧，介绍一些方式方法。</p><p>“大泥球”（Big Ball of Mud）是指一种缺乏清晰结构和良好架构的代码，通常随着时间推移不断添加功能和修复问题而产生。还是以上面的代码为例，展示一个可能被称为”大泥球”代码的案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processOrder</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (order != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (order.isValid()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (order.getPaymentStatus() == PaymentStatus.PAID) &#123;</span><br><span class="line">                <span class="keyword">if</span> (order.getShippingStatus() == ShippingStatus.SHIPPED) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (order.getShippingAddress() != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (order.isGiftOrder()) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (order.getGiftMessage() != <span class="literal">null</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (order.getGiftWrapOption() == GiftWrapOption.SELECTED) &#123;</span><br><span class="line">                                    <span class="comment">// 执行礼品订单处理操作（更多嵌套逻辑）</span></span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    <span class="comment">// 发送错误消息：未选择礼品包装选项</span></span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="comment">// 发送错误消息：缺少礼品留言</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// 执行非礼品订单处理操作</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 发送错误消息：缺少配送地址</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 发送错误消息：订单未发货</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 发送错误消息：订单未支付</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 发送错误消息：无效订单</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 发送错误消息：订单为空</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要增加一个判断订单是否为礼品订单的处理逻辑，最直接的方式是在其基础上继续嵌套更多的条件判断。久而久之这样的“大泥球”代码就存在多层嵌套的条件判断，逻辑复杂、难以理解和维护。</p><h3 id="小重构"><a href="#小重构" class="headerlink" title="小重构"></a>小重构</h3><p><strong>对于超大型的方法和类，最简单的、较低风险的方式是拆分方法和类</strong>，之前写过一篇小文章 <a href="/2019/06/26/1.html">从小重构说起</a>。对于方法和类的拆分，可以借助 IDE 来实现，这样可以进一步降低风险；对于静态变量需要提取到公共配置类；通常来说业务方法大都是无状态的，对于有状态方法需要谨慎操作。</p><p>要提高上面方法的可读性和可维护性，可以将其拆分成更小的方法。下面是重构后的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processOrder</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (order == <span class="literal">null</span>) &#123;</span><br><span class="line">        sendErrorMessage(<span class="string">&quot;订单为空&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!order.isValid()) &#123;</span><br><span class="line">        sendErrorMessage(<span class="string">&quot;无效订单&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (order.getPaymentStatus() != PaymentStatus.PAID) &#123;</span><br><span class="line">        sendErrorMessage(<span class="string">&quot;订单未支付&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (order.getShippingStatus() != ShippingStatus.SHIPPED) &#123;</span><br><span class="line">        sendErrorMessage(<span class="string">&quot;订单未发货&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (order.getShippingAddress() == <span class="literal">null</span>) &#123;</span><br><span class="line">        sendErrorMessage(<span class="string">&quot;缺少配送地址&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (order.isGiftOrder()) &#123;</span><br><span class="line">        processGiftOrder(order);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        processStandardOrder(order);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processStandardOrder</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">    <span class="comment">// 执行非礼品订单处理操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processGiftOrder</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (order.getGiftMessage() == <span class="literal">null</span>) &#123;</span><br><span class="line">        sendErrorMessage(<span class="string">&quot;缺少礼品留言&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (order.getGiftWrapOption() != GiftWrapOption.SELECTED) &#123;</span><br><span class="line">        sendErrorMessage(<span class="string">&quot;未选择礼品包装选项&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行礼品订单处理操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sendErrorMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">    <span class="comment">// 发送错误消息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重构后的代码中，我们将原来的单个方法拆分成了多个方法。<code>processOrder</code> 方法负责处理整个订单流程的控制，进行基本的前置条件检查，然后根据订单类型（礼品订单或非礼品订单）调用相应的处理方法。</p><p><code>processStandardOrder</code> 方法用于处理非礼品订单，而 <code>processGiftOrder</code> 方法用于处理礼品订单。这样，我们可以在具体的处理方法中添加更多的逻辑，而不会让整个代码过于复杂。同时，通过使用早期返回，遇到不满足条件的情况就会提前返回错误消息，避免了过多的嵌套条件。</p><p>另外，我们还引入了一个辅助方法 <code>sendErrorMessage</code>，用于发送错误消息，避免了重复的代码。</p><p>这样的重构使得代码结构更加清晰，逻辑更易于理解和维护。每个方法负责一个具体的任务，代码的可读性和可维护性都得到了提升。</p><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p>随着需求发生变化，不同状态的订单需要有不同的处理方式，当当前的方法不再满足现状时，就需要进行扩充，复杂度也会相应提升。为了进一步应对复杂度的提升，可以考虑适合的设计模式。</p><p>设计模式通过提供可重用的解决方案，帮助我们管理软件复杂度。它们提供了一种通用的、经过验证的方法来解决常见的软件设计问题，使得系统更易于理解、扩展和修改。同时，设计模式也促进了代码的重用和降低了系统的耦合度，从而提高了软件的质量和可维护性。</p><p>以上面的例子，要根据不同的订单状态生成不同的后续处理行为，可以使用策略模式来表达这一设计。策略模式允许定义一系列算法（策略），将它们封装在独立的策略类中，并使得它们可以互相替换。</p><p>下面是使用策略模式来重构的代码示例：</p><p>首先，定义一个接口 <code>OrderProcessingStrategy</code>，表示订单处理策略，其中包含一个 <code>processOrder()</code> 方法来执行订单处理操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderProcessingStrategy</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">processOrder</span><span class="params">(Order order)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，实现不同的订单处理策略，每个策略都实现 <code>OrderProcessingStrategy</code> 接口，并根据订单状态执行相应的处理操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaidShippedOrderStrategy</span> <span class="keyword">implements</span> <span class="title class_">OrderProcessingStrategy</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processOrder</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">        <span class="comment">// 执行订单被支付且已发货的处理操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaidNotShippedOrderStrategy</span> <span class="keyword">implements</span> <span class="title class_">OrderProcessingStrategy</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processOrder</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">        <span class="comment">// 执行订单被支付但未发货的处理操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnpaidOrderStrategy</span> <span class="keyword">implements</span> <span class="title class_">OrderProcessingStrategy</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processOrder</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">        <span class="comment">// 执行订单未支付的处理操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InvalidOrderStrategy</span> <span class="keyword">implements</span> <span class="title class_">OrderProcessingStrategy</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processOrder</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">        <span class="comment">// 执行无效订单的处理操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，在 <code>Order</code> 类中添加一个 <code>process()</code> 方法，用来触发订单的处理操作。在该方法中，根据订单状态选择相应的策略，并调用策略的 <code>processOrder()</code> 方法来执行处理操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> OrderProcessingStrategy processingStrategy;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他属性和方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (processingStrategy == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 默认处理策略</span></span><br><span class="line">            processingStrategy = <span class="keyword">new</span> <span class="title class_">InvalidOrderStrategy</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        processingStrategy.processOrder(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，在客户端代码中，我们可以创建订单对象，并根据订单状态设置相应的处理策略。通过调用订单对象的 <code>process()</code> 方法来触发订单的处理操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">        <span class="comment">// 根据订单状态设置对应的处理策略</span></span><br><span class="line">        <span class="keyword">if</span> (order.getPaymentStatus() == PaymentStatus.PAID) &#123;</span><br><span class="line">            <span class="keyword">if</span> (order.getShippingStatus() == ShippingStatus.SHIPPED) &#123;</span><br><span class="line">                order.setProcessingStrategy(<span class="keyword">new</span> <span class="title class_">PaidShippedOrderStrategy</span>());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                order.setProcessingStrategy(<span class="keyword">new</span> <span class="title class_">PaidNotShippedOrderStrategy</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            order.setProcessingStrategy(<span class="keyword">new</span> <span class="title class_">UnpaidOrderStrategy</span>());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        order.process();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过使用策略模式，我们可以将不同状态的订单处理逻辑解耦，使得每个策略类负责自己的处理操作。这样，可以更灵活地扩展和修改不同订单状态的处理行为，同时避免了原始代码的大泥球结构。</p><h3 id="领域驱动设计"><a href="#领域驱动设计" class="headerlink" title="领域驱动设计"></a>领域驱动设计</h3><p>从电商交易流程上来说有以下简单几步：</p><ol><li>用户在商品详情页面下单。</li><li>下单后用户进行支付。</li><li>支付后商家发货给用户。</li><li>用户收货后确认完成订单。</li><li>订单详情页展示订单、支付、物流信息。</li></ol><p>这个处理流程需要一整个系统的支持才能实现。其中每一步执行后都需要有后继行为和通知，这些通知可能是以站内的、短信的方式触达用户，或者通过一些机制发送给下游系统。这时候就涉及到一个决策，哪些是我交易系统的核心能力，哪些是外围能力。如果前期缺乏良好的架构设计，有可能演变成一个”大泥球”系统。</p><p><strong>为了避免系统的无序性演变，可以通过领域驱动设计的思想，识别交易领域核心行为，保护领域内部行为不被侵蚀，及领域内部行为是不变或者少变的。</strong></p><p>领域驱动设计提倡将软件系统划分为不同的层次，以便更好地组织和解耦系统的各个部分。在DDD中，常用的四层架构和对应职责如下：</p><p><strong>用户界面层（User Interface Layer）</strong>：</p><ul><li>负责展示商品详情页面，并接收用户的下单请求。</li><li>在下单后展示订单、支付和物流信息。</li></ul><p><strong>应用层（Application Layer）</strong>：</p><ul><li>接收用户界面层的请求，并进行必要的参数验证。</li><li>调用领域层的服务来处理下单、支付、发货和确认收货等操作。</li><li>提供查询服务，以获取订单、支付和物流信息。</li></ul><p><strong>领域层（Domain Layer）</strong>：</p><ul><li>定义订单（Order）实体，包含订单号、商品信息、支付信息、物流信息等属性，并处理与订单相关的业务逻辑。</li><li>实现下单、支付、发货和确认收货等操作的领域服务（OrderService）。</li><li>使用领域事件（Domain Event）来处理订单状态的变化，例如支付成功、发货操作等。</li></ul><p><strong>基础设施层（Infrastructure Layer）</strong>：</p><ul><li>实现与外部系统的交互，如支付服务、物流服务等。这些可以使用外部API或模拟实现。</li><li>提供持久化机制，用于存储订单、支付和物流信息。可以使用数据库或其他适合的持久化方式。</li></ul><p>下面是一个示意性的代码结构，用于展示不同层级及其职责：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- xxx-order-app</span><br><span class="line">  - UserInterface</span><br><span class="line">    - ProductDetailPage // 商品详情页面</span><br><span class="line">    - OrderDetailPage // 订单详情页面</span><br><span class="line">  - Application</span><br><span class="line">    - OrderApplicationService // 订单应用服务</span><br><span class="line">  - Domain</span><br><span class="line">    - Order // 订单实体</span><br><span class="line">    - OrderService // 订单领域服务</span><br><span class="line">    - Events // 领域事件</span><br><span class="line">  - Infrastructure</span><br><span class="line">    - PaymentService // 支付服务</span><br><span class="line">    - LogisticsService // 物流服务</span><br><span class="line">    - OrderRepository // 资源库</span><br></pre></td></tr></table></figure><p>在这个设计中，每个层级都有不同的职责和角色，以实现更好的代码结构和可维护性。用户界面层负责展示页面和处理用户输入，应用层负责协调各个领域服务的调用，领域层负责处理业务逻辑，基础设施层负责与外部系统的交互和数据持久化。</p><p>这样的设计可以更好地组织代码，使不同的职责分离，减少了耦合性，并且便于扩展和修改。同时，通过领域驱动设计，我们能够更好地表达业务领域的概念和规则，使代码更加贴近业务需求。</p><p>**用户界面层 (Presentation Layer)**：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderDetailPage</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> OrderApplicationService orderService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他属性和方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">displayOrderDetails</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">        <span class="comment">// 在订单详情页面展示物流信息、订单信息、支付信息</span></span><br><span class="line">        <span class="type">LogisticsInfo</span> <span class="variable">logisticsInfo</span> <span class="operator">=</span> orderService.getUpdatedLogisticsInfo(order);</span><br><span class="line">        <span class="comment">// 展示物流信息...</span></span><br><span class="line"></span><br><span class="line">        <span class="type">OrderInfo</span> <span class="variable">orderInfo</span> <span class="operator">=</span> orderService.getOrderInfo(order);</span><br><span class="line">        <span class="comment">// 展示订单信息...</span></span><br><span class="line"></span><br><span class="line">        <span class="type">PaymentInfo</span> <span class="variable">paymentInfo</span> <span class="operator">=</span> orderService.getPaymentInfo(order);</span><br><span class="line">        <span class="comment">// 展示支付信息...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用户操作事件响应</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">payOrder</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">        orderService.payOrder(order);</span><br><span class="line">        displayOrderDetails(order);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shipOrder</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">        orderService.shipOrder(order);</span><br><span class="line">        displayOrderDetails(order);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completeOrder</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">        orderService.completeOrder(order);</span><br><span class="line">        displayOrderDetails(order);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**应用层 (Application Layer)**：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderApplicationService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> OrderRepository orderRepository;</span><br><span class="line">    <span class="keyword">private</span> PaymentService paymentService;</span><br><span class="line">    <span class="keyword">private</span> LogisticsService logisticsService;</span><br><span class="line">    <span class="keyword">private</span> NotificationService notificationService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他属性和构造方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">payOrder</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">        paymentService.processPayment(order);</span><br><span class="line">        order.markAsPaid();</span><br><span class="line">        orderRepository.save(order);</span><br><span class="line">        notificationService.notifyOrderPaid(order);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shipOrder</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">        order.markAsShipped();</span><br><span class="line">        orderRepository.save(order);</span><br><span class="line">        notificationService.notifyOrderShipped(order);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completeOrder</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">        order.markAsCompleted();</span><br><span class="line">        orderRepository.save(order);</span><br><span class="line">        notificationService.notifyOrderCompleted(order);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> LogisticsInfo <span class="title function_">getUpdatedLogisticsInfo</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> logisticsService.queryLogisticsInfo(order.getShippingAddress());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> OrderInfo <span class="title function_">getOrderInfo</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OrderInfo</span>(order.getOrderNumber(), order.getOrderItems(), order.getTotalAmount());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> PaymentInfo <span class="title function_">getPaymentInfo</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> paymentService.getPaymentInfo(order.getPaymentId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**领域层 (Domain Layer)**：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String orderNumber;</span><br><span class="line">    <span class="keyword">private</span> List&lt;OrderItem&gt; orderItems;</span><br><span class="line">    <span class="keyword">private</span> BigDecimal totalAmount;</span><br><span class="line">    <span class="keyword">private</span> OrderStatus status;</span><br><span class="line">    <span class="keyword">private</span> String paymentId;</span><br><span class="line">    <span class="keyword">private</span> Address shippingAddress;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他属性和构造方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">markAsPaid</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (status == OrderStatus.UNPAID) &#123;</span><br><span class="line">            status = OrderStatus.PAID;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">markAsShipped</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (status == OrderStatus.PAID) &#123;</span><br><span class="line">            status = OrderStatus.SHIPPED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">markAsCompleted</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (status == OrderStatus.SHIPPED) &#123;</span><br><span class="line">            status = OrderStatus.COMPLETED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他方法和领域业务规则</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**基础设施层 (Infrastructure Layer)**：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderRepository</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(Order order)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DatabaseOrderRepository</span> <span class="keyword">implements</span> <span class="title class_">OrderRepository</span> &#123;</span><br><span class="line">    <span class="comment">// 实现 OrderRepository 接口，利用数据库来保存订单信息</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PaymentService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">processPayment</span><span class="params">(Order order)</span>;</span><br><span class="line">    PaymentInfo <span class="title function_">getPaymentInfo</span><span class="params">(String paymentId)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExternalPaymentService</span> <span class="keyword">implements</span> <span class="title class_">PaymentService</span> &#123;</span><br><span class="line">    <span class="comment">// 实现 PaymentService 接口，与第三方支付接口进行交互处理订单支付</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LogisticsService</span> &#123;</span><br><span class="line">    LogisticsInfo <span class="title function_">queryLogisticsInfo</span><span class="params">(Address address)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExternalLogisticsService</span> <span class="keyword">implements</span> <span class="title class_">LogisticsService</span> &#123;</span><br><span class="line">    <span class="comment">// 实现 LogisticsService 接口，与物流查询接口进行交互查询物流信息</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">NotificationService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">notifyOrderPaid</span><span class="params">(Order order)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">notifyOrderShipped</span><span class="params">(Order order)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">notifyOrderCompleted</span><span class="params">(Order order)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmailNotificationService</span> <span class="keyword">implements</span> <span class="title class_">NotificationService</span> &#123;</span><br><span class="line">    <span class="comment">// 实现 NotificationService 接口，通过邮件发送订单通知</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>从上述代码中我们可以看到，基础设施层和领域层设计符合依赖倒置原则，从调用关系看领域层调用基础设施层进行数据的交互，而从依赖关系来看，领域层依赖于领域抽象，不依赖于具体实现，DDD 的精髓在于保护核心领域的自治性，降低层间的偶合度，同时有助于遵循单一职责原则，关注领域核心行为的管理和维护。</strong></p><h3 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h3><p><strong>这篇文章在这里第一次直面架构，讨论的问题是软件架构（architecture）究竟是什么？从我的经验总结，是站在更高的层次去整体分析软件系统，抓大放小，把握重点，重点是组织结构，而不论是子系统、模块、包，还是分层、服务等，都可以看作为一个”构件”，需要关注的是如何组织使整体高效有序。</strong></p><p>如果你要想理解它，可以从设计者的角度去审视，上面的方法从小到大逐层递进地讲了代码的组织形式，后面还要面临更多的复杂性问题，如当用户达到千万级规模，程序如何高效部署和管理，多人协作开发时如何做到高效。</p><p>微服务架构是一种软件架构风格，它将一个大型应用程序拆分为一组小型、独立的服务，每个服务都有自己的业务功能，并通过轻量级的通信机制进行交互。每个服务都可以独立开发、部署和扩展，从而提供了灵活性、可伸缩性和可维护性。有下面几个特点：</p><ol><li><p>拆分与自治性：应用程序被拆分为多个小型服务，每个服务关注于特定的业务功能。每个服务都是自治的，可以独立开发、部署和运行，使团队可以并行开发和部署不同的服务。</p></li><li><p>独立部署和扩展：由于每个服务都是独立的，可以根据需求独立部署和扩展。这种灵活性使得系统能够更好地应对高负载和变化的需求，同时减少了对整个应用的影响。</p></li><li><p>技术多样性：微服务架构允许使用不同的技术栈和编程语言来实现不同的服务。这使得团队可以选择最适合其需求的技术，提高开发效率和灵活性。</p></li><li><p>弹性和容错性：由于每个服务都是独立的，当一个服务出现故障时，其他服务仍然可以正常运行，从而提高系统的弹性和容错性。</p></li><li><p>松耦合和可维护性：微服务通过轻量级的通信机制（如RESTful API或消息队列）进行交互，服务之间的耦合度较低。这使得系统更易于理解、修改和维护。</p></li><li><p>团队自治和快速交付：每个服务都可以由独立的团队负责开发和维护，团队可以根据自己的需求和进度进行快速交付。这种团队自治的方式促进了敏捷开发和持续交付的实践。</p></li></ol><p>然而，微服务架构也带来了一些挑战，如服务间通信的复杂性、分布式事务管理、服务发现和监控等。在采用微服务架构时，需要仔细权衡利弊，并根据具体的业务需求和团队能力做出决策。微服务更多是关于组织和团队，而不是技术。</p><p>这里必须要谈一下康威定律：Conway’s law: Organizations which design systems[…] are constrained to produce designs which are copies of the communication structures of these organizations.<br>（设计系统的组织，其产生的设计和架构等价于组织间的沟通结构。）</p><p>简单来说，这意味着一个组织的沟通和组织结构会直接影响到所开发的软件系统的结构。</p><p><img src="/resource/img/2024-02-14-22-37-19.png"></p><ol><li><p>组织结构：组织内部的团队结构、沟通渠道和决策层级等因素会直接影响到软件系统的设计。</p></li><li><p>沟通结构：组织内部团队之间的沟通方式和频率会反映在系统设计中。如果团队之间的沟通不畅或存在壁垒，那么系统的设计可能会反映出这种分隔和隔离。</p></li><li><p>系统结构：根据康威定律，软件系统的结构往往会与组织结构相似。如果组织结构是分散的，那么系统的结构可能会呈现出分散的特征；如果组织结构是集中的，那么系统的结构可能会呈现出集中的特征。</p></li></ol><p>康威定律的应用意义在于，通过理解组织结构和沟通结构对系统设计的影响，可以更好地规划和调整组织结构，以促进系统的设计和开发。例如，如果希望实现松耦合和模块化的系统，可以通过优化团队之间的沟通和协作方式来达到这个目标。</p><hr><p><strong>总结</strong></p><p>这篇文章整理了近几年的关于治理系统复杂性的一些经验，主要包括概念介绍、度量方式、设计原则、治理方法几个方面去介绍。其中治理方法部分由浅入深的介绍了几个方式，不同方式面临的问题复杂程度也是不同的。这些方式通过不同的角度帮助我们管理软件复杂度，提高代码的可维护性和可扩展性，确保软件系统与业务需求紧密结合。管理软件复杂性是软件开发过程中非常重要的一环，不论面对何种问题，“简单，易于理解”都应该是我们要坚持的方向。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/resource/img/2024-02-14-23-36-09.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;本文讨论了软件复杂性及其产生原因，介绍了如何度量软件复杂性，及 SOLID 软件设计原则，并探讨管理复杂性的方法，包括使用代码重构、设计模式、领域驱动设计等。通过遵循这些原则和方法，开发人员可以降低软件复杂性，提高代码质量和可维护性。这篇文章内容涵盖了软件开发的道与术，希望能对你所有帮助，欢迎评论交流～&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;什么是软件复杂性&lt;/li&gt;
&lt;li&gt;软件复杂性产生原因&lt;/li&gt;
&lt;li&gt;如何度量软件复杂性&lt;/li&gt;
&lt;li&gt;SOLID 软件设计原则&lt;/li&gt;
&lt;li&gt;管理复杂性的方法&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>服务拆分的几种处理思路</title>
    <link href="https://noogel.xyz/2022/11/24/1.html"/>
    <id>https://noogel.xyz/2022/11/24/1.html</id>
    <published>2022-11-24T00:00:00.000Z</published>
    <updated>2025-07-23T07:30:58.916Z</updated>
    
    <content type="html"><![CDATA[<h2 id="场景说明"><a href="#场景说明" class="headerlink" title="场景说明"></a>场景说明</h2><p>目标是需要拆分出内部服务 Y 为独立的系统，且暂时不改变系统 A 的被依赖关系，拆分前的情况如下图。</p><p>这里假定两个接口层处理模块只会调用只会调用内部服务 Y，并且其中存在着业务逻辑，也许你会疑惑接口层为什么会有业务逻辑，事实上你大多数情况下会遇到。更具体的说，接口层的业务接口 1 中包含业务逻辑，于是会产生对内部服务 Y 的两个及以上接口的调用。</p><p><img src="/resource/img/2022-11-24-01-56-42.png"></p><h2 id="处理思路"><a href="#处理思路" class="headerlink" title="处理思路"></a>处理思路</h2><p>那么你会遇到以下几种情况需要处理。</p><span id="more"></span><p><strong>针对 case 1 的 RPC 接口逻辑两种处理方式：</strong></p><ol><li>左图：拷贝 rpc 协议在系统 B 实现逻辑搬迁，系统 A 只有接口层，且只有对象转换，无任何逻辑。</li><li>右图：基于内部服务 Y 接口定义，迁移服务层逻辑到系统 B ，实现基于 BizDto  定义的 rpc 接口，系统 A 在接口层保留业务逻辑，只需要增加 BizDto  到 BizThriftVo2 对象的转换。</li></ol><p><img src="/resource/img/2022-11-24-01-56-59.png"></p><p><strong>针对 case2 的 HTTP 接口逻辑也有两种处理方式：</strong></p><ol><li>左图：同样，基于内部服务 Y 接口定义，迁移服务层逻辑到系统 B ，实现基于 BizDto  定义的 rpc 接口，系统 A 在接口层保留业务逻辑，只需要增加 BizDto  到 BizThriftVo2 对象的转换。</li><li>右图：拷贝 http 协议在系统 B 实现逻辑搬迁，BizThriftVo3 基于 BizHttpVo  定义，系统 A 只有接口层，且只有对象转换，无任何逻辑。</li></ol><p><img src="/resource/img/2022-11-24-01-57-09.png"></p><p><strong>针对 case 3 的内部服务调用：</strong></p><p>对于内部服务调用，基于内部服务 Y 接口定义，迁移服务层逻辑到系统 B ，实现基于 BizDto  定义的 rpc 接口，系统 A 只需要增加 BizDto  到 BizThriftVo2 对象的转换。</p><p>对 内部服务 X 调 Y 的场景下，需要注意其中是否包含事务型依赖关系。因为如果从本地调用改为远程调用可能会破坏整个事务的完整性，产生数据不一致。</p><p><img src="/resource/img/2022-11-24-01-57-20.png"></p><h2 id="更优解"><a href="#更优解" class="headerlink" title="更优解"></a>更优解</h2><p>如果我们要拆分内部服务 Y，从上游的依赖来看，有系统 A 和手机客户端的依赖关系（通过虚线表示）。</p><p><img src="/resource/img/2022-11-24-01-57-28.png"></p><p>如果我们不考虑上下游依赖关系，就会和上面说的几种情况一样处理，这时候系统 B 的 RPC 接口层就只是一层很薄的代理，存在的问题是资源的浪费和服务稳定性的打折扣，而且你还要写比较多的胶水代码。而更优的一种方式是消除这种传递依赖，使系统 A 和系统 B 解耦，使系统 C 的功能更内聚，每个系统只负责自己对象和 BizThriftVo  对象的转换。</p><p><img src="/resource/img/2022-11-24-01-57-38.png"></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;场景说明&quot;&gt;&lt;a href=&quot;#场景说明&quot; class=&quot;headerlink&quot; title=&quot;场景说明&quot;&gt;&lt;/a&gt;场景说明&lt;/h2&gt;&lt;p&gt;目标是需要拆分出内部服务 Y 为独立的系统，且暂时不改变系统 A 的被依赖关系，拆分前的情况如下图。&lt;/p&gt;
&lt;p&gt;这里假定两个接口层处理模块只会调用只会调用内部服务 Y，并且其中存在着业务逻辑，也许你会疑惑接口层为什么会有业务逻辑，事实上你大多数情况下会遇到。更具体的说，接口层的业务接口 1 中包含业务逻辑，于是会产生对内部服务 Y 的两个及以上接口的调用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/resource/img/2022-11-24-01-56-42.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;处理思路&quot;&gt;&lt;a href=&quot;#处理思路&quot; class=&quot;headerlink&quot; title=&quot;处理思路&quot;&gt;&lt;/a&gt;处理思路&lt;/h2&gt;&lt;p&gt;那么你会遇到以下几种情况需要处理。&lt;/p&gt;</summary>
    
    
    
    
    <category term="架构" scheme="https://noogel.xyz/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>关于读写分离架构的思考</title>
    <link href="https://noogel.xyz/2022/04/12/1.html"/>
    <id>https://noogel.xyz/2022/04/12/1.html</id>
    <published>2022-04-12T00:00:00.000Z</published>
    <updated>2025-07-23T07:30:58.916Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>分布式系统主要的目的之一就是解决大量用户的高并发问题。自己做过几个业务系统，也和别人聊过他们所做过的业务系统，其实大家都使用了相同的数据库，有的系统会使用 Redis 缓存，会使用 MQ 做系统解耦，有的也会使用搜索引擎。这些系统的构件相同的地方都是在处理数据，只不过职责不同罢了。归纳有以下几类：</p><ul><li>数据库提供结构化的持久保证。</li><li>缓存为了提高并发和响应速度。</li><li>MQ 带着事件消息将后续任务解耦。</li><li>搜索引擎提供快速的全文检索能力。</li></ul><p>以上这几个构件就可以组成相对完备的实时数据系统，可以应对常见的业务需求。</p><h2 id="数据框架"><a href="#数据框架" class="headerlink" title="数据框架"></a>数据框架</h2><p>关于一个业务系统的通用数据框架可以用下面的图来表述。</p><span id="more"></span><p><img src="/resource/img/2022-04-14-01-40-41.png"></p><p>关于整个框架的运行方式可以简单的从读和写两个角度来看。</p><p>从写的角度来看，首先需要保证数据被正确处理和持久化，处理完主存数据，需要发送事件消息到 MQ，然后将数据同步到高速缓存和搜索引擎，整个流程是需要满足事务性。<br>从读的角度来看，需要面临的主要问题是和主存的一致性问题，一般保证弱一致性即可。读数据的简化流程是先读缓存，读不到读数据库，再回填缓存。</p><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>而各式各样业务功能和逻辑对数据的处理都归为两种操作——读和写，只是不同的系统侧重点不同，主要分为以下几类：</p><ul><li>『读多写少』的系统<ul><li>百度搜索</li><li>电商商品搜索</li></ul></li><li>『写多读少』的系统<ul><li>广告计费系统</li><li>双十一的支付系统</li></ul></li><li>『读多写多』的系统<ul><li>电商秒杀</li><li>新浪微博</li></ul></li></ul><h2 id="处理思路"><a href="#处理思路" class="headerlink" title="处理思路"></a>处理思路</h2><h3 id="高并发读"><a href="#高并发读" class="headerlink" title="高并发读"></a>高并发读</h3><p>首先说说『读多』的解决方案，最常见的是用户到服务器之间的多级缓存策略（也许描述的不够准确，可以继续往下看），从服务端到用户逐层递进有以下几种：</p><ol><li>分布式缓存</li><li>内存缓存</li><li>CDN 缓存</li><li>客户端缓存</li></ol><p>从上到下，缓存越接近用户对服务器的压力约小，访问速度越快，弊端是一致性的处理越不可控，机器成本和问题排查成本越高。</p><p>从数据变化角度来看可以分为动态内容和静态内容，动态内容可以根据业务需要采用分布式缓存和内存缓存的方式，可以通过设置过期时间来自动刷新。静态内容可以通过 CDN 和客户端缓存的方式，一般是一些图片、HTML、CSS、JS 文件。</p><p>缓存的更新方式可以分为推和拉两种形式。缓存常见的三个问题略过。</p><p>第二种策略是串行读改并行，对于用户的一个请求，如果需要三个外部依赖，耗时分别是 T1\T2\T3。如果是串行化调用总耗时是 T1+T2+T3，在三者没有耦合关系的情况下，改成异步执行的总耗时为 Max(T1, T2, T3)。</p><p>第三种策略是批量请求，通过缓存或存储提供的批量命令，可以将单次读写请求改为批量请求，可以减少网络传输的总耗时。</p><h3 id="高并发写"><a href="#高并发写" class="headerlink" title="高并发写"></a>高并发写</h3><p>对于『写多』的解决方案，最常见的解决思路是对于<strong>数据分片</strong>，比如现实世界的高速多车道，医院的多诊室，以此来提升整体的吞吐量。在服务端比较常见的是数据库层面的分库分表，通过合理的分片算法，将数据尽量均匀的分散在不同的库表，通过分库可以利用起多台机器的资源。</p><p>除此之外，数据分片的设计策略还在其它方面有所体现：</p><ul><li>Kafka 的多个 Partition 的设计。</li><li>ConcurrentHashMap 中 HashEntry 和 Segment 设计。</li></ul><p>第二种策略是<strong>任务分片</strong>，将一个大任务拆分成若干子任务执行。你可能会立刻想到 CPU 的指令流水线，一条指令分为取指、译码、执行、访存、写回五个阶段，单条指令占用 5 个时间周期，每增加一条指令整体只需要再增加 1 个时间周期。</p><p><img src="/resource/img/2022-04-14-01-41-17.png"></p><p>这些策略使用的就是分治思想，耳熟能详的就是 Map&#x2F;Reduce 了，在 Java 中 ForkJoinPool 也是利用这一思想设计。</p><p><strong>分治</strong>从字面上也很容易理解，分、治其实还有个合并的过程：</p><ul><li>分(Divide)：递归解决较小的问题(到终止层或者可以解决的时候停下)。</li><li>治(Conquer)：递归求解，如果问题够小直接求解。</li><li>合并(Combine)：将子问题的解合并得到父类问题解。</li></ul><p>第三种策略是队列缓冲，如果请求量超过系统最大负载，可以放到 MQ 异步化处理请求，这时需要客户端支持异步结果响应。秒杀场景就可以将瞬时大量用户请求放到消息中间件，由服务端慢慢消费，再异步通知用户。</p><p>第四种策略是批量写。</p><h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><p>根据数据的访问特点，上面提到的各种策略本质上是读写分离，是微服务架构中提到的 CQRS。关于读写分离模式一般具有以下特征：</p><ol><li>读和写设计的数据结构不同，为系统的读和写分别设计两个视图，设计适合高并发场景的数据结构和模型。</li><li>写数据通过数据库的分库分表来提高并发能力，然后异步写入缓存来提高读并发能力。通过异步写入搜索引擎来实现全文搜索。</li><li>因为缓存和搜索引擎是异步写入的，所以读到变更后的数据会有一定延迟，保障最终一致性，而非强一致性。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>回到最上面总结的数据框架，实现一个高并发系统所需的主要数据构件有缓存、数据库、搜索引擎、消息队列，以读和写两个视角将用户的大量请求分流到不同地方处理，然后通过多副本的方式对数据构件水平扩容，这本身也是一种分治思想。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;分布式系统主要的目的之一就是解决大量用户的高并发问题。自己做过几个业务系统，也和别人聊过他们所做过的业务系统，其实大家都使用了相同的数据库，有的系统会使用 Redis 缓存，会使用 MQ 做系统解耦，有的也会使用搜索引擎。这些系统的构件相同的地方都是在处理数据，只不过职责不同罢了。归纳有以下几类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据库提供结构化的持久保证。&lt;/li&gt;
&lt;li&gt;缓存为了提高并发和响应速度。&lt;/li&gt;
&lt;li&gt;MQ 带着事件消息将后续任务解耦。&lt;/li&gt;
&lt;li&gt;搜索引擎提供快速的全文检索能力。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上这几个构件就可以组成相对完备的实时数据系统，可以应对常见的业务需求。&lt;/p&gt;
&lt;h2 id=&quot;数据框架&quot;&gt;&lt;a href=&quot;#数据框架&quot; class=&quot;headerlink&quot; title=&quot;数据框架&quot;&gt;&lt;/a&gt;数据框架&lt;/h2&gt;&lt;p&gt;关于一个业务系统的通用数据框架可以用下面的图来表述。&lt;/p&gt;</summary>
    
    
    
    
    <category term="架构" scheme="https://noogel.xyz/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>统一博客系统变更日志</title>
    <link href="https://noogel.xyz/2022/04/10/1.html"/>
    <id>https://noogel.xyz/2022/04/10/1.html</id>
    <published>2022-04-10T00:00:00.000Z</published>
    <updated>2025-07-23T07:30:58.915Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇文章是汇总历史发布过的，所有关于我的博客编写发布系统文章。文章以时间线倒序的方式罗列整理。</p><h2 id="2022-04-07-博客主题必备功能"><a href="#2022-04-07-博客主题必备功能" class="headerlink" title="2022-04-07 博客主题必备功能"></a>2022-04-07 博客主题必备功能</h2><ol><li>支持数学公式</li><li>支持 mermaid 流程图</li><li>支持标准的 Markdown</li></ol><p><a href="/2022/04/07/1.html">测试页面</a></p><h2 id="2022-02-13-统一博客编写环境"><a href="#2022-02-13-统一博客编写环境" class="headerlink" title="2022-02-13 统一博客编写环境"></a>2022-02-13 统一博客编写环境</h2><p>日常会在 macOS 和 Ubuntu 之间切换，博客是基于 Hexo 生成的，不同系统的 Node 版本会有较大差异、环境稳定性比较差，为了方便平时写博客，想到了用 Docker 统一博客生成环境，于是自己写了 Dockerfile，在结合 VS Code 编写，可以做到系统无差。</p><p><img src="/resource/img/2022-02-13-21-39-39.png"></p><p>日常开发只需要在 VS Code 中边写边预览，图片是通过 PasteImage 插件快捷键插入。预览和发布只需要以下两个命令即可。</p><p>预览本地博客：<code>alias run-blog=&#39;docker exec -it container_id python utils/goto.py blog&#39;</code></p><p>发布博客文章：<code>alias push-blog=&#39;docker exec -it container_id python utils/goto.py push&#39;</code></p><p>Docker 项目：<a href="https://github.com/noogel/noogel.github.io.docker">https://github.com/noogel/noogel.github.io.docker</a></p><span id="more"></span><h2 id="2020-04-05-VS-Code-与-HEXO-结合写博客"><a href="#2020-04-05-VS-Code-与-HEXO-结合写博客" class="headerlink" title="2020-04-05 VS Code 与 HEXO 结合写博客"></a>2020-04-05 VS Code 与 HEXO 结合写博客</h2><p>在 mac 机器上可以使用 mweb 来写博客，比较好用的地方就是可以直接把剪贴板的图片粘贴上来，缺点是 mac 键盘超难用并且不支持窗口内开启命令行。平时在家的时候都用 Ubuntu 台式机，博客使用 VS Code 编写，一直以来阻挡我的是图片的粘贴特别费劲，今天发现一个很好用的插件 pasteimage，可以直接将剪贴板图片粘贴到 markdown 使用，并且支持配置保存路径。</p><p><img src="/resource/img/2020-04-05-15-57-27.png"></p><p>然后按照教程配置好参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;pasteImage.path&quot;: &quot;$&#123;projectRoot&#125;/source/resource/img&quot;,</span><br><span class="line">    &quot;pasteImage.basePath&quot;: &quot;$&#123;projectRoot&#125;/source&quot;,</span><br><span class="line">    &quot;pasteImage.forceUnixStyleSeparator&quot;: true,</span><br><span class="line">    &quot;pasteImage.prefix&quot;: &quot;/&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就可以直接将图片粘贴到 markdown 中，其中遇到个问题就是配置不生效，会导致文件直接保存到当前文件目录，具体配置方法可以参考下面连接。</p><blockquote><p><a href="https://www.crifan.com/vscode_how_to_config_setting_plugin/">https://www.crifan.com/vscode_how_to_config_setting_plugin/</a>  这篇文章写的很详细了。<br><a href="https://github.com/mushanshitiancai/vscode-paste-image">https://github.com/mushanshitiancai/vscode-paste-image</a> 这篇是配置教程，里面有些地方比较容易被误导。</p></blockquote><p>对于Linux系统需要有 xclip 支持，使用的时候会给提示的。</p><p><img src="/resource/img/2020-04-05-16-03-56.png"></p><p>另外记录一下 Ubuntu 的截屏和粘贴快捷键：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + Shift + Print Screen  // 区域截屏到剪贴板</span><br><span class="line">Ctrl + Alt + s  // 在 VS Code 中粘贴</span><br></pre></td></tr></table></figure><h2 id="2019-10-27-基本的照片脱敏处理"><a href="#2019-10-27-基本的照片脱敏处理" class="headerlink" title="2019-10-27 基本的照片脱敏处理"></a>2019-10-27 基本的照片脱敏处理</h2><p>我们平时拍照的照片中会包含很多额外信息可能暴露我们的地理位置、拍摄数据、拍照时间等信息。在一些网站上传原图时会暴露这些敏感信息，这个脚本主要用来通过 pillow 库将照片的 exif 信息抹掉。</p><p><img src="/resource/img/carbon_desensitize.png"></p><p>其它校验网站： <a href="https://exif.tuchong.com/">https://exif.tuchong.com/</a></p><p>通过这个网站也可以查看这些额外信息：</p><p><img src="/resource/img/15721576232055.jpg"></p><h2 id="2017-12-06-MWeb-与-HEXO-结合写博客"><a href="#2017-12-06-MWeb-与-HEXO-结合写博客" class="headerlink" title="2017-12-06 MWeb 与 HEXO 结合写博客"></a>2017-12-06 MWeb 与 HEXO 结合写博客</h2><p>『MWeb 是 Mac 平台上一款专业的 Markdown 写作、记笔记、静态博客生成软件。』主要有以下几个优点：</p><ol><li>拖入图片即所见。</li><li>可以边写边展示。</li><li>再配合开发的Python处理脚本可以一行命令自动保存发布。</li></ol><p><img src="/resource/img/1505966065271.jpg" alt="1505966065271"></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这篇文章是汇总历史发布过的，所有关于我的博客编写发布系统文章。文章以时间线倒序的方式罗列整理。&lt;/p&gt;
&lt;h2 id=&quot;2022-04-07-博客主题必备功能&quot;&gt;&lt;a href=&quot;#2022-04-07-博客主题必备功能&quot; class=&quot;headerlink&quot; title=&quot;2022-04-07 博客主题必备功能&quot;&gt;&lt;/a&gt;2022-04-07 博客主题必备功能&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;支持数学公式&lt;/li&gt;
&lt;li&gt;支持 mermaid 流程图&lt;/li&gt;
&lt;li&gt;支持标准的 Markdown&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&quot;/2022/04/07/1.html&quot;&gt;测试页面&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;2022-02-13-统一博客编写环境&quot;&gt;&lt;a href=&quot;#2022-02-13-统一博客编写环境&quot; class=&quot;headerlink&quot; title=&quot;2022-02-13 统一博客编写环境&quot;&gt;&lt;/a&gt;2022-02-13 统一博客编写环境&lt;/h2&gt;&lt;p&gt;日常会在 macOS 和 Ubuntu 之间切换，博客是基于 Hexo 生成的，不同系统的 Node 版本会有较大差异、环境稳定性比较差，为了方便平时写博客，想到了用 Docker 统一博客生成环境，于是自己写了 Dockerfile，在结合 VS Code 编写，可以做到系统无差。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/resource/img/2022-02-13-21-39-39.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;日常开发只需要在 VS Code 中边写边预览，图片是通过 PasteImage 插件快捷键插入。预览和发布只需要以下两个命令即可。&lt;/p&gt;
&lt;p&gt;预览本地博客：&lt;code&gt;alias run-blog=&amp;#39;docker exec -it container_id python utils/goto.py blog&amp;#39;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;发布博客文章：&lt;code&gt;alias push-blog=&amp;#39;docker exec -it container_id python utils/goto.py push&amp;#39;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Docker 项目：&lt;a href=&quot;https://github.com/noogel/noogel.github.io.docker&quot;&gt;https://github.com/noogel/noogel.github.io.docker&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="效率" scheme="https://noogel.xyz/tags/%E6%95%88%E7%8E%87/"/>
    
    <category term="HEXO" scheme="https://noogel.xyz/tags/HEXO/"/>
    
    <category term="Docker" scheme="https://noogel.xyz/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Markdown 语法模板</title>
    <link href="https://noogel.xyz/2022/04/07/1.html"/>
    <id>https://noogel.xyz/2022/04/07/1.html</id>
    <published>2022-04-07T00:00:00.000Z</published>
    <updated>2025-07-23T07:30:58.915Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础语法示例"><a href="#基础语法示例" class="headerlink" title="基础语法示例"></a>基础语法示例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># H1</span><br><span class="line">## H2</span><br><span class="line">### H3</span><br><span class="line">#### H4</span><br><span class="line">##### H5</span><br><span class="line">###### H6</span><br></pre></td></tr></table></figure><blockquote><p>引用</p></blockquote><ul><li>无序列表</li><li>无序列表</li><li>无序列表</li></ul><ol><li>有序列表</li><li>有序列表</li><li>有序列表</li></ol><p><em>斜体</em></p><p><strong>粗体</strong></p><p><code>行内代码</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">多行代码</span><br><span class="line">多行代码</span><br></pre></td></tr></table></figure><p>分割线：</p><hr><h2 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$d=\sqrt&#123;\sum_&#123;k=1&#125;^n(x\_&#123;1k&#125;-x\_&#123;2k&#125;)^2&#125;$$</span><br></pre></td></tr></table></figure><p>效果：</p><p>$$d&#x3D;\sqrt{\sum_{k&#x3D;1}^n(x_{1k}-x_{2k})^2}$$</p><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><pre class="mermaid">sequenceDiagram    老板C ->> 员工C : 开始实行996        par 并行        员工C ->> 员工C : 刷微博    and        员工C ->> 员工C : 工作    and        员工C ->> 员工C : 刷朋友圈    end        员工C -->> 老板C : 9点下班</pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基础语法示例&quot;&gt;&lt;a href=&quot;#基础语法示例&quot; class=&quot;headerlink&quot; title=&quot;基础语法示例&quot;&gt;&lt;/a&gt;基础语法示例&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=</summary>
      
    
    
    
    
    <category term="模板" scheme="https://noogel.xyz/tags/%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>架构设计的 ROI 关注点</title>
    <link href="https://noogel.xyz/2022/03/29/1.html"/>
    <id>https://noogel.xyz/2022/03/29/1.html</id>
    <published>2022-03-29T00:00:00.000Z</published>
    <updated>2025-07-23T07:30:58.916Z</updated>
    
    <content type="html"><![CDATA[<p>ROI 是指投资回报率，对应系统架构设计上来说需要从业务发展和收益角度综合评估 ROI 来进行取舍。需要确保架构符合业务的发展，在设计开发时需要重点关注一下几个地方：</p><ol><li>系统迭代需求的提出。<ul><li>为了满足业务需求</li><li>为了解决系统问题<ul><li>需要收集系统问题，找出核心问题。</li></ul></li></ul></li><li>提出设计方案。<ul><li>明确核心价值，解决了什么样的关键问题、系统难点、业务需求。</li><li>实现成本<ul><li>复杂度，实现设计方案的复杂度是否可以接受。<ul><li>技术复杂度，系统的并发性、可用性、一致性要求。</li><li>业务复杂度，对于业务需求的支持程度。</li></ul></li><li>人力成本，是否满足各方对人力消耗和时间节点上的要求。</li></ul></li><li>设计的局限性<ul><li>可量化指标，项目的结果是否可以被量化，被观测到。</li><li>可测试性，测试的覆盖度能到多少，QA 的测试成本有多少。</li><li>可扩展性，下一次迭代可以降低多少成本。</li></ul></li></ul></li><li>评估产出收益，项目的价值。<ul><li>人力节省</li><li>机器节省</li><li>收入提升</li><li>流量提升</li></ul></li></ol><p>按照上述清单可以在进行架构设计时进行思维训练，同时不要局限于清单，做到动态调整。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;ROI 是指投资回报率，对应系统架构设计上来说需要从业务发展和收益角度综合评估 ROI 来进行取舍。需要确保架构符合业务的发展，在设计开发时需要重点关注一下几个地方：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;系统迭代需求的提出。&lt;ul&gt;
&lt;li&gt;为了满足业务需求&lt;/li&gt;
&lt;li&gt;为了解</summary>
      
    
    
    
    
    <category term="架构" scheme="https://noogel.xyz/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>技术项目复盘经验</title>
    <link href="https://noogel.xyz/2022/03/14/1.html"/>
    <id>https://noogel.xyz/2022/03/14/1.html</id>
    <published>2022-03-14T00:00:00.000Z</published>
    <updated>2025-07-23T07:30:58.918Z</updated>
    
    <content type="html"><![CDATA[<p>基于多次复盘的经验汇总，仅以当前工作环境做汇总，供参考。</p><ol><li>系统问题定位和解决<ul><li>需要抓住足够多的证据链，不能臆测代码和运行机制。常用手段有 curl，日志，sentry。</li><li>能在本地复现不要跑到联调，降低定位成本。</li><li>排查超过两小时并且无清晰路径下需要扩大问题知晓范围，找人协助。</li><li>排查过程需要有详尽的记录，记录要字符串，减少截图数据。</li></ul></li><li>RFC 设计<ul><li>跨系统交互需要补充系统交互图，明确系统边界。</li><li>需要数据备份和回滚方案，做好预案。</li><li>设计文档需要同步小组群。</li><li>评审会需要拉上 leader 知晓。</li><li>系统设计需要考虑兼容性和可观测性。</li><li>需求项目要建立人员 backup 机制。</li></ul></li><li>系统开发<ul><li>迁移是迁移，不要做重构，保证功能原样，同时也会降低测试成本。</li><li>警惕复制代码的行为，必须知晓你提交代码的逻辑和背后含义。</li><li>对于复杂逻辑和接口需要有详尽的注释，或者粘贴 wiki 链接说明设计。</li><li>新系统设计需要维护起测试用例，保证单测覆盖度，降低测试成本。</li></ul></li><li>联调和沟通效率<ul><li>重大项目和长耗时，需要考虑拉站会或者小黑屋。</li><li>能群聊的不要私聊，扩大内容的知晓范围。</li><li>并行工作需要分时间块，避免碎片化时间并行。</li><li>遇到人力合作问题，需要及时升级到 leader 支持。</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;基于多次复盘的经验汇总，仅以当前工作环境做汇总，供参考。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;系统问题定位和解决&lt;ul&gt;
&lt;li&gt;需要抓住足够多的证据链，不能臆测代码和运行机制。常用手段有 curl，日志，sentry。&lt;/li&gt;
&lt;li&gt;能在本地复现不要跑到联调，降低定位成本。&lt;/</summary>
      
    
    
    
    
    <category term="软技能" scheme="https://noogel.xyz/tags/%E8%BD%AF%E6%8A%80%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>技术面试的一点经验</title>
    <link href="https://noogel.xyz/2022/03/05/1.html"/>
    <id>https://noogel.xyz/2022/03/05/1.html</id>
    <published>2022-03-05T00:00:00.000Z</published>
    <updated>2025-07-23T07:30:58.918Z</updated>
    
    <content type="html"><![CDATA[<h2 id="技术面试看什么"><a href="#技术面试看什么" class="headerlink" title="技术面试看什么"></a>技术面试看什么</h2><ol><li>流畅的表达能力和清晰的逻辑分析能力。</li><li>比较扎实的基础知识和技术学习热情。</li><li>问题发现和推动解决问题的能力。</li><li>丰富的项目经验积累和架构规划能力。</li></ol><h2 id="优秀候选人的一些品质"><a href="#优秀候选人的一些品质" class="headerlink" title="优秀候选人的一些品质"></a>优秀候选人的一些品质</h2><ol><li>对于所了解的技术知识理解的很透彻，从语言描述上能够表达准确、有逻辑、有调理。<ul><li>表达中不会有『这个』『那个』『嗯』『啊』的语气词和停顿。</li><li>对于项目问题的解答，主动阐述项目背景，问题现状，做了什么，产生什么样的收益。</li><li>优先说出答案的关键 123，再展开举例说明，是一种清晰有效的表达方式。</li></ul></li><li>从技术底层知识上，对于一些相对关键的技术知识能够灵活掌握，能从技术前世今生很顺畅的表达出来。</li><li>实践能力上，候选人对于理论的了解不仅停留在书面上，而是动手实现一个技术理论。</li></ol><h2 id="技术面试怎么做"><a href="#技术面试怎么做" class="headerlink" title="技术面试怎么做"></a>技术面试怎么做</h2><p>从工作经验来分，以三年为界，分为两类面试思路：</p><ol><li>越是经验丰富的候选人，可以提出一个比较模糊的问题，尽量让候选人来主导拆解这个过程。同时也要避免跑题浪费时间。</li><li>对于经验很少的候选人，则可以从基础性知识和具体的问题上展开，如果难度过高需要积极的给出提示和引导。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;技术面试看什么&quot;&gt;&lt;a href=&quot;#技术面试看什么&quot; class=&quot;headerlink&quot; title=&quot;技术面试看什么&quot;&gt;&lt;/a&gt;技术面试看什么&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;流畅的表达能力和清晰的逻辑分析能力。&lt;/li&gt;
&lt;li&gt;比较扎实的基础知识和技术学习热情</summary>
      
    
    
    
    
    <category term="招聘" scheme="https://noogel.xyz/tags/%E6%8B%9B%E8%81%98/"/>
    
  </entry>
  
  <entry>
    <title>macOS 系统 10 倍高效工具</title>
    <link href="https://noogel.xyz/2022/01/23/1.html"/>
    <id>https://noogel.xyz/2022/01/23/1.html</id>
    <published>2022-01-23T00:00:00.000Z</published>
    <updated>2025-07-23T07:30:58.915Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天要说的是 macOS 下的一款效率软件 —— Alfred，想必大家就算没用过也耳闻过，老实说用好它带来的效率提升绝对不止 10 倍。博主已经安利给很多同事使用，他们普遍觉得上手有些困难，主要是配置复杂，今天的文章会一步步地介绍这款神器的高效之处。</p><p>有的人可能会说系统自带的 Spotlight 就很好用，确实是这样。在之前我会用 Spotlight 搜应用、文件、进行计算等，而 Alfred 的功能更强大，是一款可以更加 All in 的效率工具，里面还有我最常用的剪贴板历史、快速网页搜索、谷歌二次口令扩展等功能，接下来我会逐一介绍。</p><span id="more"></span><h2 id="获取方式"><a href="#获取方式" class="headerlink" title="获取方式"></a>获取方式</h2><ol><li>从 Alfred 官网中下载并安装使用即可。<ul><li>免费用户只能使用其 Features 中的功能；若要使用 Workflows，则需要购买 Powerpack 才能激活此功能。</li></ul></li><li>若要试用 Workflows，可以自行搜索破解版，不过还是建议购买正版。</li></ol><h2 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h2><p>先说一说如何调出命令面板，在 General 中配置的 Alfred Hotkey 就是使用快捷键。如下图我配置的是 Command + Space。</p><p><img src="/resource/img/af03e406816350333a1b09b467b089b3.png" alt="af03e406816350333a1b09b467b089b3.png"></p><p>调出的样子是下面这样的，在框中输入内容即可，输入内容后就会展示响应结果，选中后回车执行对应的操作。执行的操作一般是打开浏览器网址，或者将结果复制到剪贴板。</p><p><img src="/resource/img/05af8ea7a69242ebf855f05649affc74.png" alt="05af8ea7a69242ebf855f05649affc74.png"></p><p><img src="/resource/img/d3bed623187b74071557d9f145306589.png" alt="d3bed623187b74071557d9f145306589.png"></p><p>然后说一说最常用的几个功能</p><h3 id="剪贴板历史"><a href="#剪贴板历史" class="headerlink" title="剪贴板历史"></a>剪贴板历史</h3><p>在 Windows 上对应的是 Ditto，macOS 上也试过几个都不太好用。Alfred 自带这个还能搜索内容，可以自定义保存时间和查看快捷键，选中回车就能保存到剪贴板。如下图我配置 Option + Command + C 是调出历史面板。</p><p><strong>配置面板</strong></p><p><img src="/resource/img/0e5d409dabc29977e3b422883ff6a6b1.png" alt="0e5d409dabc29977e3b422883ff6a6b1.png"></p><p><strong>查看历史面板</strong></p><p><img src="/resource/img/c84b02b4a70d2cac50d33b48862ae1cc.png" alt="c84b02b4a70d2cac50d33b48862ae1cc.png"></p><p><strong>搜索功能</strong></p><p><img src="/resource/img/1a11065ff2160c3e142b512046634954.png" alt="1a11065ff2160c3e142b512046634954.png"></p><p>主要有两个使用场景，一个是在需要多次复制粘贴的场景下，可以一次性复制完，再到新页面按顺序选择性粘贴。另一个是快速搜索某天复制过的片段。</p><h3 id="文件搜索"><a href="#文件搜索" class="headerlink" title="文件搜索"></a>文件搜索</h3><p>输入 find 命令和文件名就能找到，回车会自动在 Finder 中打开所在目录。</p><p><img src="/resource/img/bdd58b4ad92a9ce1d59b3960ac5365a2.png" alt="bdd58b4ad92a9ce1d59b3960ac5365a2.png"></p><h3 id="快速网页搜索"><a href="#快速网页搜索" class="headerlink" title="快速网页搜索"></a>快速网页搜索</h3><p>快速搜索网页的输入结构是『关键字 搜索内容』，关键字就是下图中的 Keyword，然后空格再输入搜索内容。</p><p><img src="/resource/img/5ae9d5343fac84059689056428abcf23.png" alt="5ae9d5343fac84059689056428abcf23.png"></p><p>关键字是可以自定义配置的，只要有有规律的页面就能进行配置。比如我下面的配置是在谷歌搜索时过滤某网站内容。其中的『{query}』是被替换的搜索内容，『gog』是搜索指令。</p><p><img src="/resource/img/7ae07b25b70d57e481aee104e52aa45a.png" alt="7ae07b25b70d57e481aee104e52aa45a.png"></p><p>以下两张图描述了如下两个动作，一个是输入搜索指令，另一个是回车操作后的浏览器页面。</p><p><img src="/resource/img/83877ebbbea93acc0dd1ef96e906bdad.png" alt="83877ebbbea93acc0dd1ef96e906bdad.png"></p><p><img src="/resource/img/941cc4312f9f716b0adf78284457d777.png" alt="941cc4312f9f716b0adf78284457d777.png"></p><p>再比如我要配置自动搜索知乎，我会先去看下知乎搜索页面的结构，如下图。</p><p><img src="/resource/img/5de42ea85a16e3782c97cbaaea99f3f9.png" alt="5de42ea85a16e3782c97cbaaea99f3f9.png"></p><p>网址是：<a href="https://www.zhihu.com/search?type=content&q=%E9%85%8D%E7%BD%AE">https://www.zhihu.com/search?type=content&amp;q=%E9%85%8D%E7%BD%AE</a></p><p>于是在 Alfred 上就可以进行如下配置。</p><p><img src="/resource/img/52c5cd1a8c7ffacb14ff342b074bacf1.png" alt="52c5cd1a8c7ffacb14ff342b074bacf1.png"></p><p><img src="/resource/img/81fa4415d6583b5fa4abdf4b8dd3cf40.png" alt="81fa4415d6583b5fa4abdf4b8dd3cf40.png"></p><p>一般公司内部网址的规律性会更强一些，于是可以做很多的快捷操作。比如快速打开某个内部网址、在 Gitlab 快速发起 Merge Request 申请、快速打开联调环境、快速在 Sentry 搜索内容等。</p><p>附上一些常用自定义配置：</p><ul><li>百度：<a href="https://www.baidu.com/s?ie=utf-8&f=8&wd=%7Bquery%7D">https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;wd={query}</a></li><li>简书：<a href="http://www.jianshu.com/search?utf8=%E2%9C%93&q=%7Bquery%7D">http://www.jianshu.com/search?utf8=%E2%9C%93&amp;q={query}</a></li><li>淘宝：<a href="http://s.taobao.com/search?oe=utf-8&f=8&q=%7Bquery%7D">http://s.taobao.com/search?oe=utf-8&amp;f=8&amp;q={query}</a></li><li>京东：<a href="https://search.jd.com/Search?keyword=%7Bquery%7D&enc=utf-8&wq=%7Bquery%7D">https://search.jd.com/Search?keyword={query}&amp;enc=utf-8&amp;wq={query}</a></li><li>微信文章：<a href="http://weixin.sogou.com/weixin?type=2&query=%7Bquery%7D">http://weixin.sogou.com/weixin?type=2&amp;query={query}</a></li><li>stackoverflow：<a href="http://www.stackoverflow.com/search?q=%7Bquery%7D">http://www.stackoverflow.com/search?q={query}</a></li><li>github：<a href="https://github.com/search?utf8=%E2%9C%93&q=%7Bquery%7D">https://github.com/search?utf8=%E2%9C%93&amp;q={query}</a></li><li>maven：<a href="http://mvnrepository.com/search?q=%7Bquery%7D">http://mvnrepository.com/search?q={query}</a></li><li>Android API Search：<a href="https://developer.android.com/reference/classes.html#q={query}">https://developer.android.com/reference/classes.html#q={query}</a></li></ul><h3 id="快速打开控制台并执行命令"><a href="#快速打开控制台并执行命令" class="headerlink" title="快速打开控制台并执行命令"></a>快速打开控制台并执行命令</h3><p>这个功能用的不多，但也要提一下，默认会打开系统自带终端并执行，我这里的配置是结合 iTerm 启动执行。</p><p><img src="/resource/img/16d37919cb0f223f17c5f28f04bef7e4.png" alt="16d37919cb0f223f17c5f28f04bef7e4.png"></p><p><img src="/resource/img/2b6629322b5e75acc0262d839153f2bf.png" alt="2b6629322b5e75acc0262d839153f2bf.png"></p><p><img src="/resource/img/349dbf7f2c01c7dcd2812eddb390253a.png" alt="349dbf7f2c01c7dcd2812eddb390253a.png"></p><h2 id="Workflow-功能"><a href="#Workflow-功能" class="headerlink" title="Workflow 功能"></a>Workflow 功能</h2><p>Workflow 才是这款软件的灵魂所在，可以通过开发插件的形式扩展软件功能。</p><p><img src="/resource/img/905d051ae874c534cc012976e6e1c9fb.png" alt="905d051ae874c534cc012976e6e1c9fb.png"></p><p>我举三个最常用的扩展吧。</p><h3 id="谷歌身份验证器"><a href="#谷歌身份验证器" class="headerlink" title="谷歌身份验证器"></a>谷歌身份验证器</h3><p>谷歌身份验证器是在做某些危险操作时进行二次确认的一个机制，在第一次初始化时根据账户绑定一个 key，然后每次使用都需要根据当前时间算出一个数字输入，来增强安全性保障，这个原理跟游戏的令牌是一样的。有了这个插件我就可以只输入一个 ok 关键字就可以获得验证口令，回车粘贴，只需要 2 秒。</p><p><img src="/resource/img/0a2def0cd3bb614fa892914a1e0981d1.png" alt="0a2def0cd3bb614fa892914a1e0981d1.png"></p><p>与此同时，而别人的操作流程是</p><ol><li>掏出手机解锁。</li><li>找到 Authy App 打开。</li><li>看到数字口令，手动输入。</li><li>输入超时，口令换新，重新输入。</li></ol><p>以上四步的操作时间平均在 20 秒以上，除非手机时刻在 Authy 界面。</p><h3 id="知一的开发者工具箱"><a href="#知一的开发者工具箱" class="headerlink" title="知一的开发者工具箱"></a>知一的开发者工具箱</h3><p>这个是博主自己开发的一个扩展，目前已在 Github 开源，<a href="https://github.com/noogel/Alfred-Workflow%EF%BC%8C%E6%AC%A2%E8%BF%8E">https://github.com/noogel/Alfred-Workflow，欢迎</a> Star、Fork、提 Feature ~</p><p><img src="/resource/img/ac4d4f5f5eab15f3dc137eda02f87a0c.png" alt="ac4d4f5f5eab15f3dc137eda02f87a0c.png"></p><p>具体的使用教程欢迎查看 <a href="https://github.com/noogel/Alfred-Workflow">https://github.com/noogel/Alfred-Workflow</a></p><p>初衷就是提高平时的开发效率，将一些常用的重复性操作给命令化，以此来节省时间。比如我最常用的 ntm 命令，可以获取当前时间戳或者标准时间，也可以将标准时间和时间戳互转。整个操作 2 秒完成。</p><p><img src="/resource/img/3eb5b84115ef3b516235fcf24d08bb80.png" alt="3eb5b84115ef3b516235fcf24d08bb80.png"></p><p><img src="/resource/img/39dd4230a2e908df5fcbeda8d4f3ced0.png" alt="39dd4230a2e908df5fcbeda8d4f3ced0.png"></p><p><img src="/resource/img/b759437ca8aa0bf4dc3c7de8185314ee.png" alt="b759437ca8aa0bf4dc3c7de8185314ee.png"></p><p><img src="/resource/img/c187b55ba8adc49510bf20602204a16e.png" alt="c187b55ba8adc49510bf20602204a16e.png"></p><p>而别人的操作则分为以下几步。</p><ol><li>打开浏览器搜索时间戳转换工具。</li><li>打开工具网页，等待加载完成。</li><li>输入时间戳或标准时间，点击转换。</li></ol><p>工具箱中的内容不仅这个，还有很多实用的工具，可以大大的提高效率。</p><h3 id="有道翻译"><a href="#有道翻译" class="headerlink" title="有道翻译"></a>有道翻译</h3><p><img src="/resource/img/44e3dbddb40c6a9b22c7055aee8cd824.png" alt="44e3dbddb40c6a9b22c7055aee8cd824.png"></p><p>最后一个常用的插件是有道翻译扩展，输入关键字 yd 就能自动转换中英文。</p><p><img src="/resource/img/7de0e80bbf5d7c0afc5c24d2b6950bd3.png" alt="7de0e80bbf5d7c0afc5c24d2b6950bd3.png"></p><p><img src="/resource/img/316837aeaf66c7918aa9a0391fbd0f73.png" alt="316837aeaf66c7918aa9a0391fbd0f73.png"></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>平时工作的使用频率还是蛮高的，节省下来的时间可以做更多的事情。</p><p><img src="/resource/img/4d0d461ba444ad426fbef97de168b5f4.png" alt="4d0d461ba444ad426fbef97de168b5f4.png"></p><p>Alfred 的功能不止于此，在其官网有更详尽的描述，感兴趣的可以试用一下，有什么问题也可以咨询我。<strong>我是知一，如果这篇文章对你有益，欢迎一键三连~</strong></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;今天要说的是 macOS 下的一款效率软件 —— Alfred，想必大家就算没用过也耳闻过，老实说用好它带来的效率提升绝对不止 10 倍。博主已经安利给很多同事使用，他们普遍觉得上手有些困难，主要是配置复杂，今天的文章会一步步地介绍这款神器的高效之处。&lt;/p&gt;
&lt;p&gt;有的人可能会说系统自带的 Spotlight 就很好用，确实是这样。在之前我会用 Spotlight 搜应用、文件、进行计算等，而 Alfred 的功能更强大，是一款可以更加 All in 的效率工具，里面还有我最常用的剪贴板历史、快速网页搜索、谷歌二次口令扩展等功能，接下来我会逐一介绍。&lt;/p&gt;</summary>
    
    
    
    
    <category term="效率" scheme="https://noogel.xyz/tags/%E6%95%88%E7%8E%87/"/>
    
  </entry>
  
  <entry>
    <title>知一的 2021 已读书单</title>
    <link href="https://noogel.xyz/2022/01/21/1.html"/>
    <id>https://noogel.xyz/2022/01/21/1.html</id>
    <published>2022-01-21T00:00:00.000Z</published>
    <updated>2025-07-23T07:30:58.919Z</updated>
    
    <content type="html"><![CDATA[<p>2021年已经过去，准备对去年看过的书进行一个复盘，回忆下从中得到了什么成长。</p><span id="more"></span><h2 id="文化随笔"><a href="#文化随笔" class="headerlink" title="文化随笔"></a>文化随笔</h2><p><img src="/resource/img/2022-01-21-23-33-32.png"></p><p>首先是同事推荐的一本书 ——《书读完了》，由金克木先生所著，豆瓣评分 8.6 ，还是蛮高的。如今书籍浩如烟海，怎么可能读完？其实先生之所谓读完，我主要记住了以下两个观点。<br>一是说书也有层级，有些书是最基础的书，如《诗经》、《春秋》这些表达中国最底层文化思想的书籍，而其他书则是基于这些书发展而来的，所以要读就读经典。读懂经典，那么后继的书不读也自然懂了大半。中国古书不过是那几十种，是读得完的。<br>二是说经典虽难读懂，但也不要贪图潮流而追逐当下。古人说『读书得间』，读出字里行间的微言大义，于无字处看出字来。看字读句，要看出问题，若能『望气』而知书的『格局』，会看书的『相』，那就可以有『略览群书』的本领，不必一字一句的读，而做到『博览群书』。很可惜在碎片化的时间里很难有如此深度的思考。</p><p><img src="/resource/img/2022-01-21-23-33-40.png"></p><p>第二本说一下《金字塔原理》，这本书主要讲逻辑思维与表达呈现。首先作者讲的是金字塔的基本结构：中心思想明确，结论先行，以上统下，归类分组，逻辑递进。先重要后次要，先全局后细节，先结论后原因，先结果后过程。然后围绕金字塔原理通过一个个案例来讲具体的做法：自上而下表达，自下而上思考，纵向疑问回答／总结概括，横向归类分组／演绎归纳，序言讲故事，标题提炼思想精华。读这本书是因为校友群有人在看，刚好能解决我写博客困难的问题，于是就找来看了看，没有读完，不过写文章的思路总归是有了。</p><p><img src="/resource/img/2022-01-21-23-33-52.png"></p><p>第三本便是《空谷幽兰》，作者比尔·波特是著名的汉学家，在台湾当过两年沙弥，对中国传统文化有着很大的兴趣。这本书主要是讲他在八零年代实地寻访中国隐士的过程，讲述了中国传统隐士在终南山一带的隐居生活，探寻他们为何要离开城市或人群，到幽静之处筑居，有的人五十年不下山，有的人活了近百岁。又讲述了中国传统道与佛的异同。书中描述的意境我只能摘录摘录几句给大家看看：</p><blockquote><p>有个叫宝胜的和尚讲：“真修行的人太少了。至于我自己，我不怎么修行。我晚上打坐，白天干杂活儿。我只是在照管这座庙。”这是得道之人所说的话。<br>陈世杰道长这样谈修道：“当人们努力去寻找道的时候，他们就失去了道。他们混淆了有和无，我们所能做的一切只是修德（美德，精神力量），德包括我们的精神、我们的心、我们的想法。真正的德导致真正的道。但是大多数人修的不是真正的德。他们修炼的是神通和心念，于是我们以为他们得道了。但是他们错了。修习真正的德不是要去掉所有的神通和念头，像一个婴儿一样，无看而看，无听而听，无知而知。首先你要修德，道自然就来了。”这是我听过最好也最透彻的对修道的说法。</p></blockquote><h2 id="伟人传记"><a href="#伟人传记" class="headerlink" title="伟人传记"></a>伟人传记</h2><p><img src="/resource/img/2022-01-21-23-34-00.png"></p><p>《毛泽东传》这部伟人传记还没读完，不过非常值得推荐，可以结合《毛泽东选集》一起读，会有很多收获。</p><h2 id="技术加成"><a href="#技术加成" class="headerlink" title="技术加成"></a>技术加成</h2><p>然后要说的是关于技术类的，整个一年读的都是关于架构和领域驱动设计的书，都很不错。</p><p><img src="/resource/img/2022-01-21-23-34-07.png"></p><p>《架构整洁之道》主要讲了整洁架构的设计目标，系统地剖析其缘起、内涵及应用场景，涵盖软件研发的完整过程及所有核心架构模式。绝对是架构书类中的必读经典。</p><p><img src="/resource/img/2022-01-21-23-34-15.png"></p><p>《软件架构设计》围绕软件架构设计，系统化地梳理技术架构与业务架构的方法论与实践。这本书不仅讲了业务层面的内容，也讲清了很多技术深度上的知识和一些底层的技术思想。</p><p><img src="/resource/img/2022-01-21-23-34-22.png"></p><p>《实现领域驱动设计》这本书出了很多年了，算是领域驱动设计里的经典，但是奈何翻译太差劲，不建议作为入门书来读。系统性读书的话建议先看看国人写的，再结合思特沃克公司写的文章理解。</p><p><img src="/resource/img/2022-01-21-23-34-29.png"></p><p>《复杂软件设计之道》这本国人写的书，前半部分写的还可以，解决了我一些疑问，后半部分就读不进去了。</p><p>关于领域驱动设计总结了一篇文章《万字长文谈谈领域驱动设计》</p><p><img src="/resource/img/2022-01-21-23-34-37.png"></p><p>《垃圾回收的算法与实现》这本书写 GC 还是不错，重点在于算法和不同语言的实现，我也是读了个大概。</p><h2 id="旅游攻略"><a href="#旅游攻略" class="headerlink" title="旅游攻略"></a>旅游攻略</h2><p><img src="/resource/img/2022-01-21-23-34-44.png"></p><p>然后说两本旅游攻略的书，《西藏不止旅行》、《慢拍西藏》，因为 2021 年十一计划去西藏玩，所以提前看了两本书给自己种种草。写了一篇关于西藏的文章《云之彼端·生活的另一种打开方式》</p><p><img src="/resource/img/2022-01-21-23-34-50.png"></p><h2 id="科普和健身"><a href="#科普和健身" class="headerlink" title="科普和健身"></a>科普和健身</h2><p>接下来就是四本关于科普和健身的书了。</p><p><img src="/resource/img/2022-01-21-23-34-57.png"></p><p>《复杂》一书作者梅拉妮·米歇尔是计算机科学教授，她在书中讲述了复杂与复杂系统的关系，给复杂系统一个基本的定义。讲述了各个领域的复杂系统以及度量系统复杂度的方法。读书收获则是加深了对于复杂系统的认知，结合领域驱动设计了解了拆解系统、管理系统复杂度的方法。豆瓣评分 9.0 ，非常值得一读。</p><p><img src="/resource/img/2022-01-21-23-35-03.png"></p><p>《现实不似你所见》深入浅出地讲述了物理学的前世今生，虽然作者已经讲得比较简单了，很少用公式来表达，但我只看懂了只言片语。没想到的是在经典力学之后，又经过了相对论和量子力学，直至现在的量子引力，科学家们竟然进行了这么多的探索。在量子引力的世界，时间、空间、场、粒子都不存在，它们被极度简化为协变量子场的表现形式，感兴趣的读者可以看一看。</p><p><img src="/resource/img/2022-01-21-23-35-10.png"></p><p>《运动改造大脑》这本书最初来源于樊登听书对我产生的影响，作者主要讲了适度复杂运动对于大脑的正向影响。</p><blockquote><p>透过美国高中的体育改革计划、真实的案例与亲身经历、上百项科学研究证实，运动不只能健身、锻炼肌肉，还能锻炼大脑，改造心智与智商，让你更聪明、更快乐、更幸福！运动能刺激脑干，提供能量、热情和动机，还能调节脑内神经递质，改变既定的自我概念，稳定情绪，增进学习力。</p></blockquote><p><img src="/resource/img/2022-01-21-23-35-18.png"></p><p>《这里是中国 2》这本书讲述了中国在建筑和经济方面的一些成就，不如前两年看的同系列的第一本书有意思。两本都值得看看。</p><h2 id="小说类"><a href="#小说类" class="headerlink" title="小说类"></a>小说类</h2><p><img src="/resource/img/2022-01-21-23-35-24.png"></p><p>小说类基本是听，刘慈欣在《三体》之后变得几乎家喻户晓，他写的其他作品同样很好，比如我听的《球状闪电》，当我在听了《神们自己》之后，发现阿西莫夫是西方的刘慈欣，不过他是比刘慈欣要早的，两者的风格很像，鸿篇巨著，构建一个史诗级世界。读完刘慈欣建议看看阿西莫夫合集。</p><p><img src="/resource/img/2022-01-21-23-35-33.png"></p><p>再有一篇是网络小说《13 路末班车》，这篇网文不同于其他的，特点是足够恐怖但又不吓人，主角不是脑残有一定智商，剧情连贯不拖拉。当然也有缺点是有些环节逻辑不缜密，人物动机牵强。</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>最后附上书名-作者-豆瓣评分-京东分类</p><p>《书读完了》 - 金克木 - 8.6 - 文化随笔<br>《金字塔原理》 - 芭芭拉·明托 - 8.1 - 管理经典<br>《空谷幽兰》 - 比尔波特 - 8.3 - 文化随笔<br>《架构整洁之道》 - 罗伯特 C·马丁 - 8.7 - 软件工程及软件方法学<br>《软件架构设计》 - 余春龙 - 8.7 - 软件工程及软件方法学<br>《实现领域驱动设计》 - 沃恩·弗农 - 8.4 - 软件工程及软件方法学<br>《复杂软件设计之道》 - 邱晨阳 - 7.6 - 软件工程及软件方法学<br>《垃圾回收的算法与实现》 - 中村成洋 相川光 - 8.2 - 编程语言与程序设计<br>《西藏不止旅行》 - 周硚 - 7.2 - 旅游攻略<br>《慢拍西藏》 - 赵利山 - 7.5 - 旅游攻略<br>《毛泽东传》 - 中共中央文献研究室 - x - 传记<br>《复杂》 - 梅拉妮·米歇尔 - 9.0 - 科普读物<br>《这里是中国 2》 - 星球研究所 - 8.3 - 科普读物<br>《现实不似你所见》 - 卡洛·罗韦利 - 9.2 科普读物<br>《运动改造大脑》 - 约翰·瑞迪 - 7.5 - 运动健身<br>《球状闪电》 - 刘慈欣 - 9.0 - 科幻小说<br>《神们自己》 - 阿西莫夫 - 8.4 - 科幻小说<br>《13 路末班车》 - 老八零 2 - 网络小说</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;2021年已经过去，准备对去年看过的书进行一个复盘，回忆下从中得到了什么成长。&lt;/p&gt;</summary>
    
    
    
    
    <category term="书单" scheme="https://noogel.xyz/tags/%E4%B9%A6%E5%8D%95/"/>
    
  </entry>
  
  <entry>
    <title>领域驱动设计精粹（下）</title>
    <link href="https://noogel.xyz/2021/12/07/1.html"/>
    <id>https://noogel.xyz/2021/12/07/1.html</id>
    <published>2021-12-07T00:00:00.000Z</published>
    <updated>2025-07-23T07:30:58.918Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/resource/img/2021-12-10-00-27-51.png"></p><h2 id="谈谈领域驱动设计的落地"><a href="#谈谈领域驱动设计的落地" class="headerlink" title="谈谈领域驱动设计的落地"></a>谈谈领域驱动设计的落地</h2><p>前文提到了事件风暴产出的领域模型是概念模型，到实际落地还有些距离，而落地的结果也是各不相同，我觉得说落地，要先回顾一下领域驱动设计的两个作用。</p><ol><li>通过战略设计拆分子域，指导微服务拆分。</li><li>通过事件风暴建立领域概念模型，指导代码设计。</li></ol><p>也就是说领域驱动设计产出的结果是指导性的，并不是一个直接可落地的结果。落地的方案则是要通过架构设计和框架选择上来进行。架构是为了控制软件复杂性而做，就好像『一千个读者心中有一千个哈姆雷特』，不同人做架构不尽相同。下面说说我的落地方式。</p><span id="more"></span><h3 id="架构演进"><a href="#架构演进" class="headerlink" title="架构演进"></a>架构演进</h3><p>我们最初接触和使用的分层架构是三层的，三层架构解决了程序内部代码调用复杂和职责不清的问题，在 DDD 分层架构中的关于对象和服务被重新归类到不同分层中，确定了层与层之间的职责边界。DDD 提出了四层架构，其中最主要的变化是提出领域层的概念，需要领域专家对于业务知识的精准把握之上，根据领域设计方法建立领域模型，把变动较少的领域模型放入领域层，而多变的业务场景代码放入应用层。如下图对应三层到四层的演进过程。</p><p><img src="/resource/img/2022-01-19-00-07-38.png"></p><p>分层架构的一个重要原则是每层只能与位于其下方的层发生耦合，可以简单分为以下两种：</p><ul><li>严格分层架构，某层只能与位于其直接下方的层发生耦合。</li><li>松散分层架构，允许某层与它的任意下方层发生耦合。</li></ul><p>这两种分层架构的耦合方式是各有利弊，在网络上对于他们也是各有各的见解。结合实际情况在开发中，更倾向于采用松散分层架构，但是要禁止用户接口层直接访问基础设施层，防止一些潜在的安全问题。</p><p><img src="/resource/img/2022-01-19-00-07-56.png"></p><h3 id="子域划分"><a href="#子域划分" class="headerlink" title="子域划分"></a>子域划分</h3><p>基于现有三层架构，在其中增加 domain 包的形式增加领域服务层。不同的子域通过包来划分如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">package noogel.xyz.domain.deal;  // 交易子域</span><br><span class="line">package noogel.xyz.domain.quote;  // 算价子域</span><br><span class="line">package noogel.xyz.domain.promotion;  // 促销子域</span><br></pre></td></tr></table></figure><p>同一个领域服务下面再按照领域对象、领域服务、领域资源库、防腐层等方式组织。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">package noogel.xyz.domain.xxx.repository;  // 资源库接口定义</span><br><span class="line">package noogel.xyz.domain.xxx.entity;  // 领域对象</span><br><span class="line">package noogel.xyz.domain.xxx.facade;  // 防腐层</span><br><span class="line">package noogel.xyz.domain.xxx.service;  // 领域服务</span><br></pre></td></tr></table></figure><h3 id="领域对象"><a href="#领域对象" class="headerlink" title="领域对象"></a>领域对象</h3><p>领域驱动解决的一个问题就是对象的贫血问题。通过如下促销领域对象来说明，对于当前购买商品组合能否满足购买规则的检查逻辑不是放在服务层或者工具类中，而是由领域对象提供方法支持。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@Getter</span><br><span class="line">@ToString</span><br><span class="line">@...</span><br><span class="line">public class PromotionDo &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 业务幂等</span><br><span class="line">     */</span><br><span class="line">    private String bizNo;</span><br><span class="line">  // 省略字段...</span><br><span class="line">    private Long beginTime;</span><br><span class="line">    private Long endTime;</span><br><span class="line">    private String desc;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 计算生效数据</span><br><span class="line">     * @param items</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public List&lt;PromotionDo&gt; calculateValid(List&lt;ItemDo&gt; items) &#123;</span><br><span class="line">        switch (rule.getKind()) &#123;</span><br><span class="line">            // ...</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;PromotionDo&gt; promoDataList = new ArrayList&lt;&gt;();</span><br><span class="line">        // do sth ...</span><br><span class="line">        return promoDataList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="资源库（依赖倒置）"><a href="#资源库（依赖倒置）" class="headerlink" title="资源库（依赖倒置）"></a>资源库（依赖倒置）</h3><p>资源库对外的整体访问由 Repository 提供，它聚合了各个资源库的数据信息，同时也承担了资源存储的逻辑。我们将资源库的接口定义放在领域层，而具体实现放在基础设施层。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">package noogel.xyz.domain.xxx.repository;  // 资源库接口定义</span><br><span class="line">package noogel.xyz.infrastructure.repository;  // 资源库实现</span><br><span class="line">package noogel.xyz.infrastructure.rpc;  // RPC 服务</span><br><span class="line">package noogel.xyz.infrastructure.dao;  // 数据库访问对象</span><br></pre></td></tr></table></figure><p>资源库接口定义，提供必要的入参，并且以领域对象的形式作为结果返回。至于组织返回的领域对象，交由具体实现类来实现，可以通过调用数据库、缓存系统、RPC 接口等形式来组织生成领域对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public interface PromotionRepository &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 保存 xx</span><br><span class="line">     * @param data 领域对象</span><br><span class="line">     * @return 唯一 key</span><br><span class="line">     */</span><br><span class="line">    String create(PromotionDo data);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 批量更新状态</span><br><span class="line">     * @param key</span><br><span class="line">     * @param state</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    boolean batchUpdateState(List&lt;String&gt; key, PromoState state);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 批量查询</span><br><span class="line">     * @param promoIds</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    Map&lt;String, PromotionDo&gt; batchGetOnlineById(List&lt;Long&gt; ids);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="防腐层"><a href="#防腐层" class="headerlink" title="防腐层"></a>防腐层</h3><p>用来消除外部上下文结构差异的作用，也叫适配层。比如在算价上下文中需要调用促销上下文数据，不同的促销数据源提供了不同的接口和数据，这时就需要引入防腐层来屏蔽差异，防止外部上下文侵入领域内部影响代码模型。首先定义需要的数据接口规范。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public interface PromotionFacade &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 计算促销数据</span><br><span class="line">     *</span><br><span class="line">     * @param ctx</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    List&lt;PromotionData&gt; calculatePromotion(PromotionContext ctx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类来用处理外部数据的差异，按照接口要求封装数据，简化模型的复杂性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Promotion1Facade implements PromotionFacade &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;PromotionData&gt; calculatePromotion(PromotionContext ctx) &#123;</span><br><span class="line">        PromotionData promoData = PromotionData.of(...);</span><br><span class="line">        return Collections.singletonList(promoData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Promotion2Facade implements PromotionFacade &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RpcService rpcService;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;PromotionData&gt; calculatePromotion(PromotionContext ctx) &#123;</span><br><span class="line">        PromotionData data = new PromotionData();</span><br><span class="line">        // do sth ...</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="上下文集成"><a href="#上下文集成" class="headerlink" title="上下文集成"></a>上下文集成</h3><p>对于上下文集成的手段可以通过 RPC 服务、HTTP 服务、MQ 消息订阅。</p><h3 id="领域服务"><a href="#领域服务" class="headerlink" title="领域服务"></a>领域服务</h3><p>上面我们讲述了各个要素对于资源和行为的封装，业务逻辑的实现代码应该尽量放在聚合根边界内。但是总会遇到不适合放在聚合根上的业务逻辑，而此时领域服务就需要承载编排组合领域对象、资源库和防腐接口等一系列要素，提供对其它上下文的交互接口。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public interface PromotionService &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 创建促销</span><br><span class="line">     *</span><br><span class="line">     * @param item</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    String createPromotion(CreatePromotionDto item);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 批量更新状态</span><br><span class="line">     *</span><br><span class="line">     * @param req</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    boolean batchUpdatePromotion(BatchUpdatePromotionReqDto req);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 计算有效的促销</span><br><span class="line">     *</span><br><span class="line">     * @param req</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    List&lt;PromoResultDto&gt; calculateValidPromotion(CalculateValidPromotionReqDto req);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="落地延伸"><a href="#落地延伸" class="headerlink" title="落地延伸"></a>落地延伸</h3><p>DDD 的设计概念很多，学习成本比较高，于是我们组织了《实现领域驱动设计》的读书分享会，通过共读分享交流理解的方式，让大家对于 DDD 的设计方法和概念有了比较统一的认知。同时发现在做设计分享时，组内的认知比较一致，而对外的理解成本则会比较高。</p><p>不论我们怎样称呼应用层和领域层，但是四层架构的优势已经显而易见，对于电商交易这样一类相对复杂的系统而言。DDD 教会我们怎么拆分领域，如何沉淀领域模型，而如何组织领域服务提供业务功能上是匮乏的，下面是基于系统问题和业界资料总结的一个抽象框架，描述的是如何组合核心能力与业务场景，并提供一个配置化的灵活系统。</p><p><strong>能力单元</strong></p><p>提供基础能力的独立单元，只单纯依赖下游数据提供能力，职责比较单一，对应领域驱动设计的领域服务。</p><p><strong>场景单元</strong></p><p>通过编排不同能力单元，形成一个预定义的执行流程，叫做场景单元。场景单元有以下关键要素：</p><ol><li>执行节点：执行节点负责转换出入参并调用能力单元或场景单元，返回结果给下一个节点。</li><li>条件控制：根据执行节点结果进行简单逻辑判断选择不同的执行路径。</li><li>干预策略：干预策略是场景的扩展点，通过预留的扩展点可以干预执行流程。</li></ol><p>所以一个场景单元的实际处理通路由条件控制和干预策略决定。</p><p><strong>策略配置服务</strong></p><ol><li>提供静态或动态的策略配置给场景单元使用。</li><li>基于节点维度的简单风控策略支持，比如限流、熔断等。</li></ol><p><strong>框架图</strong></p><p><img src="/resource/img/2022-01-19-00-08-33.png"></p><p><strong>核心能力</strong>封装数据和行为，职责要单一且通用，对外提供完善的接口供场景调用，核心能力内部是高内聚的，能力外不能与其它能力模块发生直接耦合，只能通过场景进行间接耦合，要保证核心能力的职责单一性。</p><p><strong>能力模型</strong>是指对于复杂场景进行归类和抽象得出的一个模型，可以用来解决某一类通用问题。能力模型既可以是由订单系统内部提供的，也可能是由外部系统通过 RPC 形式提供的一整套能力接口包装而得。</p><p><strong>内部事件</strong>，由于能力之间不允许直接耦合，所以内部事件不允许在能力模块内部发送，只能由场景中进行控制发送，并且能力内部不允许直接监听，而应该把监听事件作为场景的一种入口，实现场景之间的依赖调用。</p><p><strong>场景单元</strong>偏流程数据编排，需要组织和协调资源的代码被定义为流程。场景单元与策略服务耦合更重，通过策略服务控制场景流程图的走向，以此来实现系统配置化。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《复杂软件设计之道：领域驱动设计全面解析与实战》 - 彭晨阳<br>《实现领域驱动设计》 - 沃恩·弗农<br>《解构领域驱动设计》 - 张逸<br>《DDD实战课》 - 极客时间</p><h3 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h3><p><a href="https://insights.thoughtworks.cn/backend-development-ddd/">https://insights.thoughtworks.cn/backend-development-ddd/</a><br><a href="https://zhuanlan.zhihu.com/p/383427771">https://zhuanlan.zhihu.com/p/383427771</a><br><a href="https://cloud.tencent.com/developer/article/1549817">https://cloud.tencent.com/developer/article/1549817</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/resource/img/2021-12-10-00-27-51.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;谈谈领域驱动设计的落地&quot;&gt;&lt;a href=&quot;#谈谈领域驱动设计的落地&quot; class=&quot;headerlink&quot; title=&quot;谈谈领域驱动设计的落地&quot;&gt;&lt;/a&gt;谈谈领域驱动设计的落地&lt;/h2&gt;&lt;p&gt;前文提到了事件风暴产出的领域模型是概念模型，到实际落地还有些距离，而落地的结果也是各不相同，我觉得说落地，要先回顾一下领域驱动设计的两个作用。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过战略设计拆分子域，指导微服务拆分。&lt;/li&gt;
&lt;li&gt;通过事件风暴建立领域概念模型，指导代码设计。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;也就是说领域驱动设计产出的结果是指导性的，并不是一个直接可落地的结果。落地的方案则是要通过架构设计和框架选择上来进行。架构是为了控制软件复杂性而做，就好像『一千个读者心中有一千个哈姆雷特』，不同人做架构不尽相同。下面说说我的落地方式。&lt;/p&gt;</summary>
    
    
    
    <category term="领域驱动设计" scheme="https://noogel.xyz/categories/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="架构" scheme="https://noogel.xyz/tags/%E6%9E%B6%E6%9E%84/"/>
    
    <category term="领域驱动设计" scheme="https://noogel.xyz/tags/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>领域驱动设计精粹（中）</title>
    <link href="https://noogel.xyz/2021/12/05/1.html"/>
    <id>https://noogel.xyz/2021/12/05/1.html</id>
    <published>2021-12-05T00:00:00.000Z</published>
    <updated>2025-07-23T07:30:58.918Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/resource/img/2021-12-10-00-27-51.png"></p><h2 id="领域驱动设计核心概念"><a href="#领域驱动设计核心概念" class="headerlink" title="领域驱动设计核心概念"></a>领域驱动设计核心概念</h2><p>领域驱动设计学习拦路虎之一就是众多的概念，第一次接触这些概念会有一定的理解成本，不过正是这些概念支撑起的领域驱动设计，接下来会以电商为例对其中的核心概念做介绍。</p><span id="more"></span><h3 id="电商案例"><a href="#电商案例" class="headerlink" title="电商案例"></a>电商案例</h3><p><img src="/resource/img/2021-12-12-18-57-09.png"></p><p>网上购物已经成为我们生活中不可分割的一部分，作为一个用户而言我们经历的流程有以下几点：</p><ol><li>从商品列表页面选择需要的商品。</li><li>查查商品的促销活动，凑凑满减。</li><li>在购物车选择需要买的商品下单。</li><li>下完单通过微信或者支付宝付钱。</li><li>然后等着物流送货上门。</li></ol><p>作为电商的管理人员我们需要做的则是以下几点：</p><ol><li>从采购点采购商品，存放到仓库。</li><li>编辑商品信息，上架售卖。</li><li>编辑一些优惠信息展示在平台上。</li><li>将用户下单的商品通知仓库发货。</li><li>营收成本的清结算。</li></ol><p>电商平台作为一个复杂系统主要有多阶段、⻓链路、多角⾊参与、多信息互通的商品&#x2F;服务交换过程的特点。而领域驱动设计中的概念能支撑我们将电商复杂流程拆解消化，并且建立一个易扩展、更稳定的系统。</p><h3 id="通用语言和限界上下文"><a href="#通用语言和限界上下文" class="headerlink" title="通用语言和限界上下文"></a>通用语言和限界上下文</h3><p>既然有多方协作参与系统的建设和运营，就需要沟通，而降低沟通成本的一个关键就是统一概念和认知，比如我们对于商品的认知，同样都是 iPhone 13，蓝色和粉色，128G 和 256G ，我们说卖掉了一个 iPhone 13 还是卖掉了一个 iPhone 13 蓝色 256G 要怎么表达，这时我们需要有两个概念 SKU 和 SPU 来区分，SKU 作为商品最小售卖单元表达后者，SPU 作为商品信息聚合的最小单位表达前者。</p><p>正是因为不同参与角色可能有不同的理解，为了降低大家沟通的障碍，提出了通用语言和限界上下文这两个重要概念。</p><p><strong>使团队交流达成共识的能够明确简单清晰地描述业务规则和业务含义的语言就是通用语言。</strong> 解决各岗位的沟通障碍问题，促进不同岗位的和合作，确保业务需求的正确表达。通用语言贯穿于整个设计过程，基于通用语言可以开发出可读性更好的代码，能准确的把业务需求转化为代码。</p><p><strong>界限上下文则是用来封装通用语言和领域对象，提供上下文环境，保证在上下文内的业务概念和流程等有一个确切的含义，没有二义性。</strong></p><p>业务概念往往由领域专家带领团队统一通用语言，明确上下文边界，以结算单这个概念在订单上下文和结算上下文的差异来举例：</p><p><img src="/resource/img/2021-12-12-18-57-29.png"></p><ul><li>订单上下文：记录一笔订单所购买商品的消费明细，包括商品原始金额、各项优惠金额、实付货币金额及种类。</li><li>结算上下文：记录的是商家、平台、供货方在一段时间之内的应收应付款项。</li></ul><p>明确上下文边界后，我们跟不同岗位的人沟通即使使用相同词汇也能准确理解其含义。</p><h3 id="领域专家和领域知识"><a href="#领域专家和领域知识" class="headerlink" title="领域专家和领域知识"></a>领域专家和领域知识</h3><p><img src="/resource/img/2021-12-12-18-58-00.png"></p><p>领域驱动设计强调由领域专家带领大家进行领域建模。<strong>领域专家指的是对一个领域的概念和业务流程精通的人，能快速识别或预判业务风险并能给出有效解决方案的人。</strong> 他可以是各个岗位的人，包括一个开发也能成为领域专家。领域知识则是这个领域的各种概念和业务流程。</p><h3 id="战略设计与战术设计"><a href="#战略设计与战术设计" class="headerlink" title="战略设计与战术设计"></a>战略设计与战术设计</h3><p>领域驱动设计作为一种设计方法论，从两个方向指导设计思想，提出了战略设计和战术设计的概念。</p><p>战略设计是从业务视角出发，建立业务领域模型，划分领域边界，建立通用语言下的限界上下文。它是从顶层视角来审视我们的软件系统各个子模块之间的边界。</p><p>拿上面的流程举例来说明，一个有经验的领域专家会带领大家通过事件风暴建模的方法进行子域拆分，大致分为交易域、营销域、支付域、商品域、履约域。</p><p>战术设计则是从技术视角出发，侧重于领域模型的技术实现，完成软件开发和落地，它主要关注的是技术层面的实施。战术设计识别出来的是聚合根、实体、值对象、领域服务、应用服务和资源库等代码逻辑的设计和实现。</p><h3 id="什么是领域模型"><a href="#什么是领域模型" class="headerlink" title="什么是领域模型"></a>什么是领域模型</h3><p>我们都不喜欢写 CRUD 的代码，只因为这些代码往往逻辑很简单，也不具备足够的扩展性，单一场景下可以很快开发出来，如果再加一个场景就又要开发一套，如果场景复杂并且不断变化，开发效率不仅会变慢，而且会更难以维护。下面通过支付系统来举例。</p><p><img src="/resource/img/2021-12-12-18-59-39.png"></p><p>对于 CRUD 的实践来说，在对接支付渠道的时候，给每一家渠道都增加渠道单记录表，字段参照渠道参数定义的，对接微信时增加 wechat_trade 表，增加支付宝时增加 alipay_trade 表。问题就是当渠道增多时每次都建表显然不现实。</p><p>正常的做法则是，统一支付单记录，提取支付关键信息，通过总表和渠道表来记录，总表记录关键信息，把次要信息放入渠道表。相当于把支付单信息做了一次垂直拆分。</p><p>随着发展，新增了连续订阅业务，产品说需要在支付单中识别出是系统扣费还是用户主动付费的，这时你会想着扩列来支持，可是业务千变万化，不能每次都这样做。</p><p>其实软件开发中的许多问题，例如沟通问题、演化问题都和领域模型有关。<strong>领域模型是对领域内的概念类或现实世界中对象的可视化表示。<em>它专注于分析问题领域本身，发掘重要的业务领域概念，并建立业务领域概念之间的关系。</em></strong></p><p><img src="/resource/img/2021-12-12-18-59-58.png"></p><h3 id="实体和值对象"><a href="#实体和值对象" class="headerlink" title="实体和值对象"></a>实体和值对象</h3><p>实体和值对象是组成领域模型的基础单元。</p><p><strong>实体拥有唯一标识符，且标识符在历经各种状态变更后仍能保持一致。</strong> 对实体而言，重要的不是其属性，而是其延续性和标识，对象的延续性和标识会跨越甚至超出软件的生命周期。我们把这样的对象称为实体。从上面的实例来说，支付单有唯一的 ID，渠道单有自己的唯一 ID，它们都是实体。</p><p><strong>当一个对象用来描述一个实物，而没有唯一的标识符，叫做值对象。</strong> 值对象本质就是一个集合，可以保证属性归类的清晰和概念的完整性。由于金额不能单独表达用户的消费额，需要由支付金额和货币类型组合才能表达，消费额是一组值对象。</p><p><img src="/resource/img/2021-12-12-19-00-20.png"></p><h3 id="聚合与聚合根"><a href="#聚合与聚合根" class="headerlink" title="聚合与聚合根"></a>聚合与聚合根</h3><p>聚合是领域模型的具体表达。</p><p><strong>聚合是业务和逻辑紧密关联的实体和值对象组合而成，聚合是数据修改和持久化的基本单元，一个聚合对应一个数据的持久化。</strong> 聚合在 DDD 分层架构中属于领域层，一个聚合提供一个业务核心能力，领域层包含了多个聚合，聚合内的实体以充血模型实现个体业务能力，以及业务逻辑的高内聚。</p><p><strong>聚合根也叫做根实体，它不仅仅是实体，还是实体的管理者。</strong> 聚合之间通过聚合根关联引用，如果需要访问其他聚合的实体，先访问聚合根，再导航到聚合内部的实体。即外部对象不能直接访问聚合内的实体。</p><p><img src="/resource/img/2021-12-12-19-00-36.png"></p><p>拿上面支付的例子来说，支付是一个聚合，支付单是聚合根，渠道单是依附于聚合根的另一个实体，渠道单的所有行为都要通过支付单进行操作。</p><p>上面说到聚合之间通过聚合根关联引用，一个实体是否属于聚合根取决于所处的聚合。在退款聚合中，退款单是聚合根，绑定的支付单，在这里支付单是普通实体。所以是否是聚合根取决于具体场景。</p><p>聚合的特点：高内聚、低耦合，它是领域模型中最底层的边界，可以作为拆分微服务的最小单位。</p><h3 id="概念关系"><a href="#概念关系" class="headerlink" title="概念关系"></a>概念关系</h3><p>关于领域驱动设计的核心概念已经介绍了一部分，后面还有一部分。关于这些概念的涵盖范围见下图。</p><p><img src="/resource/img/2021-12-12-18-59-11.png"></p><h2 id="从事件风暴建模学到什么"><a href="#从事件风暴建模学到什么" class="headerlink" title="从事件风暴建模学到什么"></a>从事件风暴建模学到什么</h2><p>在这里我说一下电商中比较核心的一个流程。在京东购物我们会选择很多需要的商品添加到购物车，在双十一的时候会凑单满减，然后从购物车选中下单。现在我们要设计的部分是用户在选择多件商品时自动给用户使用上最优的多种促销活动，在用户下单的时候能够计算好用户应该付多少钱，每件商品分别应付和优惠多少钱。后面的表达我会用算价来代表这个流程。</p><h3 id="领域知识的构成"><a href="#领域知识的构成" class="headerlink" title="领域知识的构成"></a>领域知识的构成</h3><p>在领域驱动设计中很强调领域专家这角色，与团队人员共同协作完成任务。而往往团队人员就拥有领域专家所拥有的部分知识，从而承担领域专家的职责，那么剩下的领域知识就需要靠团队人员借助外援来填补，方式包括但不限于以下三种方式：</p><ol><li>通过网络渠道（论文、文章、书籍）获得。</li><li>请教身边有相关经验的朋友。</li><li>通过竞品分析获得。</li></ol><p>当我们团队获得该领域下主要的领域知识后，需要结合实际需求进行战略设计和战术设计，就可以通过事件风暴建模方法进行领域建模。</p><p>本来是想着拿实际的例子来讲一遍事件风暴建模的过程，现在想想与其照本宣科的讲知识，不如写写经验和感悟来的实在。</p><h3 id="事件风暴-VS-传统开发"><a href="#事件风暴-VS-传统开发" class="headerlink" title="事件风暴 VS 传统开发"></a>事件风暴 VS 传统开发</h3><p>事件风暴建模的标准流程可以很轻松地找到，这里不再赘述。主要说下从传统软件开发模型到领域驱动设计的领域建模，发生了什么变化。</p><p>传统模式：产品需求-&gt;需求分析-&gt;详细设计-&gt;ER模型-&gt;UML 设计<br>DDD 模式：事件风暴-&gt;产品愿景-&gt;场景分析-&gt;领域建模-&gt;微服务拆分与设计。</p><p>在传统模式下的产出的是可直接落地的设计结果，但是缺乏顶层设计，对于后期的变更维护难以高效支撑。而 DDD 的关注点更多的是顶层设计和概念模型，概念模型并不是可直接落地的结果，这样的优势便是在后期的扩展和变更中更容易。</p><h3 id="子域拆分的关键经验"><a href="#子域拆分的关键经验" class="headerlink" title="子域拆分的关键经验"></a>子域拆分的关键经验</h3><p>关于如何拆分子域，看了很多的内容后得到的一句话：『凭经验』，这个就让人很糊涂，我如何知道我拆分的是否准确。</p><p>当我带着问题去找书查资料，收获还是比较快的，有一段话驱散了一部分迷雾：『领域的边界划分不断演绎，只要发现复杂性凝聚的地方，就划定为有界上下文，割裂它与其他系统的关系，并派出精兵强将专门对付。』它给了我两个点醒：</p><ol><li>领域的边界是<strong>不断演绎</strong>的。</li><li>领域内部是<strong>高内聚</strong>的，领域间是低耦合的。</li></ol><p>从这两点出发，可以通过以下两点执行：</p><ol><li>和领域专家沟通现在，并预判一下未来。</li><li>分析领域内头部公司的策略。</li></ol><h3 id="领域建模的关键经验"><a href="#领域建模的关键经验" class="headerlink" title="领域建模的关键经验"></a>领域建模的关键经验</h3><p>假定产品愿景是可行并且可执行的。在场景分析和领域建模的过程，有个通用的范式。</p><ol><li>提取业务中的<strong>动词</strong>和<strong>名词</strong>识别为领域概念。</li><li>通过业务中的定语对领域概念进行<strong>归纳抽象</strong>。</li><li>对确定的领域概念进行<strong>关系确认</strong>。</li></ol><p>由此我们可以得出领域分析模型，这是一个比较抽象的模型，此时还无法落地。从复杂性角度来看领域建模控制的是业务复杂性。</p><h3 id="复杂性问题控制方式"><a href="#复杂性问题控制方式" class="headerlink" title="复杂性问题控制方式"></a>复杂性问题控制方式</h3><p>在之前的文章中也提到过三点：</p><ol><li>抽象</li><li>分治</li><li>领域知识</li></ol><p>现在反过来看，提炼领域概念是抽象，子域拆分是分治，而要做到这两点的正需要的是领域知识。领域驱动设计不仅告诉了我们『道』，也告诉了我们『术』。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/resource/img/2021-12-10-00-27-51.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;领域驱动设计核心概念&quot;&gt;&lt;a href=&quot;#领域驱动设计核心概念&quot; class=&quot;headerlink&quot; title=&quot;领域驱动设计核心概念&quot;&gt;&lt;/a&gt;领域驱动设计核心概念&lt;/h2&gt;&lt;p&gt;领域驱动设计学习拦路虎之一就是众多的概念，第一次接触这些概念会有一定的理解成本，不过正是这些概念支撑起的领域驱动设计，接下来会以电商为例对其中的核心概念做介绍。&lt;/p&gt;</summary>
    
    
    
    <category term="领域驱动设计" scheme="https://noogel.xyz/categories/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="架构" scheme="https://noogel.xyz/tags/%E6%9E%B6%E6%9E%84/"/>
    
    <category term="领域驱动设计" scheme="https://noogel.xyz/tags/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
</feed>
