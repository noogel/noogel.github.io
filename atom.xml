<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>知一杂谈</title>
  
  <subtitle>我思故我在</subtitle>
  <link href="https://noogel.xyz/atom.xml" rel="self"/>
  
  <link href="https://noogel.xyz/"/>
  <updated>2025-07-23T17:01:49.028Z</updated>
  <id>https://noogel.xyz/</id>
  
  <author>
    <name>noogel</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从淘宝看促销：解析电商促销模型</title>
    <link href="https://noogel.xyz/2025/07/23/1.html"/>
    <id>https://noogel.xyz/2025/07/23/1.html</id>
    <published>2025-07-23T00:00:00.000Z</published>
    <updated>2025-07-23T17:01:49.028Z</updated>
    
    <content type="html"><![CDATA[<p>在当今竞争激烈的电商环境中，促销活动已不再仅仅是简单的价格打折，而是驱动用户增长、提升销售额、清理库存乃至品牌建设的核心战略工具。一个设计精良的促销系统，是电商平台能否灵活应对市场变化、实现精细化运营的关键。本文将以淘宝的视角为切入点，深入剖析促销系统的核心概念、内部关系，以期为读者提供一个全面而深入的理解。</p><h3 id="一、促销系统的核心概念与内在关系"><a href="#一、促销系统的核心概念与内在关系" class="headerlink" title="一、促销系统的核心概念与内在关系"></a><strong>一、促销系统的核心概念与内在关系</strong></h3><p><img src="/resource/img/2025-07-24-00-02-13.png"></p><p>要构建一个强大而灵活的促销系统，首先需要明确其基石——核心概念，以及这些概念之间如何相互作用、构成一个有机整体。</p><p><strong>1. 促销池 (Promotion Pool)：万策之源</strong><br>促销池是整个促销系统的“心脏”，它承载着所有已定义、待生效或已过期的促销活动。你可以将其想象成一个巨大的容器，容纳着各种形式和规则的优惠策略。所有关于促销的创建、查询、管理和应用，都离不开这个核心的概念。它不仅是促销活动的存储库，更是系统进行促销筛选和匹配的起点。</p><p><strong>2. 促销范围 (Promotion Scope)：精准打击的靶心</strong><br>促销范围定义了特定促销活动适用的商品、品类、店铺乃至用户群体。它是实现促销“精准打击”的关键。没有范围的限定，促销就如同“大水漫灌”，无法针对特定目标发挥最大效用，甚至可能导致成本失控。常见的促销范围包括：</p><ul><li><strong>SKU (Stock Keeping Unit)</strong>：最细粒度的商品唯一标识。</li><li><strong>商品品类 (Product Category)</strong>：例如“数码产品”、“服饰鞋包”。</li><li><strong>品牌 (Brand)</strong>：针对特定品牌的商品进行促销。</li><li><strong>店铺 (Store)</strong>：针对特定商家店铺内的所有商品进行促销。</li><li><strong>用户标签&#x2F;等级 (User Tags&#x2F;Levels)</strong>：例如“新用户专属”、“VIP会员特惠”。</li></ul><p>促销范围的明确界定，是后续进行促销匹配和计算的前提。</p><p><strong>3. 促销配置 (Promotion Configuration)：规则与条件的蓝图</strong><br>促销配置是促销活动的具体规则和属性的集合，它是促销活动得以生效的“蓝图”。其复杂度决定了促销策略的灵活度。一个完整的促销配置通常包含以下关键要素：</p><ul><li><strong>促销ID (Promotion ID) &#x2F; 促销Key (PromoKey)</strong>：促销的唯一标识，方便系统内部管理和用户外部引用。</li><li><strong>促销类型 (Promotion Type)</strong>：定义了促销的优惠形式，例如：<ul><li><strong>满减 (Full Reduction)</strong>：满足一定金额或数量即减免。</li><li><strong>立减 (Direct Reduction)</strong>：直接减免一定金额。</li><li><strong>折扣 (Discount)</strong>：按比例打折。</li><li><strong>限时抢购&#x2F;秒杀 (Time-limited Rush&#x2F;Flash Sale)</strong>：在特定时间段内以极低价格出售。</li><li><strong>捆绑促销 (Bundle Promotion)</strong>：多件商品组合购买优惠。</li></ul></li><li><strong>有效期 (Begin Time &#x2F; End Time)</strong>：促销活动生效和失效的时间段。</li><li><strong>促销级别 (Level)</strong>：区分促销是由平台发起、店铺发起还是基础配置，这通常与促销优先级和费用承担方相关。</li><li><strong>促销状态 (Status)</strong>：表示促销的生命周期状态，如“草稿”、“在线”、“下线”、“过期”。</li><li><strong>促销规则 (Rule)</strong>：这是最复杂也是最核心的部分，定义了触发优惠的具体条件和优惠计算方式。例如：满X件、满Y元、购买指定商品组合等。</li><li><strong>用户限制 (User Dimension)</strong>：限制每个用户参与促销的次数、领取优惠券的数量等，防止恶意刷单或滥用。</li><li><strong>优惠优先级 (Promotion Priority)</strong>：当多个促销同时满足条件时，确定哪个促销优先应用或如何进行叠加&#x2F;互斥。</li></ul><p>这些核心概念相互关联，构成了一个立体的促销模型：促销池是所有促销配置的集合，每个促销配置都定义了具体的促销类型、规则和生效时间，并通过促销范围精准地作用于特定的商品或用户。促销配置中的<strong>规则</strong>设计，是整个促销系统灵活性和表达能力的核心。在实际实现中，规则配置主要有两种方案：</p><p><strong>1. 方案一：自定义领域特定语言（DSL）</strong></p><p>自定义DSL是一种专门为特定领域问题设计的编程语言。在促销系统场景下，它表现为一套简洁、直观的指令集和语法，使得运营人员或配置工具能够以接近自然语言的方式来定义促销规则。</p><p>自定义DSL的核心在于抽象和简化。它将复杂的业务逻辑封装成一系列预定义的“指令”和“函数”，比如：</p><ul><li><strong>条件-执行指令（WHEN…THEN）</strong>：用于定义具体的触发条件和执行动作，例如 <code>WHEN HAS(SKU:XXX) THEN DOSCOUNT(80)</code>，明确表示“当某个SKU存在时，该商品打八折”。这种结构清晰地表达了“如果…就…”的业务逻辑。</li><li><strong>资源标识符</strong>：例如 <code>SKU:12312312313</code>、<code>CATEGORY:123123123213</code>，以统一的格式标识促销作用的实体。</li></ul><p>系统内部会包含一个DSL解析器和执行器。解析器将DSL文本转换为内部可执行的数据结构（如抽象语法树或指令序列），执行器则根据这些指令，结合当前的购物车数据、用户信息等“事实”，来计算并应用促销。</p><p><strong>2. 方案二：引入外部规则引擎（如Drools）</strong></p><p>引入外部规则引擎是将业务规则管理能力外包给一个成熟的、专用的软件系统。它将业务规则从应用程序代码中彻底剥离，并提供一套独立的规则定义、管理和执行机制。Drools是其中一个非常流行的开源选择。</p><p>规则引擎的核心理念是<strong>基于事实（Facts）进行模式匹配和规则触发</strong>。在促销系统中，购物车、商品、用户、订单等业务对象都是“事实”。规则引擎会持续评估这些事实，一旦满足某个规则的<code>WHEN</code>（条件）部分，就会触发其<code>THEN</code>（动作）部分。</p><p>集成Drools到促销系统的一般流程如下：</p><ol><li><p><strong>定义领域模型（Facts）</strong>：将促销所需的业务数据（如商品SKU、价格、数量、用户等级、购物车总价等）映射为Plain Old Java Objects (POJOs)，这些对象将在运行时作为“事实”被插入到规则引擎中。</p></li><li><p><strong>编写规则（Rules）</strong>：使用Drools Rule Language (DRL) 或决策表、决策树来编写促销规则。DRL规则语法强大，支持复杂的逻辑运算符、集合操作、内建函数等。例如：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rule &quot;满100减20&quot;</span><br><span class="line">    when</span><br><span class="line">        $cart : Cart(totalAmount &gt;= 100) // 购物车总金额大于等于100</span><br><span class="line">    then</span><br><span class="line">        $cart.applyDiscount(20); // 购物车应用20元优惠</span><br><span class="line">        update($cart); // 通知引擎事实已改变</span><br><span class="line">end</span><br></pre></td></tr></table></figure></li><li><p><strong>构建知识库（Knowledge Base）</strong>：将编写好的DRL文件编译成<code>KieBase</code>（知识库），这是一个包含了所有规则的运行时组件。</p></li><li><p><strong>创建会话（Session）</strong>：在应用程序运行时，创建<code>KieSession</code>（或<code>StatelessKieSession</code>），这是一个执行规则的上下文。</p></li><li><p><strong>插入事实</strong>：将当前请求的业务数据（购物车、用户等）作为事实插入到会话中。</p></li><li><p><strong>触发规则</strong>：调用<code>kieSession.fireAllRules()</code>，引擎会根据Rete算法高效地匹配所有规则并执行被触发的规则。</p></li><li><p><strong>获取结果</strong>：规则执行完毕后，从会话中提取被修改的事实对象或收集到的结果（如优惠金额列表），返回给业务逻辑层。</p></li></ol><h3 id="二、促销系统的关键系统设计"><a href="#二、促销系统的关键系统设计" class="headerlink" title="二、促销系统的关键系统设计"></a><strong>二、促销系统的关键系统设计</strong></h3><p>在理解了核心概念和规则配置方案后，接下来我们将深入探讨促销系统的关键设计模块和流程。</p><p><strong>1. 促销创建流程：从策略到配置</strong></p><p>创建促销是一个将营销策略转化为系统可执行配置的过程。该流程通常包括以下步骤：</p><ol><li><strong>策略制定与范围圈定</strong>：运营人员根据市场分析和营销目标，制定促销策略，并明确促销的目标商品或用户范围（如某个品类、一批SKU、新用户）。</li><li><strong>促销绑定与规则定义</strong>：针对已圈定的范围，选择合适的促销类型（如满减、折扣），并详细定义其触发条件和优惠力度。例如，指定“满2件8.8折”的规则，或“A商品减20元，B商品减30元”的减扣规则。这些规则的定义，将依据上述DSL或规则引擎方案进行配置。</li><li><strong>时效与状态管理</strong>：设置促销的生效和失效时间，以及初始状态（如“草稿”或“在线”）。</li><li><strong>元信息补充</strong>：录入促销描述、活动ID、费用承担方等辅助信息。</li><li><strong>提交与审核</strong>：完成配置后，提交系统进行校验和可能的审批流程，确保促销配置的合法性和准确性。</li></ol><p><strong>2. 促销筛选过程：实时匹配与优惠计算</strong></p><p>促销筛选是系统运行时最核心、最频繁的流程，它需要在用户浏览商品或提交订单时，快速准确地识别出所有适用的促销活动并计算优惠。</p><ol><li><strong>商品集合输入 (X)</strong>：用户购物车中的商品列表，或正在浏览的单个商品。</li><li><strong>在线促销检索 (Y)</strong>：系统首先从“促销池”中，根据商品集合 <code>X</code> 的基本信息（如商品ID、品类ID），快速筛选出所有<strong>可能相关且处于在线状态</strong>的促销配置集合 <code>Y</code>。这一步通常会利用缓存和索引进行优化，以提高检索效率。</li><li><strong>可用性计算（核心判决）</strong>：对 <code>Y</code> 中的每个促销 <code>y</code>，进行详细的可用性计算：<ul><li><strong>范围过滤 (X’ &#x3D; X ∩ y.scope_list)</strong>：将输入的商品集合 <code>X</code> 与当前促销 <code>y</code> 的适用范围 <code>y.scope_list</code> 进行交叉过滤，得到真正属于该促销范围的商品子集 <code>X&#39;</code>。不属于范围的商品将直接被排除。</li><li><strong>规则匹配 (y.rule)</strong>：将 <code>X&#39;</code> 应用到 <code>y.rule</code> 上。系统会判断 <code>X&#39;</code> 是否满足促销触发条件（例如，商品数量是否达到2件、总金额是否达到100元）。具体执行机制取决于采用的规则配置方案（DSL解析执行或Drools规则引擎）。</li><li><strong>优惠金额计算</strong>：如果规则匹配成功，系统将根据 <code>y.rule</code> 定义的优惠方式，精确计算出 <code>X&#39;</code> 中每个商品应享受的优惠金额，以及该促销活动的总优惠金额。</li></ul></li><li><strong>结果聚合与返回 (Y’)</strong>：将所有满足条件并计算出优惠的促销活动收集起来，形成一个促销列表 <code>Y&#39;</code>，返回给调用方。每个促销结果中，不仅包含总优惠金额，还需详细列出每个参与优惠的商品及其分摊到的具体优惠金额，这对于订单详情展示和后续财务分账至关重要。</li></ol><h3 id="三、从淘宝看促销"><a href="#三、从淘宝看促销" class="headerlink" title="三、从淘宝看促销"></a><strong>三、从淘宝看促销</strong></h3><img src="/resource/img/2025-07-24-00-41-43.png" width=260 /><p>在上面图片中，我们可以看到一个购物车的“金额明细”界面，其中明确展示了不同层级的优惠。</p><p>最显著的是 <strong>“店铺优惠 减 ¥34.19”</strong>。这与上文提到的“促销配置”中的“促销级别”概念紧密相关。店铺优惠通常是由商家（如“太力官方旗舰店”）自主设置的促销活动，其优惠力度和规则由店铺决定，属于<strong>店铺级别</strong>的促销。</p><p>具体到明细中，可以看到“太力官方旗舰店”下的商品享受了以下店铺级促销：</p><ul><li><strong>“超级立减”</strong>：小计 ¥7.90，减 ¥1.19。这是一种直接针对单个商品的折扣或立减优惠。</li><li><strong>“百亿补贴”</strong>：小计 ¥93.40，减 ¥3.00。虽然名为“百亿补贴”，但在这里它被归类到店铺名下，表明这部分补贴是由该店铺承担或与平台合作在店铺内生效的。</li><li><strong>“智能单品补贴”</strong>：小计 ¥93.40，减 ¥10.00。这同样是一种针对单个商品进行的补贴，可能通过智能算法匹配。</li><li><strong>“满45元减20元”</strong>：小计 ¥61.90，减 ¥20.00。这是一个典型的“满减”促销，商品金额达到45元即可减20元。</li></ul><p>这些优惠都是“店铺优惠”的组成部分，反映了促销系统能够支持不同商家在自身权限范围内配置和执行多样化促销策略的能力。这与“促销范围”中的“店铺”维度以及“促销类型”中的“满减”、“立减”等具体类型相符，体现了促销配置的灵活性。</p><p>值得注意的是，在当前的“金额明细”展示中，我们尚未看到优惠券类型优惠的详细拆解。在电商促销模型中，优惠券通常作为一种独立的促销类型存在，它拥有自身的领取、使用规则、有效期和适用范围。其在最终价格计算中的作用和叠加逻辑，将在后续的算价环节中进行详细介绍和体现。这进一步说明了促销系统需要处理多层级、多类型的优惠叠加与互斥，以最终得出用户实际支付金额的复杂性。</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a><strong>结语</strong></h3><p>促销系统是电商平台不可或缺的增长引擎。一个优秀的促销系统设计，不仅需要对各种促销类型有深刻的理解，更要能将复杂的业务逻辑抽象为清晰的领域模型，并通过健壮的技术架构实现高效的创建、筛选和应用。从核心概念的明确到灵活的规则配置（无论是DSL还是规则引擎），再到高效的筛选流程，每一步都至关重要。只有这样，促销系统才能真正成为助力电商企业实现持续增长的强大武器。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在当今竞争激烈的电商环境中，促销活动已不再仅仅是简单的价格打折，而是驱动用户增长、提升销售额、清理库存乃至品牌建设的核心战略工具。一个设计精良的促销系统，是电商平台能否灵活应对市场变化、实现精细化运营的关键。本文将以淘宝的视角为切入点，深入剖析促销系统的核心概念、内部关系，</summary>
      
    
    
    
    
    <category term="架构" scheme="https://noogel.xyz/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>软件系统复杂性治理方法</title>
    <link href="https://noogel.xyz/2024/02/13/1.html"/>
    <id>https://noogel.xyz/2024/02/13/1.html</id>
    <published>2024-02-13T00:00:00.000Z</published>
    <updated>2025-07-23T07:30:58.916Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/resource/img/2024-02-14-23-36-09.png"></p><p>本文讨论了软件复杂性及其产生原因，介绍了如何度量软件复杂性，及 SOLID 软件设计原则，并探讨管理复杂性的方法，包括使用代码重构、设计模式、领域驱动设计等。通过遵循这些原则和方法，开发人员可以降低软件复杂性，提高代码质量和可维护性。这篇文章内容涵盖了软件开发的道与术，希望能对你所有帮助，欢迎评论交流～</p><ol><li>什么是软件复杂性</li><li>软件复杂性产生原因</li><li>如何度量软件复杂性</li><li>SOLID 软件设计原则</li><li>管理复杂性的方法</li></ol><span id="more"></span><h2 id="什么是软件复杂性"><a href="#什么是软件复杂性" class="headerlink" title="什么是软件复杂性"></a>什么是软件复杂性</h2><p>软件系统复杂性指的是系统内部组件、模块、包、类、方法之间的交互关系以及整体设计的复杂程度。这种复杂度可能源自于多方面因素，包括但不限于代码规模、结构的混乱程度、各个模块之间的耦合度、算法的复杂性以及系统中存在的条件分支和循环等。</p><p>系统复杂度的高低直接影响着软件的可理解性、可维护性和可扩展性。高复杂度的系统通常意味着更难以理解和修改，也更容易引入错误。此外，复杂度过高还会增加软件开发和维护的成本。</p><p>所以说理解和管理软件系统复杂度至关重要。通过采用适当的设计原则、模式和工程实践，以及持续的重构和优化，可以有效地控制和降低软件系统的复杂度，从而提高系统的可维护性、可理解性和可靠性。</p><p>以下是两个相同功能的示例代码段，通过对比可以观察下复杂性差异：</p><p><strong>多层嵌套条件语句</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processOrder</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (order != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (order.isValid()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (order.getPaymentStatus() == PaymentStatus.PAID) &#123;</span><br><span class="line">                <span class="keyword">if</span> (order.getShippingStatus() == ShippingStatus.SHIPPED) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (order.getShippingAddress() != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 执行订单处理操作</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 发送错误消息：缺少配送地址</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 发送错误消息：订单未发货</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 发送错误消息：订单未支付</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 发送错误消息：无效订单</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 发送错误消息：订单为空</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通过早期返回重构</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processOrder</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (order == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 发送错误消息：订单为空</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!order.isValid()) &#123;</span><br><span class="line">        <span class="comment">// 发送错误消息：无效订单</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (order.getPaymentStatus() != PaymentStatus.PAID) &#123;</span><br><span class="line">        <span class="comment">// 发送错误消息：订单未支付</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (order.getShippingStatus() != ShippingStatus.SHIPPED) &#123;</span><br><span class="line">        <span class="comment">// 发送错误消息：订单未发货</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (order.getShippingAddress() == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 发送错误消息：缺少配送地址</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行订单处理操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面两段代码，通过对比可以发现第一段代码展示了典型的深度嵌套条件语句，可读性差、扩展性差。第二段重构后的代码使用了早期返回的方式，将每个条件检查分开处理，遇到不满足条件的情况就提前返回错误消息。这样可以减少嵌套的条件语句，提高代码的可读性和可维护性。</p><p>第二段代码是对第一段代码的改进，但也是存在一定的可读性和扩展性差的问题的，提前返回是一种断路思考方式，不利于记忆，如果方法比较长，或者后期叠代码使方法变得很长，是不太容易梳理出”什么情况下会执行订单处理操作”，你需要记住各种断路情况。</p><p><img src="/resource/img/2024-02-14-23-31-35.png"></p><h2 id="系统复杂性产生的原因"><a href="#系统复杂性产生的原因" class="headerlink" title="系统复杂性产生的原因"></a>系统复杂性产生的原因</h2><p>复杂性是系统的固有属性，它来源于系统的规模、结构、功能、行为等多个方面，有外在和内在两方面原因，下面列举几点：</p><p><strong>需求变更</strong><br>随着时间的推移，产品需求会不断变化。这些变化可能需要对现有系统进行修改或添加新功能，从而增加了软件系统的复杂性。</p><p><strong>技术选型</strong><br>选择不合适的技术栈或架构模式可能会导致系统的过度复杂化。有时为了解决一个小问题可能会引入大量不必要的技术组件，使系统变得更加复杂。</p><p><strong>规模扩大</strong><br>随着业务的发展，软件系统可能需要处理更多种类的数据和用户，这会导致系统规模的扩大，系统的元素和关系会随着规模的增大而增多。</p><p><strong>不完善的设计</strong><br>缺乏清晰的系统设计和架构规划可能导致系统出现混乱和复杂性。如果最初的设计没有考虑到系统的未来发展，系统将很快变得难以管理和理解。</p><p>巨著《人月神话》中提出了两个重要概念：</p><ul><li>本质复杂度：是指由软件系统所需解决的问题本身所固有的复杂性。它是由问题的本质属性和要求所决定的，与软件实现的细节无关。</li><li>偶然复杂度：是指由软件实现过程中引入的额外复杂性。它是由设计决策、技术选择、代码结构等因素所导致的。</li></ul><p>偶然复杂度不是待求解问题的本质，相对而言， 本质复杂度和待求解问题的本质有关，是无法避免的。偶然复杂度一般是在选用求解问题的方法时所引入的。上面列举的四点，其中技术选型不当和不完善的设计都是因为开发人员经验和预判不足而产生的，属于偶然复杂度；而需求变更和规模扩大则是待求解问题逐渐变多变复杂而产生的，属于本质复杂度。</p><h2 id="如何度量软件复杂性"><a href="#如何度量软件复杂性" class="headerlink" title="如何度量软件复杂性"></a>如何度量软件复杂性</h2><p>之前写过一篇简单介绍过 <a href="/2021/10/22/1.html">软件架构与系统复杂性</a>，下面主要介绍软件系统复杂度度量方式。</p><p><strong>圈复杂度（Cyclomatic Complexity）</strong><br>圈复杂度是一种用来衡量代码复杂性的指标，它通过计算代码中独立路径的数量来评估代码的复杂程度。通俗地说，圈复杂度越高，代码的可读性和维护性就越差。</p><p><strong>时间空间复杂度</strong><br>时间复杂度是用于衡量程序在执行过程中所需的时间资源的多少，而空间复杂度则衡量程序在执行过程中所需的内存资源的多少。</p><p><strong>代码行数</strong><br>代码行数是衡量软件规模和复杂度的一种指标。通常情况下，代码行数越多，系统的复杂度也越高。然而，这并不是绝对的，因为有时候简洁的代码可能实现了复杂的功能。</p><p><strong>嵌套层数</strong><br>嵌套层数指的是代码中条件语句、循环语句和函数调用的嵌套深度。如果嵌套层数过多，会导致代码逻辑混乱，增加代码的理解和维护难度。</p><p><strong>组件的相互依赖关系</strong><br>软件系统中各个组件之间的相互依赖关系也是衡量复杂度的重要标准。如果组件之间的依赖关系错综复杂，那么系统的修改和扩展将变得困难。</p><h2 id="SOLID-软件设计原则"><a href="#SOLID-软件设计原则" class="headerlink" title="SOLID 软件设计原则"></a>SOLID 软件设计原则</h2><p>通常来说，要想构建一个好的软件系统，应该从写整洁的代码开始做起。毕竟，如果建筑所使用的砖头质量不佳，那么架构所能起到的作用也会很有限。反之亦然，如果建筑的架构设计不佳，那么其所用的砖头质量再好也没有用。SOLID 是一组软件设计原则，旨在帮助开发人员设计可维护、可扩展和易于理解的软件架构。下面简要介绍每个原则：</p><ol><li><p>单一职责原则（Single Responsibility Principle，SRP）：一个类应该只有一个引起它变化的原因。这意味着一个类应该只负责一项明确定义的职责或功能，这样可以使类更加内聚，易于理解和修改。</p></li><li><p>开放封闭原则（Open-Closed Principle，OCP）：软件实体（类、模块、函数等）应该对扩展开放，对修改封闭。这意味着在修改现有代码时，应该通过扩展现有代码的行为来实现变化，而不是直接修改已有的代码。</p></li><li><p>里氏替换原则（Liskov Substitution Principle，LSP）：子类应该能够替换其父类并且不会破坏系统的正确性。这意味着子类应该能够在不改变程序正确性的前提下，替代父类的行为。这样可以确保代码的可靠性和可扩展性。</p></li><li><p>接口隔离原则（Interface Segregation Principle，ISP）：客户端不应该依赖于它不需要的接口。这意味着接口应该尽量小而专注，而不是大而笼统。通过定义精确的接口，可以避免客户端依赖无关的接口，提高系统的灵活性和可维护性。</p></li><li><p>依赖倒置原则（Dependency Inversion Principle，DIP）：高层模块不应该依赖于低层模块，而是应该依赖于抽象。这意味着应该通过抽象来解耦模块之间的依赖关系，使得系统更加灵活和可扩展。</p></li></ol><p><strong>这些原则共同强调了代码的高内聚性、低耦合性和可扩展性。遵循这些原则可以提高代码的可维护性、可测试性和可重用性，从而使软件架构更加健壮和可靠。你可能会说道理我都懂但是做不到，王阳明在《传习录》中说，“未有知而不行者，知而不行，只是未知”，如果不能在开发中深切体会这些原则的精髓那便是不懂，是需要在日常开发中不断思考和体会的。</strong></p><p><img src="/resource/img/2024-02-14-23-33-00.png"></p><h2 id="控制和管理复杂性的方法"><a href="#控制和管理复杂性的方法" class="headerlink" title="控制和管理复杂性的方法"></a>控制和管理复杂性的方法</h2><p>如果你读到这里，说明看过了很多 “大泥球” 代码，想找到其中的破解之道，下面会抽丝剥茧，介绍一些方式方法。</p><p>“大泥球”（Big Ball of Mud）是指一种缺乏清晰结构和良好架构的代码，通常随着时间推移不断添加功能和修复问题而产生。还是以上面的代码为例，展示一个可能被称为”大泥球”代码的案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processOrder</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (order != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (order.isValid()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (order.getPaymentStatus() == PaymentStatus.PAID) &#123;</span><br><span class="line">                <span class="keyword">if</span> (order.getShippingStatus() == ShippingStatus.SHIPPED) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (order.getShippingAddress() != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (order.isGiftOrder()) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (order.getGiftMessage() != <span class="literal">null</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (order.getGiftWrapOption() == GiftWrapOption.SELECTED) &#123;</span><br><span class="line">                                    <span class="comment">// 执行礼品订单处理操作（更多嵌套逻辑）</span></span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    <span class="comment">// 发送错误消息：未选择礼品包装选项</span></span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="comment">// 发送错误消息：缺少礼品留言</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// 执行非礼品订单处理操作</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 发送错误消息：缺少配送地址</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 发送错误消息：订单未发货</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 发送错误消息：订单未支付</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 发送错误消息：无效订单</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 发送错误消息：订单为空</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要增加一个判断订单是否为礼品订单的处理逻辑，最直接的方式是在其基础上继续嵌套更多的条件判断。久而久之这样的“大泥球”代码就存在多层嵌套的条件判断，逻辑复杂、难以理解和维护。</p><h3 id="小重构"><a href="#小重构" class="headerlink" title="小重构"></a>小重构</h3><p><strong>对于超大型的方法和类，最简单的、较低风险的方式是拆分方法和类</strong>，之前写过一篇小文章 <a href="/2019/06/26/1.html">从小重构说起</a>。对于方法和类的拆分，可以借助 IDE 来实现，这样可以进一步降低风险；对于静态变量需要提取到公共配置类；通常来说业务方法大都是无状态的，对于有状态方法需要谨慎操作。</p><p>要提高上面方法的可读性和可维护性，可以将其拆分成更小的方法。下面是重构后的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processOrder</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (order == <span class="literal">null</span>) &#123;</span><br><span class="line">        sendErrorMessage(<span class="string">&quot;订单为空&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!order.isValid()) &#123;</span><br><span class="line">        sendErrorMessage(<span class="string">&quot;无效订单&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (order.getPaymentStatus() != PaymentStatus.PAID) &#123;</span><br><span class="line">        sendErrorMessage(<span class="string">&quot;订单未支付&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (order.getShippingStatus() != ShippingStatus.SHIPPED) &#123;</span><br><span class="line">        sendErrorMessage(<span class="string">&quot;订单未发货&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (order.getShippingAddress() == <span class="literal">null</span>) &#123;</span><br><span class="line">        sendErrorMessage(<span class="string">&quot;缺少配送地址&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (order.isGiftOrder()) &#123;</span><br><span class="line">        processGiftOrder(order);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        processStandardOrder(order);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processStandardOrder</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">    <span class="comment">// 执行非礼品订单处理操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processGiftOrder</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (order.getGiftMessage() == <span class="literal">null</span>) &#123;</span><br><span class="line">        sendErrorMessage(<span class="string">&quot;缺少礼品留言&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (order.getGiftWrapOption() != GiftWrapOption.SELECTED) &#123;</span><br><span class="line">        sendErrorMessage(<span class="string">&quot;未选择礼品包装选项&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行礼品订单处理操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sendErrorMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">    <span class="comment">// 发送错误消息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重构后的代码中，我们将原来的单个方法拆分成了多个方法。<code>processOrder</code> 方法负责处理整个订单流程的控制，进行基本的前置条件检查，然后根据订单类型（礼品订单或非礼品订单）调用相应的处理方法。</p><p><code>processStandardOrder</code> 方法用于处理非礼品订单，而 <code>processGiftOrder</code> 方法用于处理礼品订单。这样，我们可以在具体的处理方法中添加更多的逻辑，而不会让整个代码过于复杂。同时，通过使用早期返回，遇到不满足条件的情况就会提前返回错误消息，避免了过多的嵌套条件。</p><p>另外，我们还引入了一个辅助方法 <code>sendErrorMessage</code>，用于发送错误消息，避免了重复的代码。</p><p>这样的重构使得代码结构更加清晰，逻辑更易于理解和维护。每个方法负责一个具体的任务，代码的可读性和可维护性都得到了提升。</p><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p>随着需求发生变化，不同状态的订单需要有不同的处理方式，当当前的方法不再满足现状时，就需要进行扩充，复杂度也会相应提升。为了进一步应对复杂度的提升，可以考虑适合的设计模式。</p><p>设计模式通过提供可重用的解决方案，帮助我们管理软件复杂度。它们提供了一种通用的、经过验证的方法来解决常见的软件设计问题，使得系统更易于理解、扩展和修改。同时，设计模式也促进了代码的重用和降低了系统的耦合度，从而提高了软件的质量和可维护性。</p><p>以上面的例子，要根据不同的订单状态生成不同的后续处理行为，可以使用策略模式来表达这一设计。策略模式允许定义一系列算法（策略），将它们封装在独立的策略类中，并使得它们可以互相替换。</p><p>下面是使用策略模式来重构的代码示例：</p><p>首先，定义一个接口 <code>OrderProcessingStrategy</code>，表示订单处理策略，其中包含一个 <code>processOrder()</code> 方法来执行订单处理操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderProcessingStrategy</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">processOrder</span><span class="params">(Order order)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，实现不同的订单处理策略，每个策略都实现 <code>OrderProcessingStrategy</code> 接口，并根据订单状态执行相应的处理操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaidShippedOrderStrategy</span> <span class="keyword">implements</span> <span class="title class_">OrderProcessingStrategy</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processOrder</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">        <span class="comment">// 执行订单被支付且已发货的处理操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaidNotShippedOrderStrategy</span> <span class="keyword">implements</span> <span class="title class_">OrderProcessingStrategy</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processOrder</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">        <span class="comment">// 执行订单被支付但未发货的处理操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnpaidOrderStrategy</span> <span class="keyword">implements</span> <span class="title class_">OrderProcessingStrategy</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processOrder</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">        <span class="comment">// 执行订单未支付的处理操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InvalidOrderStrategy</span> <span class="keyword">implements</span> <span class="title class_">OrderProcessingStrategy</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processOrder</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">        <span class="comment">// 执行无效订单的处理操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，在 <code>Order</code> 类中添加一个 <code>process()</code> 方法，用来触发订单的处理操作。在该方法中，根据订单状态选择相应的策略，并调用策略的 <code>processOrder()</code> 方法来执行处理操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> OrderProcessingStrategy processingStrategy;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他属性和方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (processingStrategy == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 默认处理策略</span></span><br><span class="line">            processingStrategy = <span class="keyword">new</span> <span class="title class_">InvalidOrderStrategy</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        processingStrategy.processOrder(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，在客户端代码中，我们可以创建订单对象，并根据订单状态设置相应的处理策略。通过调用订单对象的 <code>process()</code> 方法来触发订单的处理操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">        <span class="comment">// 根据订单状态设置对应的处理策略</span></span><br><span class="line">        <span class="keyword">if</span> (order.getPaymentStatus() == PaymentStatus.PAID) &#123;</span><br><span class="line">            <span class="keyword">if</span> (order.getShippingStatus() == ShippingStatus.SHIPPED) &#123;</span><br><span class="line">                order.setProcessingStrategy(<span class="keyword">new</span> <span class="title class_">PaidShippedOrderStrategy</span>());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                order.setProcessingStrategy(<span class="keyword">new</span> <span class="title class_">PaidNotShippedOrderStrategy</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            order.setProcessingStrategy(<span class="keyword">new</span> <span class="title class_">UnpaidOrderStrategy</span>());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        order.process();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过使用策略模式，我们可以将不同状态的订单处理逻辑解耦，使得每个策略类负责自己的处理操作。这样，可以更灵活地扩展和修改不同订单状态的处理行为，同时避免了原始代码的大泥球结构。</p><h3 id="领域驱动设计"><a href="#领域驱动设计" class="headerlink" title="领域驱动设计"></a>领域驱动设计</h3><p>从电商交易流程上来说有以下简单几步：</p><ol><li>用户在商品详情页面下单。</li><li>下单后用户进行支付。</li><li>支付后商家发货给用户。</li><li>用户收货后确认完成订单。</li><li>订单详情页展示订单、支付、物流信息。</li></ol><p>这个处理流程需要一整个系统的支持才能实现。其中每一步执行后都需要有后继行为和通知，这些通知可能是以站内的、短信的方式触达用户，或者通过一些机制发送给下游系统。这时候就涉及到一个决策，哪些是我交易系统的核心能力，哪些是外围能力。如果前期缺乏良好的架构设计，有可能演变成一个”大泥球”系统。</p><p><strong>为了避免系统的无序性演变，可以通过领域驱动设计的思想，识别交易领域核心行为，保护领域内部行为不被侵蚀，及领域内部行为是不变或者少变的。</strong></p><p>领域驱动设计提倡将软件系统划分为不同的层次，以便更好地组织和解耦系统的各个部分。在DDD中，常用的四层架构和对应职责如下：</p><p><strong>用户界面层（User Interface Layer）</strong>：</p><ul><li>负责展示商品详情页面，并接收用户的下单请求。</li><li>在下单后展示订单、支付和物流信息。</li></ul><p><strong>应用层（Application Layer）</strong>：</p><ul><li>接收用户界面层的请求，并进行必要的参数验证。</li><li>调用领域层的服务来处理下单、支付、发货和确认收货等操作。</li><li>提供查询服务，以获取订单、支付和物流信息。</li></ul><p><strong>领域层（Domain Layer）</strong>：</p><ul><li>定义订单（Order）实体，包含订单号、商品信息、支付信息、物流信息等属性，并处理与订单相关的业务逻辑。</li><li>实现下单、支付、发货和确认收货等操作的领域服务（OrderService）。</li><li>使用领域事件（Domain Event）来处理订单状态的变化，例如支付成功、发货操作等。</li></ul><p><strong>基础设施层（Infrastructure Layer）</strong>：</p><ul><li>实现与外部系统的交互，如支付服务、物流服务等。这些可以使用外部API或模拟实现。</li><li>提供持久化机制，用于存储订单、支付和物流信息。可以使用数据库或其他适合的持久化方式。</li></ul><p>下面是一个示意性的代码结构，用于展示不同层级及其职责：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- xxx-order-app</span><br><span class="line">  - UserInterface</span><br><span class="line">    - ProductDetailPage // 商品详情页面</span><br><span class="line">    - OrderDetailPage // 订单详情页面</span><br><span class="line">  - Application</span><br><span class="line">    - OrderApplicationService // 订单应用服务</span><br><span class="line">  - Domain</span><br><span class="line">    - Order // 订单实体</span><br><span class="line">    - OrderService // 订单领域服务</span><br><span class="line">    - Events // 领域事件</span><br><span class="line">  - Infrastructure</span><br><span class="line">    - PaymentService // 支付服务</span><br><span class="line">    - LogisticsService // 物流服务</span><br><span class="line">    - OrderRepository // 资源库</span><br></pre></td></tr></table></figure><p>在这个设计中，每个层级都有不同的职责和角色，以实现更好的代码结构和可维护性。用户界面层负责展示页面和处理用户输入，应用层负责协调各个领域服务的调用，领域层负责处理业务逻辑，基础设施层负责与外部系统的交互和数据持久化。</p><p>这样的设计可以更好地组织代码，使不同的职责分离，减少了耦合性，并且便于扩展和修改。同时，通过领域驱动设计，我们能够更好地表达业务领域的概念和规则，使代码更加贴近业务需求。</p><p>**用户界面层 (Presentation Layer)**：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderDetailPage</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> OrderApplicationService orderService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他属性和方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">displayOrderDetails</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">        <span class="comment">// 在订单详情页面展示物流信息、订单信息、支付信息</span></span><br><span class="line">        <span class="type">LogisticsInfo</span> <span class="variable">logisticsInfo</span> <span class="operator">=</span> orderService.getUpdatedLogisticsInfo(order);</span><br><span class="line">        <span class="comment">// 展示物流信息...</span></span><br><span class="line"></span><br><span class="line">        <span class="type">OrderInfo</span> <span class="variable">orderInfo</span> <span class="operator">=</span> orderService.getOrderInfo(order);</span><br><span class="line">        <span class="comment">// 展示订单信息...</span></span><br><span class="line"></span><br><span class="line">        <span class="type">PaymentInfo</span> <span class="variable">paymentInfo</span> <span class="operator">=</span> orderService.getPaymentInfo(order);</span><br><span class="line">        <span class="comment">// 展示支付信息...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用户操作事件响应</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">payOrder</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">        orderService.payOrder(order);</span><br><span class="line">        displayOrderDetails(order);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shipOrder</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">        orderService.shipOrder(order);</span><br><span class="line">        displayOrderDetails(order);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completeOrder</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">        orderService.completeOrder(order);</span><br><span class="line">        displayOrderDetails(order);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**应用层 (Application Layer)**：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderApplicationService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> OrderRepository orderRepository;</span><br><span class="line">    <span class="keyword">private</span> PaymentService paymentService;</span><br><span class="line">    <span class="keyword">private</span> LogisticsService logisticsService;</span><br><span class="line">    <span class="keyword">private</span> NotificationService notificationService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他属性和构造方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">payOrder</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">        paymentService.processPayment(order);</span><br><span class="line">        order.markAsPaid();</span><br><span class="line">        orderRepository.save(order);</span><br><span class="line">        notificationService.notifyOrderPaid(order);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shipOrder</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">        order.markAsShipped();</span><br><span class="line">        orderRepository.save(order);</span><br><span class="line">        notificationService.notifyOrderShipped(order);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completeOrder</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">        order.markAsCompleted();</span><br><span class="line">        orderRepository.save(order);</span><br><span class="line">        notificationService.notifyOrderCompleted(order);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> LogisticsInfo <span class="title function_">getUpdatedLogisticsInfo</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> logisticsService.queryLogisticsInfo(order.getShippingAddress());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> OrderInfo <span class="title function_">getOrderInfo</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OrderInfo</span>(order.getOrderNumber(), order.getOrderItems(), order.getTotalAmount());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> PaymentInfo <span class="title function_">getPaymentInfo</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> paymentService.getPaymentInfo(order.getPaymentId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**领域层 (Domain Layer)**：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String orderNumber;</span><br><span class="line">    <span class="keyword">private</span> List&lt;OrderItem&gt; orderItems;</span><br><span class="line">    <span class="keyword">private</span> BigDecimal totalAmount;</span><br><span class="line">    <span class="keyword">private</span> OrderStatus status;</span><br><span class="line">    <span class="keyword">private</span> String paymentId;</span><br><span class="line">    <span class="keyword">private</span> Address shippingAddress;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他属性和构造方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">markAsPaid</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (status == OrderStatus.UNPAID) &#123;</span><br><span class="line">            status = OrderStatus.PAID;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">markAsShipped</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (status == OrderStatus.PAID) &#123;</span><br><span class="line">            status = OrderStatus.SHIPPED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">markAsCompleted</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (status == OrderStatus.SHIPPED) &#123;</span><br><span class="line">            status = OrderStatus.COMPLETED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其他方法和领域业务规则</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**基础设施层 (Infrastructure Layer)**：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderRepository</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(Order order)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DatabaseOrderRepository</span> <span class="keyword">implements</span> <span class="title class_">OrderRepository</span> &#123;</span><br><span class="line">    <span class="comment">// 实现 OrderRepository 接口，利用数据库来保存订单信息</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PaymentService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">processPayment</span><span class="params">(Order order)</span>;</span><br><span class="line">    PaymentInfo <span class="title function_">getPaymentInfo</span><span class="params">(String paymentId)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExternalPaymentService</span> <span class="keyword">implements</span> <span class="title class_">PaymentService</span> &#123;</span><br><span class="line">    <span class="comment">// 实现 PaymentService 接口，与第三方支付接口进行交互处理订单支付</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LogisticsService</span> &#123;</span><br><span class="line">    LogisticsInfo <span class="title function_">queryLogisticsInfo</span><span class="params">(Address address)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExternalLogisticsService</span> <span class="keyword">implements</span> <span class="title class_">LogisticsService</span> &#123;</span><br><span class="line">    <span class="comment">// 实现 LogisticsService 接口，与物流查询接口进行交互查询物流信息</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">NotificationService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">notifyOrderPaid</span><span class="params">(Order order)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">notifyOrderShipped</span><span class="params">(Order order)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">notifyOrderCompleted</span><span class="params">(Order order)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmailNotificationService</span> <span class="keyword">implements</span> <span class="title class_">NotificationService</span> &#123;</span><br><span class="line">    <span class="comment">// 实现 NotificationService 接口，通过邮件发送订单通知</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>从上述代码中我们可以看到，基础设施层和领域层设计符合依赖倒置原则，从调用关系看领域层调用基础设施层进行数据的交互，而从依赖关系来看，领域层依赖于领域抽象，不依赖于具体实现，DDD 的精髓在于保护核心领域的自治性，降低层间的偶合度，同时有助于遵循单一职责原则，关注领域核心行为的管理和维护。</strong></p><h3 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h3><p><strong>这篇文章在这里第一次直面架构，讨论的问题是软件架构（architecture）究竟是什么？从我的经验总结，是站在更高的层次去整体分析软件系统，抓大放小，把握重点，重点是组织结构，而不论是子系统、模块、包，还是分层、服务等，都可以看作为一个”构件”，需要关注的是如何组织使整体高效有序。</strong></p><p>如果你要想理解它，可以从设计者的角度去审视，上面的方法从小到大逐层递进地讲了代码的组织形式，后面还要面临更多的复杂性问题，如当用户达到千万级规模，程序如何高效部署和管理，多人协作开发时如何做到高效。</p><p>微服务架构是一种软件架构风格，它将一个大型应用程序拆分为一组小型、独立的服务，每个服务都有自己的业务功能，并通过轻量级的通信机制进行交互。每个服务都可以独立开发、部署和扩展，从而提供了灵活性、可伸缩性和可维护性。有下面几个特点：</p><ol><li><p>拆分与自治性：应用程序被拆分为多个小型服务，每个服务关注于特定的业务功能。每个服务都是自治的，可以独立开发、部署和运行，使团队可以并行开发和部署不同的服务。</p></li><li><p>独立部署和扩展：由于每个服务都是独立的，可以根据需求独立部署和扩展。这种灵活性使得系统能够更好地应对高负载和变化的需求，同时减少了对整个应用的影响。</p></li><li><p>技术多样性：微服务架构允许使用不同的技术栈和编程语言来实现不同的服务。这使得团队可以选择最适合其需求的技术，提高开发效率和灵活性。</p></li><li><p>弹性和容错性：由于每个服务都是独立的，当一个服务出现故障时，其他服务仍然可以正常运行，从而提高系统的弹性和容错性。</p></li><li><p>松耦合和可维护性：微服务通过轻量级的通信机制（如RESTful API或消息队列）进行交互，服务之间的耦合度较低。这使得系统更易于理解、修改和维护。</p></li><li><p>团队自治和快速交付：每个服务都可以由独立的团队负责开发和维护，团队可以根据自己的需求和进度进行快速交付。这种团队自治的方式促进了敏捷开发和持续交付的实践。</p></li></ol><p>然而，微服务架构也带来了一些挑战，如服务间通信的复杂性、分布式事务管理、服务发现和监控等。在采用微服务架构时，需要仔细权衡利弊，并根据具体的业务需求和团队能力做出决策。微服务更多是关于组织和团队，而不是技术。</p><p>这里必须要谈一下康威定律：Conway’s law: Organizations which design systems[…] are constrained to produce designs which are copies of the communication structures of these organizations.<br>（设计系统的组织，其产生的设计和架构等价于组织间的沟通结构。）</p><p>简单来说，这意味着一个组织的沟通和组织结构会直接影响到所开发的软件系统的结构。</p><p><img src="/resource/img/2024-02-14-22-37-19.png"></p><ol><li><p>组织结构：组织内部的团队结构、沟通渠道和决策层级等因素会直接影响到软件系统的设计。</p></li><li><p>沟通结构：组织内部团队之间的沟通方式和频率会反映在系统设计中。如果团队之间的沟通不畅或存在壁垒，那么系统的设计可能会反映出这种分隔和隔离。</p></li><li><p>系统结构：根据康威定律，软件系统的结构往往会与组织结构相似。如果组织结构是分散的，那么系统的结构可能会呈现出分散的特征；如果组织结构是集中的，那么系统的结构可能会呈现出集中的特征。</p></li></ol><p>康威定律的应用意义在于，通过理解组织结构和沟通结构对系统设计的影响，可以更好地规划和调整组织结构，以促进系统的设计和开发。例如，如果希望实现松耦合和模块化的系统，可以通过优化团队之间的沟通和协作方式来达到这个目标。</p><hr><p><strong>总结</strong></p><p>这篇文章整理了近几年的关于治理系统复杂性的一些经验，主要包括概念介绍、度量方式、设计原则、治理方法几个方面去介绍。其中治理方法部分由浅入深的介绍了几个方式，不同方式面临的问题复杂程度也是不同的。这些方式通过不同的角度帮助我们管理软件复杂度，提高代码的可维护性和可扩展性，确保软件系统与业务需求紧密结合。管理软件复杂性是软件开发过程中非常重要的一环，不论面对何种问题，“简单，易于理解”都应该是我们要坚持的方向。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/resource/img/2024-02-14-23-36-09.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;本文讨论了软件复杂性及其产生原因，介绍了如何度量软件复杂性，及 SOLID 软件设计原则，并探讨管理复杂性的方法，包括使用代码重构、设计模式、领域驱动设计等。通过遵循这些原则和方法，开发人员可以降低软件复杂性，提高代码质量和可维护性。这篇文章内容涵盖了软件开发的道与术，希望能对你所有帮助，欢迎评论交流～&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;什么是软件复杂性&lt;/li&gt;
&lt;li&gt;软件复杂性产生原因&lt;/li&gt;
&lt;li&gt;如何度量软件复杂性&lt;/li&gt;
&lt;li&gt;SOLID 软件设计原则&lt;/li&gt;
&lt;li&gt;管理复杂性的方法&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>服务拆分的几种处理思路</title>
    <link href="https://noogel.xyz/2022/11/24/1.html"/>
    <id>https://noogel.xyz/2022/11/24/1.html</id>
    <published>2022-11-24T00:00:00.000Z</published>
    <updated>2025-07-23T07:30:58.916Z</updated>
    
    <content type="html"><![CDATA[<h2 id="场景说明"><a href="#场景说明" class="headerlink" title="场景说明"></a>场景说明</h2><p>目标是需要拆分出内部服务 Y 为独立的系统，且暂时不改变系统 A 的被依赖关系，拆分前的情况如下图。</p><p>这里假定两个接口层处理模块只会调用只会调用内部服务 Y，并且其中存在着业务逻辑，也许你会疑惑接口层为什么会有业务逻辑，事实上你大多数情况下会遇到。更具体的说，接口层的业务接口 1 中包含业务逻辑，于是会产生对内部服务 Y 的两个及以上接口的调用。</p><p><img src="/resource/img/2022-11-24-01-56-42.png"></p><h2 id="处理思路"><a href="#处理思路" class="headerlink" title="处理思路"></a>处理思路</h2><p>那么你会遇到以下几种情况需要处理。</p><span id="more"></span><p><strong>针对 case 1 的 RPC 接口逻辑两种处理方式：</strong></p><ol><li>左图：拷贝 rpc 协议在系统 B 实现逻辑搬迁，系统 A 只有接口层，且只有对象转换，无任何逻辑。</li><li>右图：基于内部服务 Y 接口定义，迁移服务层逻辑到系统 B ，实现基于 BizDto  定义的 rpc 接口，系统 A 在接口层保留业务逻辑，只需要增加 BizDto  到 BizThriftVo2 对象的转换。</li></ol><p><img src="/resource/img/2022-11-24-01-56-59.png"></p><p><strong>针对 case2 的 HTTP 接口逻辑也有两种处理方式：</strong></p><ol><li>左图：同样，基于内部服务 Y 接口定义，迁移服务层逻辑到系统 B ，实现基于 BizDto  定义的 rpc 接口，系统 A 在接口层保留业务逻辑，只需要增加 BizDto  到 BizThriftVo2 对象的转换。</li><li>右图：拷贝 http 协议在系统 B 实现逻辑搬迁，BizThriftVo3 基于 BizHttpVo  定义，系统 A 只有接口层，且只有对象转换，无任何逻辑。</li></ol><p><img src="/resource/img/2022-11-24-01-57-09.png"></p><p><strong>针对 case 3 的内部服务调用：</strong></p><p>对于内部服务调用，基于内部服务 Y 接口定义，迁移服务层逻辑到系统 B ，实现基于 BizDto  定义的 rpc 接口，系统 A 只需要增加 BizDto  到 BizThriftVo2 对象的转换。</p><p>对 内部服务 X 调 Y 的场景下，需要注意其中是否包含事务型依赖关系。因为如果从本地调用改为远程调用可能会破坏整个事务的完整性，产生数据不一致。</p><p><img src="/resource/img/2022-11-24-01-57-20.png"></p><h2 id="更优解"><a href="#更优解" class="headerlink" title="更优解"></a>更优解</h2><p>如果我们要拆分内部服务 Y，从上游的依赖来看，有系统 A 和手机客户端的依赖关系（通过虚线表示）。</p><p><img src="/resource/img/2022-11-24-01-57-28.png"></p><p>如果我们不考虑上下游依赖关系，就会和上面说的几种情况一样处理，这时候系统 B 的 RPC 接口层就只是一层很薄的代理，存在的问题是资源的浪费和服务稳定性的打折扣，而且你还要写比较多的胶水代码。而更优的一种方式是消除这种传递依赖，使系统 A 和系统 B 解耦，使系统 C 的功能更内聚，每个系统只负责自己对象和 BizThriftVo  对象的转换。</p><p><img src="/resource/img/2022-11-24-01-57-38.png"></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;场景说明&quot;&gt;&lt;a href=&quot;#场景说明&quot; class=&quot;headerlink&quot; title=&quot;场景说明&quot;&gt;&lt;/a&gt;场景说明&lt;/h2&gt;&lt;p&gt;目标是需要拆分出内部服务 Y 为独立的系统，且暂时不改变系统 A 的被依赖关系，拆分前的情况如下图。&lt;/p&gt;
&lt;p&gt;这里假定两个接口层处理模块只会调用只会调用内部服务 Y，并且其中存在着业务逻辑，也许你会疑惑接口层为什么会有业务逻辑，事实上你大多数情况下会遇到。更具体的说，接口层的业务接口 1 中包含业务逻辑，于是会产生对内部服务 Y 的两个及以上接口的调用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/resource/img/2022-11-24-01-56-42.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;处理思路&quot;&gt;&lt;a href=&quot;#处理思路&quot; class=&quot;headerlink&quot; title=&quot;处理思路&quot;&gt;&lt;/a&gt;处理思路&lt;/h2&gt;&lt;p&gt;那么你会遇到以下几种情况需要处理。&lt;/p&gt;</summary>
    
    
    
    
    <category term="架构" scheme="https://noogel.xyz/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>关于读写分离架构的思考</title>
    <link href="https://noogel.xyz/2022/04/12/1.html"/>
    <id>https://noogel.xyz/2022/04/12/1.html</id>
    <published>2022-04-12T00:00:00.000Z</published>
    <updated>2025-07-23T07:30:58.916Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>分布式系统主要的目的之一就是解决大量用户的高并发问题。自己做过几个业务系统，也和别人聊过他们所做过的业务系统，其实大家都使用了相同的数据库，有的系统会使用 Redis 缓存，会使用 MQ 做系统解耦，有的也会使用搜索引擎。这些系统的构件相同的地方都是在处理数据，只不过职责不同罢了。归纳有以下几类：</p><ul><li>数据库提供结构化的持久保证。</li><li>缓存为了提高并发和响应速度。</li><li>MQ 带着事件消息将后续任务解耦。</li><li>搜索引擎提供快速的全文检索能力。</li></ul><p>以上这几个构件就可以组成相对完备的实时数据系统，可以应对常见的业务需求。</p><h2 id="数据框架"><a href="#数据框架" class="headerlink" title="数据框架"></a>数据框架</h2><p>关于一个业务系统的通用数据框架可以用下面的图来表述。</p><span id="more"></span><p><img src="/resource/img/2022-04-14-01-40-41.png"></p><p>关于整个框架的运行方式可以简单的从读和写两个角度来看。</p><p>从写的角度来看，首先需要保证数据被正确处理和持久化，处理完主存数据，需要发送事件消息到 MQ，然后将数据同步到高速缓存和搜索引擎，整个流程是需要满足事务性。<br>从读的角度来看，需要面临的主要问题是和主存的一致性问题，一般保证弱一致性即可。读数据的简化流程是先读缓存，读不到读数据库，再回填缓存。</p><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>而各式各样业务功能和逻辑对数据的处理都归为两种操作——读和写，只是不同的系统侧重点不同，主要分为以下几类：</p><ul><li>『读多写少』的系统<ul><li>百度搜索</li><li>电商商品搜索</li></ul></li><li>『写多读少』的系统<ul><li>广告计费系统</li><li>双十一的支付系统</li></ul></li><li>『读多写多』的系统<ul><li>电商秒杀</li><li>新浪微博</li></ul></li></ul><h2 id="处理思路"><a href="#处理思路" class="headerlink" title="处理思路"></a>处理思路</h2><h3 id="高并发读"><a href="#高并发读" class="headerlink" title="高并发读"></a>高并发读</h3><p>首先说说『读多』的解决方案，最常见的是用户到服务器之间的多级缓存策略（也许描述的不够准确，可以继续往下看），从服务端到用户逐层递进有以下几种：</p><ol><li>分布式缓存</li><li>内存缓存</li><li>CDN 缓存</li><li>客户端缓存</li></ol><p>从上到下，缓存越接近用户对服务器的压力约小，访问速度越快，弊端是一致性的处理越不可控，机器成本和问题排查成本越高。</p><p>从数据变化角度来看可以分为动态内容和静态内容，动态内容可以根据业务需要采用分布式缓存和内存缓存的方式，可以通过设置过期时间来自动刷新。静态内容可以通过 CDN 和客户端缓存的方式，一般是一些图片、HTML、CSS、JS 文件。</p><p>缓存的更新方式可以分为推和拉两种形式。缓存常见的三个问题略过。</p><p>第二种策略是串行读改并行，对于用户的一个请求，如果需要三个外部依赖，耗时分别是 T1\T2\T3。如果是串行化调用总耗时是 T1+T2+T3，在三者没有耦合关系的情况下，改成异步执行的总耗时为 Max(T1, T2, T3)。</p><p>第三种策略是批量请求，通过缓存或存储提供的批量命令，可以将单次读写请求改为批量请求，可以减少网络传输的总耗时。</p><h3 id="高并发写"><a href="#高并发写" class="headerlink" title="高并发写"></a>高并发写</h3><p>对于『写多』的解决方案，最常见的解决思路是对于<strong>数据分片</strong>，比如现实世界的高速多车道，医院的多诊室，以此来提升整体的吞吐量。在服务端比较常见的是数据库层面的分库分表，通过合理的分片算法，将数据尽量均匀的分散在不同的库表，通过分库可以利用起多台机器的资源。</p><p>除此之外，数据分片的设计策略还在其它方面有所体现：</p><ul><li>Kafka 的多个 Partition 的设计。</li><li>ConcurrentHashMap 中 HashEntry 和 Segment 设计。</li></ul><p>第二种策略是<strong>任务分片</strong>，将一个大任务拆分成若干子任务执行。你可能会立刻想到 CPU 的指令流水线，一条指令分为取指、译码、执行、访存、写回五个阶段，单条指令占用 5 个时间周期，每增加一条指令整体只需要再增加 1 个时间周期。</p><p><img src="/resource/img/2022-04-14-01-41-17.png"></p><p>这些策略使用的就是分治思想，耳熟能详的就是 Map&#x2F;Reduce 了，在 Java 中 ForkJoinPool 也是利用这一思想设计。</p><p><strong>分治</strong>从字面上也很容易理解，分、治其实还有个合并的过程：</p><ul><li>分(Divide)：递归解决较小的问题(到终止层或者可以解决的时候停下)。</li><li>治(Conquer)：递归求解，如果问题够小直接求解。</li><li>合并(Combine)：将子问题的解合并得到父类问题解。</li></ul><p>第三种策略是队列缓冲，如果请求量超过系统最大负载，可以放到 MQ 异步化处理请求，这时需要客户端支持异步结果响应。秒杀场景就可以将瞬时大量用户请求放到消息中间件，由服务端慢慢消费，再异步通知用户。</p><p>第四种策略是批量写。</p><h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><p>根据数据的访问特点，上面提到的各种策略本质上是读写分离，是微服务架构中提到的 CQRS。关于读写分离模式一般具有以下特征：</p><ol><li>读和写设计的数据结构不同，为系统的读和写分别设计两个视图，设计适合高并发场景的数据结构和模型。</li><li>写数据通过数据库的分库分表来提高并发能力，然后异步写入缓存来提高读并发能力。通过异步写入搜索引擎来实现全文搜索。</li><li>因为缓存和搜索引擎是异步写入的，所以读到变更后的数据会有一定延迟，保障最终一致性，而非强一致性。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>回到最上面总结的数据框架，实现一个高并发系统所需的主要数据构件有缓存、数据库、搜索引擎、消息队列，以读和写两个视角将用户的大量请求分流到不同地方处理，然后通过多副本的方式对数据构件水平扩容，这本身也是一种分治思想。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;分布式系统主要的目的之一就是解决大量用户的高并发问题。自己做过几个业务系统，也和别人聊过他们所做过的业务系统，其实大家都使用了相同的数据库，有的系统会使用 Redis 缓存，会使用 MQ 做系统解耦，有的也会使用搜索引擎。这些系统的构件相同的地方都是在处理数据，只不过职责不同罢了。归纳有以下几类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据库提供结构化的持久保证。&lt;/li&gt;
&lt;li&gt;缓存为了提高并发和响应速度。&lt;/li&gt;
&lt;li&gt;MQ 带着事件消息将后续任务解耦。&lt;/li&gt;
&lt;li&gt;搜索引擎提供快速的全文检索能力。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上这几个构件就可以组成相对完备的实时数据系统，可以应对常见的业务需求。&lt;/p&gt;
&lt;h2 id=&quot;数据框架&quot;&gt;&lt;a href=&quot;#数据框架&quot; class=&quot;headerlink&quot; title=&quot;数据框架&quot;&gt;&lt;/a&gt;数据框架&lt;/h2&gt;&lt;p&gt;关于一个业务系统的通用数据框架可以用下面的图来表述。&lt;/p&gt;</summary>
    
    
    
    
    <category term="架构" scheme="https://noogel.xyz/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>统一博客系统变更日志</title>
    <link href="https://noogel.xyz/2022/04/10/1.html"/>
    <id>https://noogel.xyz/2022/04/10/1.html</id>
    <published>2022-04-10T00:00:00.000Z</published>
    <updated>2025-07-23T07:30:58.915Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇文章是汇总历史发布过的，所有关于我的博客编写发布系统文章。文章以时间线倒序的方式罗列整理。</p><h2 id="2022-04-07-博客主题必备功能"><a href="#2022-04-07-博客主题必备功能" class="headerlink" title="2022-04-07 博客主题必备功能"></a>2022-04-07 博客主题必备功能</h2><ol><li>支持数学公式</li><li>支持 mermaid 流程图</li><li>支持标准的 Markdown</li></ol><p><a href="/2022/04/07/1.html">测试页面</a></p><h2 id="2022-02-13-统一博客编写环境"><a href="#2022-02-13-统一博客编写环境" class="headerlink" title="2022-02-13 统一博客编写环境"></a>2022-02-13 统一博客编写环境</h2><p>日常会在 macOS 和 Ubuntu 之间切换，博客是基于 Hexo 生成的，不同系统的 Node 版本会有较大差异、环境稳定性比较差，为了方便平时写博客，想到了用 Docker 统一博客生成环境，于是自己写了 Dockerfile，在结合 VS Code 编写，可以做到系统无差。</p><p><img src="/resource/img/2022-02-13-21-39-39.png"></p><p>日常开发只需要在 VS Code 中边写边预览，图片是通过 PasteImage 插件快捷键插入。预览和发布只需要以下两个命令即可。</p><p>预览本地博客：<code>alias run-blog=&#39;docker exec -it container_id python utils/goto.py blog&#39;</code></p><p>发布博客文章：<code>alias push-blog=&#39;docker exec -it container_id python utils/goto.py push&#39;</code></p><p>Docker 项目：<a href="https://github.com/noogel/noogel.github.io.docker">https://github.com/noogel/noogel.github.io.docker</a></p><span id="more"></span><h2 id="2020-04-05-VS-Code-与-HEXO-结合写博客"><a href="#2020-04-05-VS-Code-与-HEXO-结合写博客" class="headerlink" title="2020-04-05 VS Code 与 HEXO 结合写博客"></a>2020-04-05 VS Code 与 HEXO 结合写博客</h2><p>在 mac 机器上可以使用 mweb 来写博客，比较好用的地方就是可以直接把剪贴板的图片粘贴上来，缺点是 mac 键盘超难用并且不支持窗口内开启命令行。平时在家的时候都用 Ubuntu 台式机，博客使用 VS Code 编写，一直以来阻挡我的是图片的粘贴特别费劲，今天发现一个很好用的插件 pasteimage，可以直接将剪贴板图片粘贴到 markdown 使用，并且支持配置保存路径。</p><p><img src="/resource/img/2020-04-05-15-57-27.png"></p><p>然后按照教程配置好参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;pasteImage.path&quot;: &quot;$&#123;projectRoot&#125;/source/resource/img&quot;,</span><br><span class="line">    &quot;pasteImage.basePath&quot;: &quot;$&#123;projectRoot&#125;/source&quot;,</span><br><span class="line">    &quot;pasteImage.forceUnixStyleSeparator&quot;: true,</span><br><span class="line">    &quot;pasteImage.prefix&quot;: &quot;/&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就可以直接将图片粘贴到 markdown 中，其中遇到个问题就是配置不生效，会导致文件直接保存到当前文件目录，具体配置方法可以参考下面连接。</p><blockquote><p><a href="https://www.crifan.com/vscode_how_to_config_setting_plugin/">https://www.crifan.com/vscode_how_to_config_setting_plugin/</a>  这篇文章写的很详细了。<br><a href="https://github.com/mushanshitiancai/vscode-paste-image">https://github.com/mushanshitiancai/vscode-paste-image</a> 这篇是配置教程，里面有些地方比较容易被误导。</p></blockquote><p>对于Linux系统需要有 xclip 支持，使用的时候会给提示的。</p><p><img src="/resource/img/2020-04-05-16-03-56.png"></p><p>另外记录一下 Ubuntu 的截屏和粘贴快捷键：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + Shift + Print Screen  // 区域截屏到剪贴板</span><br><span class="line">Ctrl + Alt + s  // 在 VS Code 中粘贴</span><br></pre></td></tr></table></figure><h2 id="2019-10-27-基本的照片脱敏处理"><a href="#2019-10-27-基本的照片脱敏处理" class="headerlink" title="2019-10-27 基本的照片脱敏处理"></a>2019-10-27 基本的照片脱敏处理</h2><p>我们平时拍照的照片中会包含很多额外信息可能暴露我们的地理位置、拍摄数据、拍照时间等信息。在一些网站上传原图时会暴露这些敏感信息，这个脚本主要用来通过 pillow 库将照片的 exif 信息抹掉。</p><p><img src="/resource/img/carbon_desensitize.png"></p><p>其它校验网站： <a href="https://exif.tuchong.com/">https://exif.tuchong.com/</a></p><p>通过这个网站也可以查看这些额外信息：</p><p><img src="/resource/img/15721576232055.jpg"></p><h2 id="2017-12-06-MWeb-与-HEXO-结合写博客"><a href="#2017-12-06-MWeb-与-HEXO-结合写博客" class="headerlink" title="2017-12-06 MWeb 与 HEXO 结合写博客"></a>2017-12-06 MWeb 与 HEXO 结合写博客</h2><p>『MWeb 是 Mac 平台上一款专业的 Markdown 写作、记笔记、静态博客生成软件。』主要有以下几个优点：</p><ol><li>拖入图片即所见。</li><li>可以边写边展示。</li><li>再配合开发的Python处理脚本可以一行命令自动保存发布。</li></ol><p><img src="/resource/img/1505966065271.jpg" alt="1505966065271"></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这篇文章是汇总历史发布过的，所有关于我的博客编写发布系统文章。文章以时间线倒序的方式罗列整理。&lt;/p&gt;
&lt;h2 id=&quot;2022-04-07-博客主题必备功能&quot;&gt;&lt;a href=&quot;#2022-04-07-博客主题必备功能&quot; class=&quot;headerlink&quot; title=&quot;2022-04-07 博客主题必备功能&quot;&gt;&lt;/a&gt;2022-04-07 博客主题必备功能&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;支持数学公式&lt;/li&gt;
&lt;li&gt;支持 mermaid 流程图&lt;/li&gt;
&lt;li&gt;支持标准的 Markdown&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&quot;/2022/04/07/1.html&quot;&gt;测试页面&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;2022-02-13-统一博客编写环境&quot;&gt;&lt;a href=&quot;#2022-02-13-统一博客编写环境&quot; class=&quot;headerlink&quot; title=&quot;2022-02-13 统一博客编写环境&quot;&gt;&lt;/a&gt;2022-02-13 统一博客编写环境&lt;/h2&gt;&lt;p&gt;日常会在 macOS 和 Ubuntu 之间切换，博客是基于 Hexo 生成的，不同系统的 Node 版本会有较大差异、环境稳定性比较差，为了方便平时写博客，想到了用 Docker 统一博客生成环境，于是自己写了 Dockerfile，在结合 VS Code 编写，可以做到系统无差。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/resource/img/2022-02-13-21-39-39.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;日常开发只需要在 VS Code 中边写边预览，图片是通过 PasteImage 插件快捷键插入。预览和发布只需要以下两个命令即可。&lt;/p&gt;
&lt;p&gt;预览本地博客：&lt;code&gt;alias run-blog=&amp;#39;docker exec -it container_id python utils/goto.py blog&amp;#39;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;发布博客文章：&lt;code&gt;alias push-blog=&amp;#39;docker exec -it container_id python utils/goto.py push&amp;#39;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Docker 项目：&lt;a href=&quot;https://github.com/noogel/noogel.github.io.docker&quot;&gt;https://github.com/noogel/noogel.github.io.docker&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="效率" scheme="https://noogel.xyz/tags/%E6%95%88%E7%8E%87/"/>
    
    <category term="HEXO" scheme="https://noogel.xyz/tags/HEXO/"/>
    
    <category term="Docker" scheme="https://noogel.xyz/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Markdown 语法模板</title>
    <link href="https://noogel.xyz/2022/04/07/1.html"/>
    <id>https://noogel.xyz/2022/04/07/1.html</id>
    <published>2022-04-07T00:00:00.000Z</published>
    <updated>2025-07-23T07:30:58.915Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础语法示例"><a href="#基础语法示例" class="headerlink" title="基础语法示例"></a>基础语法示例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># H1</span><br><span class="line">## H2</span><br><span class="line">### H3</span><br><span class="line">#### H4</span><br><span class="line">##### H5</span><br><span class="line">###### H6</span><br></pre></td></tr></table></figure><blockquote><p>引用</p></blockquote><ul><li>无序列表</li><li>无序列表</li><li>无序列表</li></ul><ol><li>有序列表</li><li>有序列表</li><li>有序列表</li></ol><p><em>斜体</em></p><p><strong>粗体</strong></p><p><code>行内代码</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">多行代码</span><br><span class="line">多行代码</span><br></pre></td></tr></table></figure><p>分割线：</p><hr><h2 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$d=\sqrt&#123;\sum_&#123;k=1&#125;^n(x\_&#123;1k&#125;-x\_&#123;2k&#125;)^2&#125;$$</span><br></pre></td></tr></table></figure><p>效果：</p><p>$$d&#x3D;\sqrt{\sum_{k&#x3D;1}^n(x_{1k}-x_{2k})^2}$$</p><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><pre class="mermaid">sequenceDiagram    老板C ->> 员工C : 开始实行996        par 并行        员工C ->> 员工C : 刷微博    and        员工C ->> 员工C : 工作    and        员工C ->> 员工C : 刷朋友圈    end        员工C -->> 老板C : 9点下班</pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基础语法示例&quot;&gt;&lt;a href=&quot;#基础语法示例&quot; class=&quot;headerlink&quot; title=&quot;基础语法示例&quot;&gt;&lt;/a&gt;基础语法示例&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=</summary>
      
    
    
    
    
    <category term="模板" scheme="https://noogel.xyz/tags/%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>架构设计的 ROI 关注点</title>
    <link href="https://noogel.xyz/2022/03/29/1.html"/>
    <id>https://noogel.xyz/2022/03/29/1.html</id>
    <published>2022-03-29T00:00:00.000Z</published>
    <updated>2025-07-23T07:30:58.916Z</updated>
    
    <content type="html"><![CDATA[<p>ROI 是指投资回报率，对应系统架构设计上来说需要从业务发展和收益角度综合评估 ROI 来进行取舍。需要确保架构符合业务的发展，在设计开发时需要重点关注一下几个地方：</p><ol><li>系统迭代需求的提出。<ul><li>为了满足业务需求</li><li>为了解决系统问题<ul><li>需要收集系统问题，找出核心问题。</li></ul></li></ul></li><li>提出设计方案。<ul><li>明确核心价值，解决了什么样的关键问题、系统难点、业务需求。</li><li>实现成本<ul><li>复杂度，实现设计方案的复杂度是否可以接受。<ul><li>技术复杂度，系统的并发性、可用性、一致性要求。</li><li>业务复杂度，对于业务需求的支持程度。</li></ul></li><li>人力成本，是否满足各方对人力消耗和时间节点上的要求。</li></ul></li><li>设计的局限性<ul><li>可量化指标，项目的结果是否可以被量化，被观测到。</li><li>可测试性，测试的覆盖度能到多少，QA 的测试成本有多少。</li><li>可扩展性，下一次迭代可以降低多少成本。</li></ul></li></ul></li><li>评估产出收益，项目的价值。<ul><li>人力节省</li><li>机器节省</li><li>收入提升</li><li>流量提升</li></ul></li></ol><p>按照上述清单可以在进行架构设计时进行思维训练，同时不要局限于清单，做到动态调整。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;ROI 是指投资回报率，对应系统架构设计上来说需要从业务发展和收益角度综合评估 ROI 来进行取舍。需要确保架构符合业务的发展，在设计开发时需要重点关注一下几个地方：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;系统迭代需求的提出。&lt;ul&gt;
&lt;li&gt;为了满足业务需求&lt;/li&gt;
&lt;li&gt;为了解</summary>
      
    
    
    
    
    <category term="架构" scheme="https://noogel.xyz/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>技术项目复盘经验</title>
    <link href="https://noogel.xyz/2022/03/14/1.html"/>
    <id>https://noogel.xyz/2022/03/14/1.html</id>
    <published>2022-03-14T00:00:00.000Z</published>
    <updated>2025-07-23T07:30:58.918Z</updated>
    
    <content type="html"><![CDATA[<p>基于多次复盘的经验汇总，仅以当前工作环境做汇总，供参考。</p><ol><li>系统问题定位和解决<ul><li>需要抓住足够多的证据链，不能臆测代码和运行机制。常用手段有 curl，日志，sentry。</li><li>能在本地复现不要跑到联调，降低定位成本。</li><li>排查超过两小时并且无清晰路径下需要扩大问题知晓范围，找人协助。</li><li>排查过程需要有详尽的记录，记录要字符串，减少截图数据。</li></ul></li><li>RFC 设计<ul><li>跨系统交互需要补充系统交互图，明确系统边界。</li><li>需要数据备份和回滚方案，做好预案。</li><li>设计文档需要同步小组群。</li><li>评审会需要拉上 leader 知晓。</li><li>系统设计需要考虑兼容性和可观测性。</li><li>需求项目要建立人员 backup 机制。</li></ul></li><li>系统开发<ul><li>迁移是迁移，不要做重构，保证功能原样，同时也会降低测试成本。</li><li>警惕复制代码的行为，必须知晓你提交代码的逻辑和背后含义。</li><li>对于复杂逻辑和接口需要有详尽的注释，或者粘贴 wiki 链接说明设计。</li><li>新系统设计需要维护起测试用例，保证单测覆盖度，降低测试成本。</li></ul></li><li>联调和沟通效率<ul><li>重大项目和长耗时，需要考虑拉站会或者小黑屋。</li><li>能群聊的不要私聊，扩大内容的知晓范围。</li><li>并行工作需要分时间块，避免碎片化时间并行。</li><li>遇到人力合作问题，需要及时升级到 leader 支持。</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;基于多次复盘的经验汇总，仅以当前工作环境做汇总，供参考。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;系统问题定位和解决&lt;ul&gt;
&lt;li&gt;需要抓住足够多的证据链，不能臆测代码和运行机制。常用手段有 curl，日志，sentry。&lt;/li&gt;
&lt;li&gt;能在本地复现不要跑到联调，降低定位成本。&lt;/</summary>
      
    
    
    
    
    <category term="软技能" scheme="https://noogel.xyz/tags/%E8%BD%AF%E6%8A%80%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>技术面试的一点经验</title>
    <link href="https://noogel.xyz/2022/03/05/1.html"/>
    <id>https://noogel.xyz/2022/03/05/1.html</id>
    <published>2022-03-05T00:00:00.000Z</published>
    <updated>2025-07-23T07:30:58.918Z</updated>
    
    <content type="html"><![CDATA[<h2 id="技术面试看什么"><a href="#技术面试看什么" class="headerlink" title="技术面试看什么"></a>技术面试看什么</h2><ol><li>流畅的表达能力和清晰的逻辑分析能力。</li><li>比较扎实的基础知识和技术学习热情。</li><li>问题发现和推动解决问题的能力。</li><li>丰富的项目经验积累和架构规划能力。</li></ol><h2 id="优秀候选人的一些品质"><a href="#优秀候选人的一些品质" class="headerlink" title="优秀候选人的一些品质"></a>优秀候选人的一些品质</h2><ol><li>对于所了解的技术知识理解的很透彻，从语言描述上能够表达准确、有逻辑、有调理。<ul><li>表达中不会有『这个』『那个』『嗯』『啊』的语气词和停顿。</li><li>对于项目问题的解答，主动阐述项目背景，问题现状，做了什么，产生什么样的收益。</li><li>优先说出答案的关键 123，再展开举例说明，是一种清晰有效的表达方式。</li></ul></li><li>从技术底层知识上，对于一些相对关键的技术知识能够灵活掌握，能从技术前世今生很顺畅的表达出来。</li><li>实践能力上，候选人对于理论的了解不仅停留在书面上，而是动手实现一个技术理论。</li></ol><h2 id="技术面试怎么做"><a href="#技术面试怎么做" class="headerlink" title="技术面试怎么做"></a>技术面试怎么做</h2><p>从工作经验来分，以三年为界，分为两类面试思路：</p><ol><li>越是经验丰富的候选人，可以提出一个比较模糊的问题，尽量让候选人来主导拆解这个过程。同时也要避免跑题浪费时间。</li><li>对于经验很少的候选人，则可以从基础性知识和具体的问题上展开，如果难度过高需要积极的给出提示和引导。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;技术面试看什么&quot;&gt;&lt;a href=&quot;#技术面试看什么&quot; class=&quot;headerlink&quot; title=&quot;技术面试看什么&quot;&gt;&lt;/a&gt;技术面试看什么&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;流畅的表达能力和清晰的逻辑分析能力。&lt;/li&gt;
&lt;li&gt;比较扎实的基础知识和技术学习热情</summary>
      
    
    
    
    
    <category term="招聘" scheme="https://noogel.xyz/tags/%E6%8B%9B%E8%81%98/"/>
    
  </entry>
  
  <entry>
    <title>macOS 系统 10 倍高效工具</title>
    <link href="https://noogel.xyz/2022/01/23/1.html"/>
    <id>https://noogel.xyz/2022/01/23/1.html</id>
    <published>2022-01-23T00:00:00.000Z</published>
    <updated>2025-07-23T07:30:58.915Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天要说的是 macOS 下的一款效率软件 —— Alfred，想必大家就算没用过也耳闻过，老实说用好它带来的效率提升绝对不止 10 倍。博主已经安利给很多同事使用，他们普遍觉得上手有些困难，主要是配置复杂，今天的文章会一步步地介绍这款神器的高效之处。</p><p>有的人可能会说系统自带的 Spotlight 就很好用，确实是这样。在之前我会用 Spotlight 搜应用、文件、进行计算等，而 Alfred 的功能更强大，是一款可以更加 All in 的效率工具，里面还有我最常用的剪贴板历史、快速网页搜索、谷歌二次口令扩展等功能，接下来我会逐一介绍。</p><span id="more"></span><h2 id="获取方式"><a href="#获取方式" class="headerlink" title="获取方式"></a>获取方式</h2><ol><li>从 Alfred 官网中下载并安装使用即可。<ul><li>免费用户只能使用其 Features 中的功能；若要使用 Workflows，则需要购买 Powerpack 才能激活此功能。</li></ul></li><li>若要试用 Workflows，可以自行搜索破解版，不过还是建议购买正版。</li></ol><h2 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h2><p>先说一说如何调出命令面板，在 General 中配置的 Alfred Hotkey 就是使用快捷键。如下图我配置的是 Command + Space。</p><p><img src="/resource/img/af03e406816350333a1b09b467b089b3.png" alt="af03e406816350333a1b09b467b089b3.png"></p><p>调出的样子是下面这样的，在框中输入内容即可，输入内容后就会展示响应结果，选中后回车执行对应的操作。执行的操作一般是打开浏览器网址，或者将结果复制到剪贴板。</p><p><img src="/resource/img/05af8ea7a69242ebf855f05649affc74.png" alt="05af8ea7a69242ebf855f05649affc74.png"></p><p><img src="/resource/img/d3bed623187b74071557d9f145306589.png" alt="d3bed623187b74071557d9f145306589.png"></p><p>然后说一说最常用的几个功能</p><h3 id="剪贴板历史"><a href="#剪贴板历史" class="headerlink" title="剪贴板历史"></a>剪贴板历史</h3><p>在 Windows 上对应的是 Ditto，macOS 上也试过几个都不太好用。Alfred 自带这个还能搜索内容，可以自定义保存时间和查看快捷键，选中回车就能保存到剪贴板。如下图我配置 Option + Command + C 是调出历史面板。</p><p><strong>配置面板</strong></p><p><img src="/resource/img/0e5d409dabc29977e3b422883ff6a6b1.png" alt="0e5d409dabc29977e3b422883ff6a6b1.png"></p><p><strong>查看历史面板</strong></p><p><img src="/resource/img/c84b02b4a70d2cac50d33b48862ae1cc.png" alt="c84b02b4a70d2cac50d33b48862ae1cc.png"></p><p><strong>搜索功能</strong></p><p><img src="/resource/img/1a11065ff2160c3e142b512046634954.png" alt="1a11065ff2160c3e142b512046634954.png"></p><p>主要有两个使用场景，一个是在需要多次复制粘贴的场景下，可以一次性复制完，再到新页面按顺序选择性粘贴。另一个是快速搜索某天复制过的片段。</p><h3 id="文件搜索"><a href="#文件搜索" class="headerlink" title="文件搜索"></a>文件搜索</h3><p>输入 find 命令和文件名就能找到，回车会自动在 Finder 中打开所在目录。</p><p><img src="/resource/img/bdd58b4ad92a9ce1d59b3960ac5365a2.png" alt="bdd58b4ad92a9ce1d59b3960ac5365a2.png"></p><h3 id="快速网页搜索"><a href="#快速网页搜索" class="headerlink" title="快速网页搜索"></a>快速网页搜索</h3><p>快速搜索网页的输入结构是『关键字 搜索内容』，关键字就是下图中的 Keyword，然后空格再输入搜索内容。</p><p><img src="/resource/img/5ae9d5343fac84059689056428abcf23.png" alt="5ae9d5343fac84059689056428abcf23.png"></p><p>关键字是可以自定义配置的，只要有有规律的页面就能进行配置。比如我下面的配置是在谷歌搜索时过滤某网站内容。其中的『{query}』是被替换的搜索内容，『gog』是搜索指令。</p><p><img src="/resource/img/7ae07b25b70d57e481aee104e52aa45a.png" alt="7ae07b25b70d57e481aee104e52aa45a.png"></p><p>以下两张图描述了如下两个动作，一个是输入搜索指令，另一个是回车操作后的浏览器页面。</p><p><img src="/resource/img/83877ebbbea93acc0dd1ef96e906bdad.png" alt="83877ebbbea93acc0dd1ef96e906bdad.png"></p><p><img src="/resource/img/941cc4312f9f716b0adf78284457d777.png" alt="941cc4312f9f716b0adf78284457d777.png"></p><p>再比如我要配置自动搜索知乎，我会先去看下知乎搜索页面的结构，如下图。</p><p><img src="/resource/img/5de42ea85a16e3782c97cbaaea99f3f9.png" alt="5de42ea85a16e3782c97cbaaea99f3f9.png"></p><p>网址是：<a href="https://www.zhihu.com/search?type=content&q=%E9%85%8D%E7%BD%AE">https://www.zhihu.com/search?type=content&amp;q=%E9%85%8D%E7%BD%AE</a></p><p>于是在 Alfred 上就可以进行如下配置。</p><p><img src="/resource/img/52c5cd1a8c7ffacb14ff342b074bacf1.png" alt="52c5cd1a8c7ffacb14ff342b074bacf1.png"></p><p><img src="/resource/img/81fa4415d6583b5fa4abdf4b8dd3cf40.png" alt="81fa4415d6583b5fa4abdf4b8dd3cf40.png"></p><p>一般公司内部网址的规律性会更强一些，于是可以做很多的快捷操作。比如快速打开某个内部网址、在 Gitlab 快速发起 Merge Request 申请、快速打开联调环境、快速在 Sentry 搜索内容等。</p><p>附上一些常用自定义配置：</p><ul><li>百度：<a href="https://www.baidu.com/s?ie=utf-8&f=8&wd=%7Bquery%7D">https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;wd={query}</a></li><li>简书：<a href="http://www.jianshu.com/search?utf8=%E2%9C%93&q=%7Bquery%7D">http://www.jianshu.com/search?utf8=%E2%9C%93&amp;q={query}</a></li><li>淘宝：<a href="http://s.taobao.com/search?oe=utf-8&f=8&q=%7Bquery%7D">http://s.taobao.com/search?oe=utf-8&amp;f=8&amp;q={query}</a></li><li>京东：<a href="https://search.jd.com/Search?keyword=%7Bquery%7D&enc=utf-8&wq=%7Bquery%7D">https://search.jd.com/Search?keyword={query}&amp;enc=utf-8&amp;wq={query}</a></li><li>微信文章：<a href="http://weixin.sogou.com/weixin?type=2&query=%7Bquery%7D">http://weixin.sogou.com/weixin?type=2&amp;query={query}</a></li><li>stackoverflow：<a href="http://www.stackoverflow.com/search?q=%7Bquery%7D">http://www.stackoverflow.com/search?q={query}</a></li><li>github：<a href="https://github.com/search?utf8=%E2%9C%93&q=%7Bquery%7D">https://github.com/search?utf8=%E2%9C%93&amp;q={query}</a></li><li>maven：<a href="http://mvnrepository.com/search?q=%7Bquery%7D">http://mvnrepository.com/search?q={query}</a></li><li>Android API Search：<a href="https://developer.android.com/reference/classes.html#q={query}">https://developer.android.com/reference/classes.html#q={query}</a></li></ul><h3 id="快速打开控制台并执行命令"><a href="#快速打开控制台并执行命令" class="headerlink" title="快速打开控制台并执行命令"></a>快速打开控制台并执行命令</h3><p>这个功能用的不多，但也要提一下，默认会打开系统自带终端并执行，我这里的配置是结合 iTerm 启动执行。</p><p><img src="/resource/img/16d37919cb0f223f17c5f28f04bef7e4.png" alt="16d37919cb0f223f17c5f28f04bef7e4.png"></p><p><img src="/resource/img/2b6629322b5e75acc0262d839153f2bf.png" alt="2b6629322b5e75acc0262d839153f2bf.png"></p><p><img src="/resource/img/349dbf7f2c01c7dcd2812eddb390253a.png" alt="349dbf7f2c01c7dcd2812eddb390253a.png"></p><h2 id="Workflow-功能"><a href="#Workflow-功能" class="headerlink" title="Workflow 功能"></a>Workflow 功能</h2><p>Workflow 才是这款软件的灵魂所在，可以通过开发插件的形式扩展软件功能。</p><p><img src="/resource/img/905d051ae874c534cc012976e6e1c9fb.png" alt="905d051ae874c534cc012976e6e1c9fb.png"></p><p>我举三个最常用的扩展吧。</p><h3 id="谷歌身份验证器"><a href="#谷歌身份验证器" class="headerlink" title="谷歌身份验证器"></a>谷歌身份验证器</h3><p>谷歌身份验证器是在做某些危险操作时进行二次确认的一个机制，在第一次初始化时根据账户绑定一个 key，然后每次使用都需要根据当前时间算出一个数字输入，来增强安全性保障，这个原理跟游戏的令牌是一样的。有了这个插件我就可以只输入一个 ok 关键字就可以获得验证口令，回车粘贴，只需要 2 秒。</p><p><img src="/resource/img/0a2def0cd3bb614fa892914a1e0981d1.png" alt="0a2def0cd3bb614fa892914a1e0981d1.png"></p><p>与此同时，而别人的操作流程是</p><ol><li>掏出手机解锁。</li><li>找到 Authy App 打开。</li><li>看到数字口令，手动输入。</li><li>输入超时，口令换新，重新输入。</li></ol><p>以上四步的操作时间平均在 20 秒以上，除非手机时刻在 Authy 界面。</p><h3 id="知一的开发者工具箱"><a href="#知一的开发者工具箱" class="headerlink" title="知一的开发者工具箱"></a>知一的开发者工具箱</h3><p>这个是博主自己开发的一个扩展，目前已在 Github 开源，<a href="https://github.com/noogel/Alfred-Workflow%EF%BC%8C%E6%AC%A2%E8%BF%8E">https://github.com/noogel/Alfred-Workflow，欢迎</a> Star、Fork、提 Feature ~</p><p><img src="/resource/img/ac4d4f5f5eab15f3dc137eda02f87a0c.png" alt="ac4d4f5f5eab15f3dc137eda02f87a0c.png"></p><p>具体的使用教程欢迎查看 <a href="https://github.com/noogel/Alfred-Workflow">https://github.com/noogel/Alfred-Workflow</a></p><p>初衷就是提高平时的开发效率，将一些常用的重复性操作给命令化，以此来节省时间。比如我最常用的 ntm 命令，可以获取当前时间戳或者标准时间，也可以将标准时间和时间戳互转。整个操作 2 秒完成。</p><p><img src="/resource/img/3eb5b84115ef3b516235fcf24d08bb80.png" alt="3eb5b84115ef3b516235fcf24d08bb80.png"></p><p><img src="/resource/img/39dd4230a2e908df5fcbeda8d4f3ced0.png" alt="39dd4230a2e908df5fcbeda8d4f3ced0.png"></p><p><img src="/resource/img/b759437ca8aa0bf4dc3c7de8185314ee.png" alt="b759437ca8aa0bf4dc3c7de8185314ee.png"></p><p><img src="/resource/img/c187b55ba8adc49510bf20602204a16e.png" alt="c187b55ba8adc49510bf20602204a16e.png"></p><p>而别人的操作则分为以下几步。</p><ol><li>打开浏览器搜索时间戳转换工具。</li><li>打开工具网页，等待加载完成。</li><li>输入时间戳或标准时间，点击转换。</li></ol><p>工具箱中的内容不仅这个，还有很多实用的工具，可以大大的提高效率。</p><h3 id="有道翻译"><a href="#有道翻译" class="headerlink" title="有道翻译"></a>有道翻译</h3><p><img src="/resource/img/44e3dbddb40c6a9b22c7055aee8cd824.png" alt="44e3dbddb40c6a9b22c7055aee8cd824.png"></p><p>最后一个常用的插件是有道翻译扩展，输入关键字 yd 就能自动转换中英文。</p><p><img src="/resource/img/7de0e80bbf5d7c0afc5c24d2b6950bd3.png" alt="7de0e80bbf5d7c0afc5c24d2b6950bd3.png"></p><p><img src="/resource/img/316837aeaf66c7918aa9a0391fbd0f73.png" alt="316837aeaf66c7918aa9a0391fbd0f73.png"></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>平时工作的使用频率还是蛮高的，节省下来的时间可以做更多的事情。</p><p><img src="/resource/img/4d0d461ba444ad426fbef97de168b5f4.png" alt="4d0d461ba444ad426fbef97de168b5f4.png"></p><p>Alfred 的功能不止于此，在其官网有更详尽的描述，感兴趣的可以试用一下，有什么问题也可以咨询我。<strong>我是知一，如果这篇文章对你有益，欢迎一键三连~</strong></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;今天要说的是 macOS 下的一款效率软件 —— Alfred，想必大家就算没用过也耳闻过，老实说用好它带来的效率提升绝对不止 10 倍。博主已经安利给很多同事使用，他们普遍觉得上手有些困难，主要是配置复杂，今天的文章会一步步地介绍这款神器的高效之处。&lt;/p&gt;
&lt;p&gt;有的人可能会说系统自带的 Spotlight 就很好用，确实是这样。在之前我会用 Spotlight 搜应用、文件、进行计算等，而 Alfred 的功能更强大，是一款可以更加 All in 的效率工具，里面还有我最常用的剪贴板历史、快速网页搜索、谷歌二次口令扩展等功能，接下来我会逐一介绍。&lt;/p&gt;</summary>
    
    
    
    
    <category term="效率" scheme="https://noogel.xyz/tags/%E6%95%88%E7%8E%87/"/>
    
  </entry>
  
  <entry>
    <title>知一的 2021 已读书单</title>
    <link href="https://noogel.xyz/2022/01/21/1.html"/>
    <id>https://noogel.xyz/2022/01/21/1.html</id>
    <published>2022-01-21T00:00:00.000Z</published>
    <updated>2025-07-23T07:30:58.919Z</updated>
    
    <content type="html"><![CDATA[<p>2021年已经过去，准备对去年看过的书进行一个复盘，回忆下从中得到了什么成长。</p><span id="more"></span><h2 id="文化随笔"><a href="#文化随笔" class="headerlink" title="文化随笔"></a>文化随笔</h2><p><img src="/resource/img/2022-01-21-23-33-32.png"></p><p>首先是同事推荐的一本书 ——《书读完了》，由金克木先生所著，豆瓣评分 8.6 ，还是蛮高的。如今书籍浩如烟海，怎么可能读完？其实先生之所谓读完，我主要记住了以下两个观点。<br>一是说书也有层级，有些书是最基础的书，如《诗经》、《春秋》这些表达中国最底层文化思想的书籍，而其他书则是基于这些书发展而来的，所以要读就读经典。读懂经典，那么后继的书不读也自然懂了大半。中国古书不过是那几十种，是读得完的。<br>二是说经典虽难读懂，但也不要贪图潮流而追逐当下。古人说『读书得间』，读出字里行间的微言大义，于无字处看出字来。看字读句，要看出问题，若能『望气』而知书的『格局』，会看书的『相』，那就可以有『略览群书』的本领，不必一字一句的读，而做到『博览群书』。很可惜在碎片化的时间里很难有如此深度的思考。</p><p><img src="/resource/img/2022-01-21-23-33-40.png"></p><p>第二本说一下《金字塔原理》，这本书主要讲逻辑思维与表达呈现。首先作者讲的是金字塔的基本结构：中心思想明确，结论先行，以上统下，归类分组，逻辑递进。先重要后次要，先全局后细节，先结论后原因，先结果后过程。然后围绕金字塔原理通过一个个案例来讲具体的做法：自上而下表达，自下而上思考，纵向疑问回答／总结概括，横向归类分组／演绎归纳，序言讲故事，标题提炼思想精华。读这本书是因为校友群有人在看，刚好能解决我写博客困难的问题，于是就找来看了看，没有读完，不过写文章的思路总归是有了。</p><p><img src="/resource/img/2022-01-21-23-33-52.png"></p><p>第三本便是《空谷幽兰》，作者比尔·波特是著名的汉学家，在台湾当过两年沙弥，对中国传统文化有着很大的兴趣。这本书主要是讲他在八零年代实地寻访中国隐士的过程，讲述了中国传统隐士在终南山一带的隐居生活，探寻他们为何要离开城市或人群，到幽静之处筑居，有的人五十年不下山，有的人活了近百岁。又讲述了中国传统道与佛的异同。书中描述的意境我只能摘录摘录几句给大家看看：</p><blockquote><p>有个叫宝胜的和尚讲：“真修行的人太少了。至于我自己，我不怎么修行。我晚上打坐，白天干杂活儿。我只是在照管这座庙。”这是得道之人所说的话。<br>陈世杰道长这样谈修道：“当人们努力去寻找道的时候，他们就失去了道。他们混淆了有和无，我们所能做的一切只是修德（美德，精神力量），德包括我们的精神、我们的心、我们的想法。真正的德导致真正的道。但是大多数人修的不是真正的德。他们修炼的是神通和心念，于是我们以为他们得道了。但是他们错了。修习真正的德不是要去掉所有的神通和念头，像一个婴儿一样，无看而看，无听而听，无知而知。首先你要修德，道自然就来了。”这是我听过最好也最透彻的对修道的说法。</p></blockquote><h2 id="伟人传记"><a href="#伟人传记" class="headerlink" title="伟人传记"></a>伟人传记</h2><p><img src="/resource/img/2022-01-21-23-34-00.png"></p><p>《毛泽东传》这部伟人传记还没读完，不过非常值得推荐，可以结合《毛泽东选集》一起读，会有很多收获。</p><h2 id="技术加成"><a href="#技术加成" class="headerlink" title="技术加成"></a>技术加成</h2><p>然后要说的是关于技术类的，整个一年读的都是关于架构和领域驱动设计的书，都很不错。</p><p><img src="/resource/img/2022-01-21-23-34-07.png"></p><p>《架构整洁之道》主要讲了整洁架构的设计目标，系统地剖析其缘起、内涵及应用场景，涵盖软件研发的完整过程及所有核心架构模式。绝对是架构书类中的必读经典。</p><p><img src="/resource/img/2022-01-21-23-34-15.png"></p><p>《软件架构设计》围绕软件架构设计，系统化地梳理技术架构与业务架构的方法论与实践。这本书不仅讲了业务层面的内容，也讲清了很多技术深度上的知识和一些底层的技术思想。</p><p><img src="/resource/img/2022-01-21-23-34-22.png"></p><p>《实现领域驱动设计》这本书出了很多年了，算是领域驱动设计里的经典，但是奈何翻译太差劲，不建议作为入门书来读。系统性读书的话建议先看看国人写的，再结合思特沃克公司写的文章理解。</p><p><img src="/resource/img/2022-01-21-23-34-29.png"></p><p>《复杂软件设计之道》这本国人写的书，前半部分写的还可以，解决了我一些疑问，后半部分就读不进去了。</p><p>关于领域驱动设计总结了一篇文章《万字长文谈谈领域驱动设计》</p><p><img src="/resource/img/2022-01-21-23-34-37.png"></p><p>《垃圾回收的算法与实现》这本书写 GC 还是不错，重点在于算法和不同语言的实现，我也是读了个大概。</p><h2 id="旅游攻略"><a href="#旅游攻略" class="headerlink" title="旅游攻略"></a>旅游攻略</h2><p><img src="/resource/img/2022-01-21-23-34-44.png"></p><p>然后说两本旅游攻略的书，《西藏不止旅行》、《慢拍西藏》，因为 2021 年十一计划去西藏玩，所以提前看了两本书给自己种种草。写了一篇关于西藏的文章《云之彼端·生活的另一种打开方式》</p><p><img src="/resource/img/2022-01-21-23-34-50.png"></p><h2 id="科普和健身"><a href="#科普和健身" class="headerlink" title="科普和健身"></a>科普和健身</h2><p>接下来就是四本关于科普和健身的书了。</p><p><img src="/resource/img/2022-01-21-23-34-57.png"></p><p>《复杂》一书作者梅拉妮·米歇尔是计算机科学教授，她在书中讲述了复杂与复杂系统的关系，给复杂系统一个基本的定义。讲述了各个领域的复杂系统以及度量系统复杂度的方法。读书收获则是加深了对于复杂系统的认知，结合领域驱动设计了解了拆解系统、管理系统复杂度的方法。豆瓣评分 9.0 ，非常值得一读。</p><p><img src="/resource/img/2022-01-21-23-35-03.png"></p><p>《现实不似你所见》深入浅出地讲述了物理学的前世今生，虽然作者已经讲得比较简单了，很少用公式来表达，但我只看懂了只言片语。没想到的是在经典力学之后，又经过了相对论和量子力学，直至现在的量子引力，科学家们竟然进行了这么多的探索。在量子引力的世界，时间、空间、场、粒子都不存在，它们被极度简化为协变量子场的表现形式，感兴趣的读者可以看一看。</p><p><img src="/resource/img/2022-01-21-23-35-10.png"></p><p>《运动改造大脑》这本书最初来源于樊登听书对我产生的影响，作者主要讲了适度复杂运动对于大脑的正向影响。</p><blockquote><p>透过美国高中的体育改革计划、真实的案例与亲身经历、上百项科学研究证实，运动不只能健身、锻炼肌肉，还能锻炼大脑，改造心智与智商，让你更聪明、更快乐、更幸福！运动能刺激脑干，提供能量、热情和动机，还能调节脑内神经递质，改变既定的自我概念，稳定情绪，增进学习力。</p></blockquote><p><img src="/resource/img/2022-01-21-23-35-18.png"></p><p>《这里是中国 2》这本书讲述了中国在建筑和经济方面的一些成就，不如前两年看的同系列的第一本书有意思。两本都值得看看。</p><h2 id="小说类"><a href="#小说类" class="headerlink" title="小说类"></a>小说类</h2><p><img src="/resource/img/2022-01-21-23-35-24.png"></p><p>小说类基本是听，刘慈欣在《三体》之后变得几乎家喻户晓，他写的其他作品同样很好，比如我听的《球状闪电》，当我在听了《神们自己》之后，发现阿西莫夫是西方的刘慈欣，不过他是比刘慈欣要早的，两者的风格很像，鸿篇巨著，构建一个史诗级世界。读完刘慈欣建议看看阿西莫夫合集。</p><p><img src="/resource/img/2022-01-21-23-35-33.png"></p><p>再有一篇是网络小说《13 路末班车》，这篇网文不同于其他的，特点是足够恐怖但又不吓人，主角不是脑残有一定智商，剧情连贯不拖拉。当然也有缺点是有些环节逻辑不缜密，人物动机牵强。</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>最后附上书名-作者-豆瓣评分-京东分类</p><p>《书读完了》 - 金克木 - 8.6 - 文化随笔<br>《金字塔原理》 - 芭芭拉·明托 - 8.1 - 管理经典<br>《空谷幽兰》 - 比尔波特 - 8.3 - 文化随笔<br>《架构整洁之道》 - 罗伯特 C·马丁 - 8.7 - 软件工程及软件方法学<br>《软件架构设计》 - 余春龙 - 8.7 - 软件工程及软件方法学<br>《实现领域驱动设计》 - 沃恩·弗农 - 8.4 - 软件工程及软件方法学<br>《复杂软件设计之道》 - 邱晨阳 - 7.6 - 软件工程及软件方法学<br>《垃圾回收的算法与实现》 - 中村成洋 相川光 - 8.2 - 编程语言与程序设计<br>《西藏不止旅行》 - 周硚 - 7.2 - 旅游攻略<br>《慢拍西藏》 - 赵利山 - 7.5 - 旅游攻略<br>《毛泽东传》 - 中共中央文献研究室 - x - 传记<br>《复杂》 - 梅拉妮·米歇尔 - 9.0 - 科普读物<br>《这里是中国 2》 - 星球研究所 - 8.3 - 科普读物<br>《现实不似你所见》 - 卡洛·罗韦利 - 9.2 科普读物<br>《运动改造大脑》 - 约翰·瑞迪 - 7.5 - 运动健身<br>《球状闪电》 - 刘慈欣 - 9.0 - 科幻小说<br>《神们自己》 - 阿西莫夫 - 8.4 - 科幻小说<br>《13 路末班车》 - 老八零 2 - 网络小说</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;2021年已经过去，准备对去年看过的书进行一个复盘，回忆下从中得到了什么成长。&lt;/p&gt;</summary>
    
    
    
    
    <category term="书单" scheme="https://noogel.xyz/tags/%E4%B9%A6%E5%8D%95/"/>
    
  </entry>
  
  <entry>
    <title>领域驱动设计精粹（下）</title>
    <link href="https://noogel.xyz/2021/12/07/1.html"/>
    <id>https://noogel.xyz/2021/12/07/1.html</id>
    <published>2021-12-07T00:00:00.000Z</published>
    <updated>2025-07-23T07:30:58.918Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/resource/img/2021-12-10-00-27-51.png"></p><h2 id="谈谈领域驱动设计的落地"><a href="#谈谈领域驱动设计的落地" class="headerlink" title="谈谈领域驱动设计的落地"></a>谈谈领域驱动设计的落地</h2><p>前文提到了事件风暴产出的领域模型是概念模型，到实际落地还有些距离，而落地的结果也是各不相同，我觉得说落地，要先回顾一下领域驱动设计的两个作用。</p><ol><li>通过战略设计拆分子域，指导微服务拆分。</li><li>通过事件风暴建立领域概念模型，指导代码设计。</li></ol><p>也就是说领域驱动设计产出的结果是指导性的，并不是一个直接可落地的结果。落地的方案则是要通过架构设计和框架选择上来进行。架构是为了控制软件复杂性而做，就好像『一千个读者心中有一千个哈姆雷特』，不同人做架构不尽相同。下面说说我的落地方式。</p><span id="more"></span><h3 id="架构演进"><a href="#架构演进" class="headerlink" title="架构演进"></a>架构演进</h3><p>我们最初接触和使用的分层架构是三层的，三层架构解决了程序内部代码调用复杂和职责不清的问题，在 DDD 分层架构中的关于对象和服务被重新归类到不同分层中，确定了层与层之间的职责边界。DDD 提出了四层架构，其中最主要的变化是提出领域层的概念，需要领域专家对于业务知识的精准把握之上，根据领域设计方法建立领域模型，把变动较少的领域模型放入领域层，而多变的业务场景代码放入应用层。如下图对应三层到四层的演进过程。</p><p><img src="/resource/img/2022-01-19-00-07-38.png"></p><p>分层架构的一个重要原则是每层只能与位于其下方的层发生耦合，可以简单分为以下两种：</p><ul><li>严格分层架构，某层只能与位于其直接下方的层发生耦合。</li><li>松散分层架构，允许某层与它的任意下方层发生耦合。</li></ul><p>这两种分层架构的耦合方式是各有利弊，在网络上对于他们也是各有各的见解。结合实际情况在开发中，更倾向于采用松散分层架构，但是要禁止用户接口层直接访问基础设施层，防止一些潜在的安全问题。</p><p><img src="/resource/img/2022-01-19-00-07-56.png"></p><h3 id="子域划分"><a href="#子域划分" class="headerlink" title="子域划分"></a>子域划分</h3><p>基于现有三层架构，在其中增加 domain 包的形式增加领域服务层。不同的子域通过包来划分如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">package noogel.xyz.domain.deal;  // 交易子域</span><br><span class="line">package noogel.xyz.domain.quote;  // 算价子域</span><br><span class="line">package noogel.xyz.domain.promotion;  // 促销子域</span><br></pre></td></tr></table></figure><p>同一个领域服务下面再按照领域对象、领域服务、领域资源库、防腐层等方式组织。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">package noogel.xyz.domain.xxx.repository;  // 资源库接口定义</span><br><span class="line">package noogel.xyz.domain.xxx.entity;  // 领域对象</span><br><span class="line">package noogel.xyz.domain.xxx.facade;  // 防腐层</span><br><span class="line">package noogel.xyz.domain.xxx.service;  // 领域服务</span><br></pre></td></tr></table></figure><h3 id="领域对象"><a href="#领域对象" class="headerlink" title="领域对象"></a>领域对象</h3><p>领域驱动解决的一个问题就是对象的贫血问题。通过如下促销领域对象来说明，对于当前购买商品组合能否满足购买规则的检查逻辑不是放在服务层或者工具类中，而是由领域对象提供方法支持。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@Getter</span><br><span class="line">@ToString</span><br><span class="line">@...</span><br><span class="line">public class PromotionDo &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 业务幂等</span><br><span class="line">     */</span><br><span class="line">    private String bizNo;</span><br><span class="line">  // 省略字段...</span><br><span class="line">    private Long beginTime;</span><br><span class="line">    private Long endTime;</span><br><span class="line">    private String desc;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 计算生效数据</span><br><span class="line">     * @param items</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public List&lt;PromotionDo&gt; calculateValid(List&lt;ItemDo&gt; items) &#123;</span><br><span class="line">        switch (rule.getKind()) &#123;</span><br><span class="line">            // ...</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;PromotionDo&gt; promoDataList = new ArrayList&lt;&gt;();</span><br><span class="line">        // do sth ...</span><br><span class="line">        return promoDataList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="资源库（依赖倒置）"><a href="#资源库（依赖倒置）" class="headerlink" title="资源库（依赖倒置）"></a>资源库（依赖倒置）</h3><p>资源库对外的整体访问由 Repository 提供，它聚合了各个资源库的数据信息，同时也承担了资源存储的逻辑。我们将资源库的接口定义放在领域层，而具体实现放在基础设施层。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">package noogel.xyz.domain.xxx.repository;  // 资源库接口定义</span><br><span class="line">package noogel.xyz.infrastructure.repository;  // 资源库实现</span><br><span class="line">package noogel.xyz.infrastructure.rpc;  // RPC 服务</span><br><span class="line">package noogel.xyz.infrastructure.dao;  // 数据库访问对象</span><br></pre></td></tr></table></figure><p>资源库接口定义，提供必要的入参，并且以领域对象的形式作为结果返回。至于组织返回的领域对象，交由具体实现类来实现，可以通过调用数据库、缓存系统、RPC 接口等形式来组织生成领域对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public interface PromotionRepository &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 保存 xx</span><br><span class="line">     * @param data 领域对象</span><br><span class="line">     * @return 唯一 key</span><br><span class="line">     */</span><br><span class="line">    String create(PromotionDo data);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 批量更新状态</span><br><span class="line">     * @param key</span><br><span class="line">     * @param state</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    boolean batchUpdateState(List&lt;String&gt; key, PromoState state);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 批量查询</span><br><span class="line">     * @param promoIds</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    Map&lt;String, PromotionDo&gt; batchGetOnlineById(List&lt;Long&gt; ids);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="防腐层"><a href="#防腐层" class="headerlink" title="防腐层"></a>防腐层</h3><p>用来消除外部上下文结构差异的作用，也叫适配层。比如在算价上下文中需要调用促销上下文数据，不同的促销数据源提供了不同的接口和数据，这时就需要引入防腐层来屏蔽差异，防止外部上下文侵入领域内部影响代码模型。首先定义需要的数据接口规范。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public interface PromotionFacade &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 计算促销数据</span><br><span class="line">     *</span><br><span class="line">     * @param ctx</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    List&lt;PromotionData&gt; calculatePromotion(PromotionContext ctx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类来用处理外部数据的差异，按照接口要求封装数据，简化模型的复杂性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Promotion1Facade implements PromotionFacade &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;PromotionData&gt; calculatePromotion(PromotionContext ctx) &#123;</span><br><span class="line">        PromotionData promoData = PromotionData.of(...);</span><br><span class="line">        return Collections.singletonList(promoData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Promotion2Facade implements PromotionFacade &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RpcService rpcService;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;PromotionData&gt; calculatePromotion(PromotionContext ctx) &#123;</span><br><span class="line">        PromotionData data = new PromotionData();</span><br><span class="line">        // do sth ...</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="上下文集成"><a href="#上下文集成" class="headerlink" title="上下文集成"></a>上下文集成</h3><p>对于上下文集成的手段可以通过 RPC 服务、HTTP 服务、MQ 消息订阅。</p><h3 id="领域服务"><a href="#领域服务" class="headerlink" title="领域服务"></a>领域服务</h3><p>上面我们讲述了各个要素对于资源和行为的封装，业务逻辑的实现代码应该尽量放在聚合根边界内。但是总会遇到不适合放在聚合根上的业务逻辑，而此时领域服务就需要承载编排组合领域对象、资源库和防腐接口等一系列要素，提供对其它上下文的交互接口。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public interface PromotionService &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 创建促销</span><br><span class="line">     *</span><br><span class="line">     * @param item</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    String createPromotion(CreatePromotionDto item);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 批量更新状态</span><br><span class="line">     *</span><br><span class="line">     * @param req</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    boolean batchUpdatePromotion(BatchUpdatePromotionReqDto req);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 计算有效的促销</span><br><span class="line">     *</span><br><span class="line">     * @param req</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    List&lt;PromoResultDto&gt; calculateValidPromotion(CalculateValidPromotionReqDto req);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="落地延伸"><a href="#落地延伸" class="headerlink" title="落地延伸"></a>落地延伸</h3><p>DDD 的设计概念很多，学习成本比较高，于是我们组织了《实现领域驱动设计》的读书分享会，通过共读分享交流理解的方式，让大家对于 DDD 的设计方法和概念有了比较统一的认知。同时发现在做设计分享时，组内的认知比较一致，而对外的理解成本则会比较高。</p><p>不论我们怎样称呼应用层和领域层，但是四层架构的优势已经显而易见，对于电商交易这样一类相对复杂的系统而言。DDD 教会我们怎么拆分领域，如何沉淀领域模型，而如何组织领域服务提供业务功能上是匮乏的，下面是基于系统问题和业界资料总结的一个抽象框架，描述的是如何组合核心能力与业务场景，并提供一个配置化的灵活系统。</p><p><strong>能力单元</strong></p><p>提供基础能力的独立单元，只单纯依赖下游数据提供能力，职责比较单一，对应领域驱动设计的领域服务。</p><p><strong>场景单元</strong></p><p>通过编排不同能力单元，形成一个预定义的执行流程，叫做场景单元。场景单元有以下关键要素：</p><ol><li>执行节点：执行节点负责转换出入参并调用能力单元或场景单元，返回结果给下一个节点。</li><li>条件控制：根据执行节点结果进行简单逻辑判断选择不同的执行路径。</li><li>干预策略：干预策略是场景的扩展点，通过预留的扩展点可以干预执行流程。</li></ol><p>所以一个场景单元的实际处理通路由条件控制和干预策略决定。</p><p><strong>策略配置服务</strong></p><ol><li>提供静态或动态的策略配置给场景单元使用。</li><li>基于节点维度的简单风控策略支持，比如限流、熔断等。</li></ol><p><strong>框架图</strong></p><p><img src="/resource/img/2022-01-19-00-08-33.png"></p><p><strong>核心能力</strong>封装数据和行为，职责要单一且通用，对外提供完善的接口供场景调用，核心能力内部是高内聚的，能力外不能与其它能力模块发生直接耦合，只能通过场景进行间接耦合，要保证核心能力的职责单一性。</p><p><strong>能力模型</strong>是指对于复杂场景进行归类和抽象得出的一个模型，可以用来解决某一类通用问题。能力模型既可以是由订单系统内部提供的，也可能是由外部系统通过 RPC 形式提供的一整套能力接口包装而得。</p><p><strong>内部事件</strong>，由于能力之间不允许直接耦合，所以内部事件不允许在能力模块内部发送，只能由场景中进行控制发送，并且能力内部不允许直接监听，而应该把监听事件作为场景的一种入口，实现场景之间的依赖调用。</p><p><strong>场景单元</strong>偏流程数据编排，需要组织和协调资源的代码被定义为流程。场景单元与策略服务耦合更重，通过策略服务控制场景流程图的走向，以此来实现系统配置化。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《复杂软件设计之道：领域驱动设计全面解析与实战》 - 彭晨阳<br>《实现领域驱动设计》 - 沃恩·弗农<br>《解构领域驱动设计》 - 张逸<br>《DDD实战课》 - 极客时间</p><h3 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h3><p><a href="https://insights.thoughtworks.cn/backend-development-ddd/">https://insights.thoughtworks.cn/backend-development-ddd/</a><br><a href="https://zhuanlan.zhihu.com/p/383427771">https://zhuanlan.zhihu.com/p/383427771</a><br><a href="https://cloud.tencent.com/developer/article/1549817">https://cloud.tencent.com/developer/article/1549817</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/resource/img/2021-12-10-00-27-51.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;谈谈领域驱动设计的落地&quot;&gt;&lt;a href=&quot;#谈谈领域驱动设计的落地&quot; class=&quot;headerlink&quot; title=&quot;谈谈领域驱动设计的落地&quot;&gt;&lt;/a&gt;谈谈领域驱动设计的落地&lt;/h2&gt;&lt;p&gt;前文提到了事件风暴产出的领域模型是概念模型，到实际落地还有些距离，而落地的结果也是各不相同，我觉得说落地，要先回顾一下领域驱动设计的两个作用。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过战略设计拆分子域，指导微服务拆分。&lt;/li&gt;
&lt;li&gt;通过事件风暴建立领域概念模型，指导代码设计。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;也就是说领域驱动设计产出的结果是指导性的，并不是一个直接可落地的结果。落地的方案则是要通过架构设计和框架选择上来进行。架构是为了控制软件复杂性而做，就好像『一千个读者心中有一千个哈姆雷特』，不同人做架构不尽相同。下面说说我的落地方式。&lt;/p&gt;</summary>
    
    
    
    <category term="领域驱动设计" scheme="https://noogel.xyz/categories/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="架构" scheme="https://noogel.xyz/tags/%E6%9E%B6%E6%9E%84/"/>
    
    <category term="领域驱动设计" scheme="https://noogel.xyz/tags/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>领域驱动设计精粹（中）</title>
    <link href="https://noogel.xyz/2021/12/05/1.html"/>
    <id>https://noogel.xyz/2021/12/05/1.html</id>
    <published>2021-12-05T00:00:00.000Z</published>
    <updated>2025-07-23T07:30:58.918Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/resource/img/2021-12-10-00-27-51.png"></p><h2 id="领域驱动设计核心概念"><a href="#领域驱动设计核心概念" class="headerlink" title="领域驱动设计核心概念"></a>领域驱动设计核心概念</h2><p>领域驱动设计学习拦路虎之一就是众多的概念，第一次接触这些概念会有一定的理解成本，不过正是这些概念支撑起的领域驱动设计，接下来会以电商为例对其中的核心概念做介绍。</p><span id="more"></span><h3 id="电商案例"><a href="#电商案例" class="headerlink" title="电商案例"></a>电商案例</h3><p><img src="/resource/img/2021-12-12-18-57-09.png"></p><p>网上购物已经成为我们生活中不可分割的一部分，作为一个用户而言我们经历的流程有以下几点：</p><ol><li>从商品列表页面选择需要的商品。</li><li>查查商品的促销活动，凑凑满减。</li><li>在购物车选择需要买的商品下单。</li><li>下完单通过微信或者支付宝付钱。</li><li>然后等着物流送货上门。</li></ol><p>作为电商的管理人员我们需要做的则是以下几点：</p><ol><li>从采购点采购商品，存放到仓库。</li><li>编辑商品信息，上架售卖。</li><li>编辑一些优惠信息展示在平台上。</li><li>将用户下单的商品通知仓库发货。</li><li>营收成本的清结算。</li></ol><p>电商平台作为一个复杂系统主要有多阶段、⻓链路、多角⾊参与、多信息互通的商品&#x2F;服务交换过程的特点。而领域驱动设计中的概念能支撑我们将电商复杂流程拆解消化，并且建立一个易扩展、更稳定的系统。</p><h3 id="通用语言和限界上下文"><a href="#通用语言和限界上下文" class="headerlink" title="通用语言和限界上下文"></a>通用语言和限界上下文</h3><p>既然有多方协作参与系统的建设和运营，就需要沟通，而降低沟通成本的一个关键就是统一概念和认知，比如我们对于商品的认知，同样都是 iPhone 13，蓝色和粉色，128G 和 256G ，我们说卖掉了一个 iPhone 13 还是卖掉了一个 iPhone 13 蓝色 256G 要怎么表达，这时我们需要有两个概念 SKU 和 SPU 来区分，SKU 作为商品最小售卖单元表达后者，SPU 作为商品信息聚合的最小单位表达前者。</p><p>正是因为不同参与角色可能有不同的理解，为了降低大家沟通的障碍，提出了通用语言和限界上下文这两个重要概念。</p><p><strong>使团队交流达成共识的能够明确简单清晰地描述业务规则和业务含义的语言就是通用语言。</strong> 解决各岗位的沟通障碍问题，促进不同岗位的和合作，确保业务需求的正确表达。通用语言贯穿于整个设计过程，基于通用语言可以开发出可读性更好的代码，能准确的把业务需求转化为代码。</p><p><strong>界限上下文则是用来封装通用语言和领域对象，提供上下文环境，保证在上下文内的业务概念和流程等有一个确切的含义，没有二义性。</strong></p><p>业务概念往往由领域专家带领团队统一通用语言，明确上下文边界，以结算单这个概念在订单上下文和结算上下文的差异来举例：</p><p><img src="/resource/img/2021-12-12-18-57-29.png"></p><ul><li>订单上下文：记录一笔订单所购买商品的消费明细，包括商品原始金额、各项优惠金额、实付货币金额及种类。</li><li>结算上下文：记录的是商家、平台、供货方在一段时间之内的应收应付款项。</li></ul><p>明确上下文边界后，我们跟不同岗位的人沟通即使使用相同词汇也能准确理解其含义。</p><h3 id="领域专家和领域知识"><a href="#领域专家和领域知识" class="headerlink" title="领域专家和领域知识"></a>领域专家和领域知识</h3><p><img src="/resource/img/2021-12-12-18-58-00.png"></p><p>领域驱动设计强调由领域专家带领大家进行领域建模。<strong>领域专家指的是对一个领域的概念和业务流程精通的人，能快速识别或预判业务风险并能给出有效解决方案的人。</strong> 他可以是各个岗位的人，包括一个开发也能成为领域专家。领域知识则是这个领域的各种概念和业务流程。</p><h3 id="战略设计与战术设计"><a href="#战略设计与战术设计" class="headerlink" title="战略设计与战术设计"></a>战略设计与战术设计</h3><p>领域驱动设计作为一种设计方法论，从两个方向指导设计思想，提出了战略设计和战术设计的概念。</p><p>战略设计是从业务视角出发，建立业务领域模型，划分领域边界，建立通用语言下的限界上下文。它是从顶层视角来审视我们的软件系统各个子模块之间的边界。</p><p>拿上面的流程举例来说明，一个有经验的领域专家会带领大家通过事件风暴建模的方法进行子域拆分，大致分为交易域、营销域、支付域、商品域、履约域。</p><p>战术设计则是从技术视角出发，侧重于领域模型的技术实现，完成软件开发和落地，它主要关注的是技术层面的实施。战术设计识别出来的是聚合根、实体、值对象、领域服务、应用服务和资源库等代码逻辑的设计和实现。</p><h3 id="什么是领域模型"><a href="#什么是领域模型" class="headerlink" title="什么是领域模型"></a>什么是领域模型</h3><p>我们都不喜欢写 CRUD 的代码，只因为这些代码往往逻辑很简单，也不具备足够的扩展性，单一场景下可以很快开发出来，如果再加一个场景就又要开发一套，如果场景复杂并且不断变化，开发效率不仅会变慢，而且会更难以维护。下面通过支付系统来举例。</p><p><img src="/resource/img/2021-12-12-18-59-39.png"></p><p>对于 CRUD 的实践来说，在对接支付渠道的时候，给每一家渠道都增加渠道单记录表，字段参照渠道参数定义的，对接微信时增加 wechat_trade 表，增加支付宝时增加 alipay_trade 表。问题就是当渠道增多时每次都建表显然不现实。</p><p>正常的做法则是，统一支付单记录，提取支付关键信息，通过总表和渠道表来记录，总表记录关键信息，把次要信息放入渠道表。相当于把支付单信息做了一次垂直拆分。</p><p>随着发展，新增了连续订阅业务，产品说需要在支付单中识别出是系统扣费还是用户主动付费的，这时你会想着扩列来支持，可是业务千变万化，不能每次都这样做。</p><p>其实软件开发中的许多问题，例如沟通问题、演化问题都和领域模型有关。<strong>领域模型是对领域内的概念类或现实世界中对象的可视化表示。<em>它专注于分析问题领域本身，发掘重要的业务领域概念，并建立业务领域概念之间的关系。</em></strong></p><p><img src="/resource/img/2021-12-12-18-59-58.png"></p><h3 id="实体和值对象"><a href="#实体和值对象" class="headerlink" title="实体和值对象"></a>实体和值对象</h3><p>实体和值对象是组成领域模型的基础单元。</p><p><strong>实体拥有唯一标识符，且标识符在历经各种状态变更后仍能保持一致。</strong> 对实体而言，重要的不是其属性，而是其延续性和标识，对象的延续性和标识会跨越甚至超出软件的生命周期。我们把这样的对象称为实体。从上面的实例来说，支付单有唯一的 ID，渠道单有自己的唯一 ID，它们都是实体。</p><p><strong>当一个对象用来描述一个实物，而没有唯一的标识符，叫做值对象。</strong> 值对象本质就是一个集合，可以保证属性归类的清晰和概念的完整性。由于金额不能单独表达用户的消费额，需要由支付金额和货币类型组合才能表达，消费额是一组值对象。</p><p><img src="/resource/img/2021-12-12-19-00-20.png"></p><h3 id="聚合与聚合根"><a href="#聚合与聚合根" class="headerlink" title="聚合与聚合根"></a>聚合与聚合根</h3><p>聚合是领域模型的具体表达。</p><p><strong>聚合是业务和逻辑紧密关联的实体和值对象组合而成，聚合是数据修改和持久化的基本单元，一个聚合对应一个数据的持久化。</strong> 聚合在 DDD 分层架构中属于领域层，一个聚合提供一个业务核心能力，领域层包含了多个聚合，聚合内的实体以充血模型实现个体业务能力，以及业务逻辑的高内聚。</p><p><strong>聚合根也叫做根实体，它不仅仅是实体，还是实体的管理者。</strong> 聚合之间通过聚合根关联引用，如果需要访问其他聚合的实体，先访问聚合根，再导航到聚合内部的实体。即外部对象不能直接访问聚合内的实体。</p><p><img src="/resource/img/2021-12-12-19-00-36.png"></p><p>拿上面支付的例子来说，支付是一个聚合，支付单是聚合根，渠道单是依附于聚合根的另一个实体，渠道单的所有行为都要通过支付单进行操作。</p><p>上面说到聚合之间通过聚合根关联引用，一个实体是否属于聚合根取决于所处的聚合。在退款聚合中，退款单是聚合根，绑定的支付单，在这里支付单是普通实体。所以是否是聚合根取决于具体场景。</p><p>聚合的特点：高内聚、低耦合，它是领域模型中最底层的边界，可以作为拆分微服务的最小单位。</p><h3 id="概念关系"><a href="#概念关系" class="headerlink" title="概念关系"></a>概念关系</h3><p>关于领域驱动设计的核心概念已经介绍了一部分，后面还有一部分。关于这些概念的涵盖范围见下图。</p><p><img src="/resource/img/2021-12-12-18-59-11.png"></p><h2 id="从事件风暴建模学到什么"><a href="#从事件风暴建模学到什么" class="headerlink" title="从事件风暴建模学到什么"></a>从事件风暴建模学到什么</h2><p>在这里我说一下电商中比较核心的一个流程。在京东购物我们会选择很多需要的商品添加到购物车，在双十一的时候会凑单满减，然后从购物车选中下单。现在我们要设计的部分是用户在选择多件商品时自动给用户使用上最优的多种促销活动，在用户下单的时候能够计算好用户应该付多少钱，每件商品分别应付和优惠多少钱。后面的表达我会用算价来代表这个流程。</p><h3 id="领域知识的构成"><a href="#领域知识的构成" class="headerlink" title="领域知识的构成"></a>领域知识的构成</h3><p>在领域驱动设计中很强调领域专家这角色，与团队人员共同协作完成任务。而往往团队人员就拥有领域专家所拥有的部分知识，从而承担领域专家的职责，那么剩下的领域知识就需要靠团队人员借助外援来填补，方式包括但不限于以下三种方式：</p><ol><li>通过网络渠道（论文、文章、书籍）获得。</li><li>请教身边有相关经验的朋友。</li><li>通过竞品分析获得。</li></ol><p>当我们团队获得该领域下主要的领域知识后，需要结合实际需求进行战略设计和战术设计，就可以通过事件风暴建模方法进行领域建模。</p><p>本来是想着拿实际的例子来讲一遍事件风暴建模的过程，现在想想与其照本宣科的讲知识，不如写写经验和感悟来的实在。</p><h3 id="事件风暴-VS-传统开发"><a href="#事件风暴-VS-传统开发" class="headerlink" title="事件风暴 VS 传统开发"></a>事件风暴 VS 传统开发</h3><p>事件风暴建模的标准流程可以很轻松地找到，这里不再赘述。主要说下从传统软件开发模型到领域驱动设计的领域建模，发生了什么变化。</p><p>传统模式：产品需求-&gt;需求分析-&gt;详细设计-&gt;ER模型-&gt;UML 设计<br>DDD 模式：事件风暴-&gt;产品愿景-&gt;场景分析-&gt;领域建模-&gt;微服务拆分与设计。</p><p>在传统模式下的产出的是可直接落地的设计结果，但是缺乏顶层设计，对于后期的变更维护难以高效支撑。而 DDD 的关注点更多的是顶层设计和概念模型，概念模型并不是可直接落地的结果，这样的优势便是在后期的扩展和变更中更容易。</p><h3 id="子域拆分的关键经验"><a href="#子域拆分的关键经验" class="headerlink" title="子域拆分的关键经验"></a>子域拆分的关键经验</h3><p>关于如何拆分子域，看了很多的内容后得到的一句话：『凭经验』，这个就让人很糊涂，我如何知道我拆分的是否准确。</p><p>当我带着问题去找书查资料，收获还是比较快的，有一段话驱散了一部分迷雾：『领域的边界划分不断演绎，只要发现复杂性凝聚的地方，就划定为有界上下文，割裂它与其他系统的关系，并派出精兵强将专门对付。』它给了我两个点醒：</p><ol><li>领域的边界是<strong>不断演绎</strong>的。</li><li>领域内部是<strong>高内聚</strong>的，领域间是低耦合的。</li></ol><p>从这两点出发，可以通过以下两点执行：</p><ol><li>和领域专家沟通现在，并预判一下未来。</li><li>分析领域内头部公司的策略。</li></ol><h3 id="领域建模的关键经验"><a href="#领域建模的关键经验" class="headerlink" title="领域建模的关键经验"></a>领域建模的关键经验</h3><p>假定产品愿景是可行并且可执行的。在场景分析和领域建模的过程，有个通用的范式。</p><ol><li>提取业务中的<strong>动词</strong>和<strong>名词</strong>识别为领域概念。</li><li>通过业务中的定语对领域概念进行<strong>归纳抽象</strong>。</li><li>对确定的领域概念进行<strong>关系确认</strong>。</li></ol><p>由此我们可以得出领域分析模型，这是一个比较抽象的模型，此时还无法落地。从复杂性角度来看领域建模控制的是业务复杂性。</p><h3 id="复杂性问题控制方式"><a href="#复杂性问题控制方式" class="headerlink" title="复杂性问题控制方式"></a>复杂性问题控制方式</h3><p>在之前的文章中也提到过三点：</p><ol><li>抽象</li><li>分治</li><li>领域知识</li></ol><p>现在反过来看，提炼领域概念是抽象，子域拆分是分治，而要做到这两点的正需要的是领域知识。领域驱动设计不仅告诉了我们『道』，也告诉了我们『术』。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/resource/img/2021-12-10-00-27-51.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;领域驱动设计核心概念&quot;&gt;&lt;a href=&quot;#领域驱动设计核心概念&quot; class=&quot;headerlink&quot; title=&quot;领域驱动设计核心概念&quot;&gt;&lt;/a&gt;领域驱动设计核心概念&lt;/h2&gt;&lt;p&gt;领域驱动设计学习拦路虎之一就是众多的概念，第一次接触这些概念会有一定的理解成本，不过正是这些概念支撑起的领域驱动设计，接下来会以电商为例对其中的核心概念做介绍。&lt;/p&gt;</summary>
    
    
    
    <category term="领域驱动设计" scheme="https://noogel.xyz/categories/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="架构" scheme="https://noogel.xyz/tags/%E6%9E%B6%E6%9E%84/"/>
    
    <category term="领域驱动设计" scheme="https://noogel.xyz/tags/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>领域驱动设计精粹（上）</title>
    <link href="https://noogel.xyz/2021/12/03/1.html"/>
    <id>https://noogel.xyz/2021/12/03/1.html</id>
    <published>2021-12-03T00:00:00.000Z</published>
    <updated>2025-07-23T07:30:58.918Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/resource/img/2021-12-10-00-27-51.png"></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>概念可以简单描述某类事物，这类事物可以是实体也可以是问题。领域驱动设计是为了管理系统复杂性问题而生的一套方法论。</p><p>随着业务系统的复杂性不断提高，系统的性能和灵活性要求也会越来越高，如何构建一个扩展性强、可用性高的业务系统是需要我们不断思考的问题。</p><p>我们以交易系统为例，在互联网之初，实体商业占据绝对主导地位的时代，电子商务系统最初的目的就是把货物卖出去，业务需求很简单，就是一手付钱，一手交货，而更多的难点是在于如何让人们接受并认可在网络上进行交易。随着这几十年的发展，电商早已不是最初的样子，需求变为如何更快更多的把商品卖出去，于是产生出了层出不穷你算不清楚的促销活动，比如满减、凑单、会员价、拼团、优惠券等。你买东西的价格也许只有系统能真正算清楚。</p><p>系统的复杂性比起最初，呈几何倍的增长，如何控制并管理系统复杂度是我们需要在业务发展过程中需要解决的问题。复杂的业务各有各的复杂，而拆解之道也各有各的侧重，<strong>今天要介绍的是领域驱动设计如何帮助我们拆解需求，并建立一个灵活性高、可扩展的业务系统。</strong></p><span id="more"></span><h2 id="领域驱动设计在讲什么"><a href="#领域驱动设计在讲什么" class="headerlink" title="领域驱动设计在讲什么"></a>领域驱动设计在讲什么</h2><p>领域驱动设计中的领域是什么？我理解的是一个比行业更加细分的方向，比如互联网做电商业务是电商领域，电商中有专注交易的交易领域，做电子支付叫支付领域。领域范围可大可小，领域知识表示某些具有相关相关性知识的合集。</p><p><strong>领域驱动设计是通过领域知识构建的领域模型来控制业务的复杂性，通过领域模型反映领域知识，构建更易维护的系统。解决软件难以理解，难以演化的问题。</strong></p><p><em>上面的总结涉嫌鸡生蛋蛋生鸡的问题。其实领域模型和领域知识是迭代产生的，随着人类抽象总结而不断凝练而成的。拿之前讨论过的例子来说，一个电商领域专家可能脱口而出订单的概念，大家先入为主的很容易理解这个概念。</em></p><p><em>从人类历程来看最早出现的是物物交换的概念，后面逐渐变成等价货币交换，我们抽象的名词叫交易，再到后面你从我这里付一笔钱，我给你一个凭据，过段时间你来取货，我们管这叫购买凭据，进而逐渐演化成订单这个概念。</em></p><h3 id="领域驱动设计的核心价值"><a href="#领域驱动设计的核心价值" class="headerlink" title="领域驱动设计的核心价值"></a>领域驱动设计的核心价值</h3><p>领域驱动设计的核心目标是<strong>基于特定业务范围，通过统一业务概念（统一语言），将系统参与各方整合在一起，从而减少不同角色和环节的信息熵减问题。</strong></p><p>领域模型是领域驱动设计的核心产出，它不仅能描述真实的业务逻辑和业务场景，也是系统实现的表达方式。<strong>领域模型的适应性能直接反应系统的扩展性上，能否使系统在增大时仍然保持敏捷。</strong></p><p>领域驱动设计之所以更加流行，很大因素是<strong>领域驱动设计提供的方法论上与近些年流行的微服务有很好的匹配性，通过领域驱动设计方法清晰地识别业务边界，以此来指导微服务的拆分。</strong> 领域驱动设计提供的领域划分方法可以指导我们对微服务的拆分，以及对于演进式架构有很强的助力。</p><h3 id="领域驱动设计的适用场景"><a href="#领域驱动设计的适用场景" class="headerlink" title="领域驱动设计的适用场景"></a>领域驱动设计的适用场景</h3><p>通过上面对于领域驱动设计的介绍，可以提炼出三个主要作用：</p><ol><li>统一通用语言，降低不同角色间的沟通成本。</li><li>通过战略设计划分子域、限界上下文，以此垂直拆解复杂度。</li><li>通过聚合的方式进行建模，以此水平拆解复杂度。</li></ol><p>通过以上三个作用来逐步介绍领域驱动设计的适用场景。</p><h4 id="多角色协作的业务场景"><a href="#多角色协作的业务场景" class="headerlink" title="多角色协作的业务场景"></a>多角色协作的业务场景</h4><p>领域驱动设计中引入领域专家角色，是指对某个领域的概念和流程有着深入理解的一类人。开发人员与领域专家之间，他们掌握的知识存在巨大的差异。就比如电商领域专家清楚地了解交易单、订单、子单、售后、物流单、运单这些概念的准确含义，而开发人员更专注技术的运用，在沟通中如果没有达成一致的理解，沟通效率就会很差，甚至产生误解。</p><p>领域驱动设计提出从需求中提炼出统一语言，其实就是在两个不同的语言世界中进行正确翻译的过程。在多角色协作的场景中可以有效降低沟通成本，迭代式的探索和发现模型。</p><h4 id="复杂业务场景进行业务拆解"><a href="#复杂业务场景进行业务拆解" class="headerlink" title="复杂业务场景进行业务拆解"></a>复杂业务场景进行业务拆解</h4><p>上面我们提到现代电商促销方案层出不穷，决定一笔交易的金额有很多影响因素，而算价结果直接影响到这笔交易的支付金额，以及每件商品的实付金额。如果我们认为促销价格计算和交易联系很紧密就把他们放到了一起去开发维护，我想这个系统后面必定会难以维护，最终进行拆分。</p><p>而系统拆分的指导思想就是我们耳熟能详的六个字：<strong>『高内聚，低耦合。』</strong> 领域驱动设计有着一套完整的方法论，指导我们对复杂问题进行拆分、梳理各个子系统间的关系，帮助我们落地复杂系统。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/resource/img/2021-12-10-00-27-51.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;概念可以简单描述某类事物，这类事物可以是实体也可以是问题。领域驱动设计是为了管理系统复杂性问题而生的一套方法论。&lt;/p&gt;
&lt;p&gt;随着业务系统的复杂性不断提高，系统的性能和灵活性要求也会越来越高，如何构建一个扩展性强、可用性高的业务系统是需要我们不断思考的问题。&lt;/p&gt;
&lt;p&gt;我们以交易系统为例，在互联网之初，实体商业占据绝对主导地位的时代，电子商务系统最初的目的就是把货物卖出去，业务需求很简单，就是一手付钱，一手交货，而更多的难点是在于如何让人们接受并认可在网络上进行交易。随着这几十年的发展，电商早已不是最初的样子，需求变为如何更快更多的把商品卖出去，于是产生出了层出不穷你算不清楚的促销活动，比如满减、凑单、会员价、拼团、优惠券等。你买东西的价格也许只有系统能真正算清楚。&lt;/p&gt;
&lt;p&gt;系统的复杂性比起最初，呈几何倍的增长，如何控制并管理系统复杂度是我们需要在业务发展过程中需要解决的问题。复杂的业务各有各的复杂，而拆解之道也各有各的侧重，&lt;strong&gt;今天要介绍的是领域驱动设计如何帮助我们拆解需求，并建立一个灵活性高、可扩展的业务系统。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="领域驱动设计" scheme="https://noogel.xyz/categories/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="架构" scheme="https://noogel.xyz/tags/%E6%9E%B6%E6%9E%84/"/>
    
    <category term="领域驱动设计" scheme="https://noogel.xyz/tags/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>云之彼端，生活的另一种打开方式</title>
    <link href="https://noogel.xyz/2021/11/25/1.html"/>
    <id>https://noogel.xyz/2021/11/25/1.html</id>
    <published>2021-11-25T00:00:00.000Z</published>
    <updated>2025-07-23T07:30:58.919Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/resource/img/2021-12-27-02-24-04.png"></p><p>在加乌拉山口拍珠峰，这里可以一眼望尽五座八千米高山。</p><p>旅行是为了什么？有的人是为了好吃好玩，有的人是为了看风景。我就是后者，如果你喜欢游览祖国广袤的山川河流，看尽一望无际的高原雪山，那么你一定要来趟西藏，看看还是那么相对纯粹的自然风光。</p><p>去西藏的计划是从八月推迟到了十一黄金周，不过今年西藏的十一却少了往日的火爆，人不是那么多，主要还是因为前一段事件疫情的影响，所以路上的体验都还不错。</p><p>全国除了西藏都是可以想去就去的，而西藏是需要好好准备一下的，为此也踩了一些坑。就拿抗高反来说吧，去之前你需要做的是好好休息，减少运动量就可以了，不用喝什么红景天、高原康之类的，作用不大。在高原防止高反只需要做到以下几点即可：</p><ol><li>晚上保证充足的睡眠。</li><li>多吃高热量实物来保障能量供应。</li><li>放平心态，不要有心理压力。</li><li>到高原先缓两天再安排行程。</li></ol><p>刚去的前几天高反加水土不服，在羊卓雍措的湖边住房车，大半夜的跑到车外吐了好几次，第二天买了藿香正气就好了，然后就是听司机的话，觉得不舒服就喝点葡萄糖，确实很有效。</p><p>到了西藏，面对壮阔的雪山群，纯净的圣湖，当然要留下一些回忆。</p><p><img src="/resource/img/2021-12-27-02-24-47.png"></p><p>在海拔 5200 米的珠峰大本营，珠峰山顶总被云雾缠绕着，能近距离的看到很难得。</p><p><img src="/resource/img/2021-12-27-02-25-12.png"></p><p><img src="/resource/img/2021-12-27-02-25-30.png"></p><p><img src="/resource/img/2021-12-27-02-25-50.png"></p><p>羊卓雍措是西藏的三大圣湖之一，从山上看下去，湖水呈靛青色，就跟染料一般纯净，和其它湖水的蓝很不一样。</p><p><img src="/resource/img/2021-12-27-02-26-23.png"></p><p>纳木错也是西藏的三大圣湖之一，蓝色湖水对面的雪山就是念青唐古拉山脉。</p><p><img src="/resource/img/2021-12-27-02-26-40.png"></p><p><img src="/resource/img/2021-12-27-02-26-56.png"></p><p>在西藏还有一点独特的体验就是看星空，与平原不同地是这里的高海拔，使得星空银河非常清晰明显，你会看到银河从地上的一端穿过天空扎向另一端。站在山顶的那一刻我终于体会到儿时的一句话『天空是一块幕布，星星和月亮就是装饰这块幕布的花纹。』望着繁星与银河，感觉到自己渺小，如这沧海中的一粟。</p><p><img src="/resource/img/2021-12-27-02-27-16.png"></p><p>西藏之旅还有很多有意思的故事与见闻，虽然这篇文章鸽了这么久，但是我还是不想再去讲了。总之这是一场头疼并快乐的旅途~</p><p><img src="/resource/img/2021-12-27-02-27-32.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/resource/img/2021-12-27-02-24-04.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;在加乌拉山口拍珠峰，这里可以一眼望尽五座八千米高山。&lt;/p&gt;
&lt;p&gt;旅行是为了什么？有的人是为了好吃好玩，有的人是为了看风景。我就是后者，如果你喜欢游览祖国广袤</summary>
      
    
    
    
    
    <category term="游记" scheme="https://noogel.xyz/tags/%E6%B8%B8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>ETCD 运维笔记</title>
    <link href="https://noogel.xyz/2021/11/16/1.html"/>
    <id>https://noogel.xyz/2021/11/16/1.html</id>
    <published>2021-11-16T00:00:00.000Z</published>
    <updated>2025-07-23T07:30:58.914Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>调研环境说明</strong></p><p>etcd –version<br>etcd Version: 3.5.1<br>Git SHA: d42e8589e<br>Go Version: go1.17.2<br>Go OS&#x2F;Arch: darwin&#x2F;amd64</p></blockquote><h2 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h2><p>启动参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">--name etcd-1 // 节点名称</span><br><span class="line">--data-dir /Users/noogel/Debug/data/etcd1 // 数据目录</span><br><span class="line">--initial-advertise-peer-urls http://127.0.0.1:238</span><br><span class="line">--listen-peer-urls http://127.0.0.1:2381</span><br><span class="line">--listen-client-urls http://127.0.0.1:2379</span><br><span class="line">--advertise-client-urls http://127.0.0.1:2379</span><br><span class="line">--initial-cluster-token etcd-lock-cluster-1 // 集群 token</span><br><span class="line">--initial-cluster etcd-1=http://127.0.0.1:2381,etcd-2=http://127.0.0.1:2382,etcd-3=http://127.0.0.1:2383 // 集群节点信息</span><br><span class="line">--initial-cluster-state new // 初始化的集群状态</span><br><span class="line">--heartbeat-interval 1000 // 心跳间隔</span><br><span class="line">--auto-compaction-retention 1 // 开启自动压缩，间隔 1h 执行</span><br><span class="line">--auto-compaction-mode periodic</span><br><span class="line">--quota-backend-bytes 8589934592 // 后端存储大小</span><br><span class="line">--election-timeout 5000 // 选举超时时间</span><br></pre></td></tr></table></figure><p><strong>关于自动压缩</strong><br><a href="https://etcd.io/docs/v3.4/op-guide/maintenance/#defragmentation">https://etcd.io/docs/v3.4/op-guide/maintenance/#defragmentation</a></p><ul><li><code>--auto-compaction-mode=revision --auto-compaction-retention=1000</code> 每5分钟自动压缩”latest revision” - 1000</li><li><code>--auto-compaction-mode=periodic --auto-compaction-retention=12h</code> 每1小时自动压缩并保留12小时窗口。</li></ul><p>自动压缩碎片后还需要单独再清理占用的系统存储空间，<code>etcdctl defrag</code>。</p><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><ol><li>heartbeat timeout 默认为 100ms,推荐配置为 1s;</li><li>election timeout 默认为 1000ms,推荐为 5s(election timeout &gt;&#x3D; 5 * heartbeat timeout);</li><li>quota-backend-bytes 默认为 2G(最大值8G),推荐根据集群容量预估调整;</li><li>配置 auto-compaction-retention&#x3D;1 和 auto-compaction-mode&#x3D;periodic 参数，定期压缩历史数据;</li><li>推荐通过 cronjob 定期执行 etcdctl defrag（如果 defrag 执行时间 &gt; election timeout，则集群会进入重新选主模式）</li></ol><h2 id="环境模拟"><a href="#环境模拟" class="headerlink" title="环境模拟"></a>环境模拟</h2><h3 id="端口映射"><a href="#端口映射" class="headerlink" title="端口映射"></a>端口映射</h3><p>单机环境写集群搭建，以下是端口映射</p><p>etcd1 2379 -&gt; 2391 2380 -&gt; 2381</p><p>etcd2 2379 -&gt; 2392 2380 -&gt; 2382</p><p>etcd3 2379 -&gt; 2393 2380 -&gt; 2383</p><h3 id="启动命令"><a href="#启动命令" class="headerlink" title="启动命令"></a>启动命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ETCDCTL_API=3 etcd --name etcd-1 --data-dir /Users/noogel/Debug/data/etcd1 --initial-advertise-peer-urls http://127.0.0.1:2381 --listen-peer-urls http://127.0.0.1:2381 --listen-client-urls http://127.0.0.1:2379 --advertise-client-urls http://127.0.0.1:2379 --initial-cluster-token etcd-lock-cluster-1 --initial-cluster etcd-1=http://127.0.0.1:2381,etcd-2=http://127.0.0.1:2382,etcd-3=http://127.0.0.1:2383 --initial-cluster-state new --heartbeat-interval 1000 --auto-compaction-mode=revision --auto-compaction-retention=1000 --quota-backend-bytes 8589934592 --election-timeout 5000 &gt; /Users/noogel/Debug/data/etcd1/run.log 2&gt;&amp;1 &amp;</span><br><span class="line"></span><br><span class="line">ETCDCTL_API=3 etcd --name etcd-2 --data-dir /Users/noogel/Debug/data/etcd2 --initial-advertise-peer-urls http://127.0.0.1:2382 --listen-peer-urls http://127.0.0.1:2382 --listen-client-urls http://127.0.0.1:2378 --advertise-client-urls http://127.0.0.1:2378 --initial-cluster-token etcd-lock-cluster-1 --initial-cluster etcd-1=http://127.0.0.1:2381,etcd-2=http://127.0.0.1:2382,etcd-3=http://127.0.0.1:2383 --initial-cluster-state new --heartbeat-interval 1000 --auto-compaction-mode=revision --auto-compaction-retention=1000 --quota-backend-bytes 8589934592 --election-timeout 5000 &gt; /Users/noogel/Debug/data/etcd2/run.log 2&gt;&amp;1 &amp;</span><br><span class="line"></span><br><span class="line">ETCDCTL_API=3 etcd --name etcd-3 --data-dir /Users/noogel/Debug/data/etcd3 --initial-advertise-peer-urls http://127.0.0.1:2383 --listen-peer-urls http://127.0.0.1:2383 --listen-client-urls http://127.0.0.1:2377 --advertise-client-urls http://127.0.0.1:2377 --initial-cluster-token etcd-lock-cluster-1 --initial-cluster etcd-1=http://127.0.0.1:2381,etcd-2=http://127.0.0.1:2382,etcd-3=http://127.0.0.1:2383 --initial-cluster-state new --heartbeat-interval 1000 --auto-compaction-mode=revision --auto-compaction-retention=1000 --quota-backend-bytes 8589934592 --election-timeout 5000 &gt; /Users/noogel/Debug/data/etcd3/run.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure><h3 id="历史数据清理命令"><a href="#历史数据清理命令" class="headerlink" title="历史数据清理命令"></a>历史数据清理命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rm -rf /Users/noogel/Debug/data/etcd1</span><br><span class="line">rm -rf /Users/noogel/Debug/data/etcd2</span><br><span class="line">rm -rf /Users/noogel/Debug/data/etcd3</span><br><span class="line">mkdir etcd1 etcd2 etcd3</span><br></pre></td></tr></table></figure><h2 id="日常运维"><a href="#日常运维" class="headerlink" title="日常运维"></a>日常运维</h2><h3 id="常规命令"><a href="#常规命令" class="headerlink" title="常规命令"></a>常规命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">export ETCDCTL_API=3</span><br><span class="line">// 节点列表查询</span><br><span class="line">etcdctl member list</span><br><span class="line">// 节点状态</span><br><span class="line">etcdctl --endpoints=127.0.0.1:2381,127.0.0.1:2382,127.0.0.1:2383 endpoint status --write-out=table</span><br><span class="line">// 整理磁盘碎片</span><br><span class="line">etcdctl --endpoints=127.0.0.1:2381,127.0.0.1:2382,127.0.0.1:2383 --user root:123456 defrag</span><br></pre></td></tr></table></figure><h3 id="开启鉴权"><a href="#开启鉴权" class="headerlink" title="开启鉴权"></a>开启鉴权</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 添加 root 用户</span><br><span class="line">etcdctl --endpoints=127.0.0.1:2381,127.0.0.1:2382,127.0.0.1:2383 user add root</span><br><span class="line">// 授权 root 角色</span><br><span class="line">etcdctl --endpoints=127.0.0.1:2381,127.0.0.1:2382,127.0.0.1:2383 user grant-role root root</span><br><span class="line">// 查看用户列表</span><br><span class="line">etcdctl --endpoints=127.0.0.1:2381,127.0.0.1:2382,127.0.0.1:2383 --user=root:123456 user list</span><br><span class="line">// 开启鉴权</span><br><span class="line">etcdctl --endpoints=127.0.0.1:2381,127.0.0.1:2382,127.0.0.1:2383 auth enable</span><br></pre></td></tr></table></figure><h3 id="生产集群节点启动方式"><a href="#生产集群节点启动方式" class="headerlink" title="生产集群节点启动方式"></a>生产集群节点启动方式</h3><p>在生产机通过 <code>systemd</code> 启动。第一次启动命令<code>--initial-cluster-state new</code>，后续节点的增加需要修改为 <code>--initial-cluster-state existing</code>，不明白看节点增加部分。</p><p><strong>修改配置</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 编辑配置</span><br><span class="line">vim /lib/systemd/system/etcd.service</span><br><span class="line">// 重新加载配置</span><br><span class="line">systemctl daemon-reload</span><br><span class="line">// 启动服务</span><br><span class="line">systemctl start etcd.service</span><br><span class="line">// 查看服务状态</span><br><span class="line">systemctl status etcd.service</span><br></pre></td></tr></table></figure><h3 id="问题处理"><a href="#问题处理" class="headerlink" title="问题处理"></a>问题处理</h3><h4 id="Etcd-的-compact-机制"><a href="#Etcd-的-compact-机制" class="headerlink" title="Etcd 的 compact 机制"></a>Etcd 的 compact 机制</h4><p>Etcd 默认不会自动 compact，需要设置启动参数，或者通过命令进行compact，如果变更频繁建议设置，否则会导致空间和内存的浪费以及错误。Etcd v3 的默认的 backend quota 2GB，如果不 compact，boltdb 文件大小超过这个限制后，就会报错：”Error: etcdserver: mvcc: database space exceeded”，导致数据无法写入。</p><p>要从空间不足配额警报中恢复：</p><ol><li>Compact etcd的历史。</li><li>对每个etcd端点进行碎片整理。</li><li>解除警报。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 1、获取当前的版本</span><br><span class="line">$ rev=$(ETCDCTL_API=3 etcdctl --endpoints=:2379 endpoint status --write-out=&quot;json&quot; | egrep -o &#x27;&quot;revision&quot;:[0-9]*&#x27; | egrep -o &#x27;[0-9].*&#x27;)</span><br><span class="line"># 2、压缩当前版本之前的所有记录</span><br><span class="line">$ ETCDCTL_API=3 etcdctl compact $rev</span><br><span class="line">compacted revision 1516</span><br><span class="line"># 3、清理多余的碎片空间</span><br><span class="line">$ ETCDCTL_API=3 etcdctl defrag</span><br><span class="line">Finished defragmenting etcd member[127.0.0.1:2381]</span><br><span class="line"># 4、解除警告</span><br><span class="line">$ ETCDCTL_API=3 etcdctl alarm disarm</span><br><span class="line">memberID:13803658152347727308 alarm:NOSPACE</span><br></pre></td></tr></table></figure><blockquote><p><strong>需要注意的是整理碎片释放空间，要一个一个节点执行，因为在执行期间节点是无响应的，直到处理完。防止因为全部节点无响应导致的服务不可用</strong></p></blockquote><h4 id="碎片整理"><a href="#碎片整理" class="headerlink" title="碎片整理"></a>碎片整理</h4><p>压缩key空间后，会出现内部碎片，这些压缩出来的碎片空间可以被etcd使用，但是不会真正的释放物理空间，需要进行碎片整理，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ etcdctl defrag</span><br><span class="line">Finished defragmenting etcd member[127.0.0.1:2379]以上指令只作用于当前所在的主机，不会在集群</span><br></pre></td></tr></table></figure><p>环境中复刻。可以使用–cluster标记指定所有成员以自动查找所有集群成员。如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ etcdctl defrag --cluster</span><br><span class="line">Finished defragmenting etcd member[http://127.0.0.1:2381]</span><br><span class="line">Finished defragmenting etcd member[http://127.0.0.1:2382]</span><br><span class="line">Finished defragmenting etcd member[http://127.0.0.1:2383]</span><br></pre></td></tr></table></figure><h4 id="节点增减"><a href="#节点增减" class="headerlink" title="节点增减"></a>节点增减</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 查看成员信息</span><br><span class="line">ETCDCTL_API=3 etcdctl member list</span><br><span class="line"># 移除节点</span><br><span class="line">ETCDCTL_API=3 etcdctl member remove wallet0x</span><br><span class="line"># 添加节点</span><br><span class="line">ETCDCTL_API=3 etcdctl member add wallet0x --peer-urls=&quot;http://10.137.158.119:2380&quot;</span><br><span class="line"># 最后再启动服务</span><br><span class="line"># 其中启动命令 --initial-cluster-state 需要设置为 existing。</span><br></pre></td></tr></table></figure><p>需要先移除故障节点成员，再添加进去成员列表。然后清理掉故障节点的工作目录内容，之后再启动服务，启动后服务会自动同步数据。</p><p>其中启动命令需要设置为 <code>--initial-cluster-state existing</code>。</p><p><img src="/resource/img/2021-12-10-02-19-32.png"></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://www.zhaowenyu.com/etcd-doc/ops/data-space-manage.html">http://www.zhaowenyu.com/etcd-doc/ops/data-space-manage.html</a><br><a href="https://xieys.club/etcd-backup-restore">https://xieys.club/etcd-backup-restore</a><br><a href="https://www.cnblogs.com/lowezheng/p/10307592.html">https://www.cnblogs.com/lowezheng/p/10307592.html</a><br><a href="https://bbotte.github.io/service_config/etcd-cluster-troubleshooting.html">https://bbotte.github.io/service_config/etcd-cluster-troubleshooting.html</a><br><a href="https://www.mytecdb.com/blogDetail.php?id=211">https://www.mytecdb.com/blogDetail.php?id=211</a><br><a href="https://www.cnblogs.com/tencent-cloud-native/p/14893209.html">https://www.cnblogs.com/tencent-cloud-native/p/14893209.html</a><br><a href="http://www.dockone.io/article/2955">http://www.dockone.io/article/2955</a><br><a href="https://mytecdb.com/blogDetail.php?id=199">https://mytecdb.com/blogDetail.php?id=199</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;调研环境说明&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;etcd –version&lt;br&gt;etcd Version: 3.5.1&lt;br&gt;Git SHA: d42e8589e&lt;br&gt;Go Version: go1.17.2&lt;br&gt;Go OS&amp;#</summary>
      
    
    
    
    
    <category term="中间件" scheme="https://noogel.xyz/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>周末在厨房的一些思考</title>
    <link href="https://noogel.xyz/2021/10/31/1.html"/>
    <id>https://noogel.xyz/2021/10/31/1.html</id>
    <published>2021-10-31T00:00:00.000Z</published>
    <updated>2025-07-23T07:30:58.919Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/resource/img/2021-12-10-01-41-35.png"></p><h2 id="概况"><a href="#概况" class="headerlink" title="概况"></a>概况</h2><p>作为一个北方汉子对于面食真的是十分热爱的，尤其是发面后的。从小在家兜包子都是只能看不让参与的，长大后在外面都是买现成的，如今也想自己做一做。也许是从小在家耳濡目染，第一次做整体的效果还不错。<br>宋丹丹老师曾经说过把大象装进冰箱总共要分三步，那么蒸包子总共需要分为如下五步：</p><ol><li>准备原材料</li><li>发面</li><li>调馅</li><li>擀面片</li><li>蒸包子</li></ol><p>可是，真的就是只蒸了包子吗？</p><h2 id="关于蒸包子的一些思考"><a href="#关于蒸包子的一些思考" class="headerlink" title="关于蒸包子的一些思考"></a>关于蒸包子的一些思考</h2><h3 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h3><p>就像我之前聊到过的，复杂的东西是由许多简单的东西组成的。就像蒸包子这件事不一定多么复杂，但也不那么简单，要想做好也是要拆分成上面五个相对简单的步骤执行。作为一个后端工程师，现在做事情总是会带入一些思维模型去看，这个例子是<strong>分治法</strong>来将蒸包子这件事简单化，只要我们把其中简单的每一步做好就可以最终把包子蒸好。</p><h3 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h3><p>当我把包子蒸好以后，发现耗时很长，那么怎么提高效率呢。刨除在网上买菜等菜的时间，大致的时间线如下：</p><p>发面准备：15:00 -&gt; 15:30<br>发面期间：15:30 -&gt; 17:00<br>做、调馅：16:30 -&gt; 17:30<br>擀皮       ：17:30 -&gt; 18:00<br>包、蒸    ：18:00 -&gt; 19:00</p><p>总计人力耗时 3 小时，出锅 18 个包子。如果我要是蒸 36 个包子就要消耗 6 小时的时间吗？答案是要小于 6 小时的，主要原因有以下几点：</p><ol><li>蒸笼仍有一半的空间未用，可以节省掉一次烧水蒸包子的时间。</li><li>每个环节都可以节省准备工具，收拾工具的时间。</li></ol><p>但是我要再多蒸一倍的包子是不是平均耗时会更短，这个就不一定了，如果蒸锅的承载上限就是 36 个包子，那平均耗时就不会再减少。<br><strong>批处理的方案在一定程度上会提高我们的效率，但不会无限提高，而是有一个最优解，这个最优解取决于外在条件。</strong></p><h3 id="并发思维"><a href="#并发思维" class="headerlink" title="并发思维"></a>并发思维</h3><p>以上情况分析的是单人力情况下，如果再有一个人一起做。可以有以下方面提升：</p><ol><li>我们发现面团在 17:00 发好的，擀皮在 17:30 才开始的，中间阻塞的时间在弄馅。把弄馅的时间交给第二个人做，可以减少 30 分钟阻塞。</li><li>发面准备分两个人做可以大致减少 15 分钟耗时。</li><li>两个人一起包包子可以大致减少15分钟耗时。</li><li>额外损耗，例如工具准备上因为多加了一套工具会产生额外耗时。</li></ol><p>最后大致的总人力耗时会大于 3 小时，平均人力耗时在 1.5 到 2小时之间。<strong>并发思维又是我们另外一个手段。</strong></p><h3 id="流水线模型"><a href="#流水线模型" class="headerlink" title="流水线模型"></a>流水线模型</h3><p>上面需要人操作的蒸包子需要四步，其中每一步都会有一些内耗是在每步切换时都需要思考下一步该怎么做，以及准备对应步骤的工具撤掉上一步骤的工具。如果我们厨房能供四人同时使用，并且每人只做一步的事，那么每一步的耗时就会因为熟能生巧而使时间大大缩短。如果这是一家包子店的厨房，那么这四个人就可以源源不断的高效生产包子。<strong>通过流水线模型来提高效率，这也是并发的一种。</strong></p><h3 id="工具化思维"><a href="#工具化思维" class="headerlink" title="工具化思维"></a>工具化思维</h3><p>再假如，北京所有的人早餐都要来这家店吃包子，那么任凭这四个人怎么日夜生产，也不能满足整个北京的需求。如果还是这四个人怎么做？如果恰好其中有一个人学过机械相关的知识并且动手能力又很强，这时候他可以和其他三个人一起交流蒸包子的心得，然后结合整个知识，设计出蒸包子机器，然后找工厂生产出几十台日夜生产，我想北京的包子供应应该就没问题了。他们四个人只需要盯盯机器，坏了修一修就好了。<strong>这里面就用到了工具化思维，可以极大的提高我们的生产效率。工业革命的意义之一就是创造了巨大的生产力。</strong></p><p>说了这么多，下面附上我的蒸包子攻略~</p><h2 id="蒸包子攻略"><a href="#蒸包子攻略" class="headerlink" title="蒸包子攻略"></a>蒸包子攻略</h2><h3 id="准备原材料"><a href="#准备原材料" class="headerlink" title="准备原材料"></a>准备原材料</h3><ul><li>准备面皮<ul><li>面粉 1 kg</li><li>酵母粉 5g</li><li>温水</li></ul></li><li>准备馅（猪肉大葱）<ul><li>猪肉馅 500g</li><li>大葱 500g</li><li>姜、料酒、胡椒粉</li><li>耗油、鸡精、生抽</li><li>香油</li><li>老抽</li></ul></li></ul><h3 id="发面"><a href="#发面" class="headerlink" title="发面"></a>发面</h3><ol><li>用温水冲开酵母粉，混合均匀后加入面粉中和面。</li></ol><p><img src="/resource/img/2021-10-31-12-10-22.png"></p><ol start="2"><li>慢慢慢慢~加水，搅拌成絮状。</li></ol><p><img src="/resource/img/2021-10-31-12-10-29.png"></p><ol start="3"><li>最后柔成光滑的圆面团。</li></ol><p><img src="/resource/img/2021-10-31-12-10-36.png"></p><ol start="4"><li>放到温暖的地方发酵，一小时左右吧，面团最后会放大一倍左右。</li></ol><p>加水的时候需要慢慢加慢慢抓，慢慢会形成一个光滑的圆团，面团的软硬跟水的多少有关，如果面硬的话可以适当加一些水调整软硬程度。</p><h3 id="调馅"><a href="#调馅" class="headerlink" title="调馅"></a>调馅</h3><p><img src="/resource/img/2021-10-31-12-10-48.png"></p><ol><li>趁着面团发酵期间，可以开始准备调馅了。买的是绞好的猪肉馅，然后就是把两颗大葱切碎，切点姜碎进去。</li><li>加入上述的各种调料调整肉馅的口味。由于放了老抽和生抽，盐可以少放或者不放，根据个人口味来看。</li><li>加好以后搅拌均匀就行了。</li></ol><p>其中老抽用来调色，生抽、鸡精、耗油用来调味，胡椒粉、姜碎、料酒用来去腥，加一些香油可以让肉馅变得超级香。</p><h3 id="擀面片"><a href="#擀面片" class="headerlink" title="擀面片"></a>擀面片</h3><p><img src="/resource/img/2021-10-31-12-10-57.png"></p><ol><li>调好馅可以休息一会，待发好面取出来继续揉捏，直到里面没有气泡了。</li><li>然后揉成一个细条状，用刀切成一段一段的。用手掌按成扁圆的。</li><li>用擀面杖一点点擀成扁片，厚度比饺子皮厚一些，标准的面片是边缘较薄中心较厚的圆形。</li></ol><h3 id="蒸包子"><a href="#蒸包子" class="headerlink" title="蒸包子"></a>蒸包子</h3><p><img src="/resource/img/2021-10-31-12-11-05.png"></p><ol><li>准备一个篦子，上面放好屉布，待包子包好放上去。至于兜包子的手法直接网上查吧。</li><li>准备好蒸锅，放上包子开火后蒸20分钟左右即可，关火后放 5分钟。</li><li>最后的出锅，因为包子会变大导致互相黏连，可以准备一些清水滴到屉布和包子连接处湿润，这样包子就可以完好的取下了。</li></ol><p>最后来一张出锅照，年轻人的第一锅包子就这样做好了。</p><p><img src="/resource/img/2021-10-31-12-11-13.png"></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>工作和生活中我们会遇到很多事和物，事事物物之间有很多共通之处，包括问题的产生和解决办法。不同表象的背后相同的本质的东西是思维方式还是抽象模型？看清它们，能带给我的是做出好吃的包子，不仅仅是这些，还有更多。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/resource/img/2021-12-10-01-41-35.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;概况&quot;&gt;&lt;a href=&quot;#概况&quot; class=&quot;headerlink&quot; title=&quot;概况&quot;&gt;&lt;/a&gt;概况&lt;/h2&gt;&lt;p&gt;作为一个北方汉子对于面食真</summary>
      
    
    
    
    
    <category term="效率" scheme="https://noogel.xyz/tags/%E6%95%88%E7%8E%87/"/>
    
  </entry>
  
  <entry>
    <title>软件架构与系统复杂性</title>
    <link href="https://noogel.xyz/2021/10/22/1.html"/>
    <id>https://noogel.xyz/2021/10/22/1.html</id>
    <published>2021-10-22T00:00:00.000Z</published>
    <updated>2025-07-23T07:30:58.916Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/resource/img/2021-10-29-02-16-30.png"></p><h2 id="什么是复杂性"><a href="#什么是复杂性" class="headerlink" title="什么是复杂性"></a>什么是复杂性</h2><p>复杂或复杂性与简单相对立，那么复杂是什么？它是我们大脑中的一个概念，但是我在网上找不到一个给复杂恰当的定义描述，它会有不同的解释。<br>其中洛克在《人类理解论》中说道：『一些思想是由简单的思想组合而成，我称此为复杂；比如美、感激、人、军队、宇宙等。』<br>作为研究复杂系统的专家 Melanie Mitchell，也没有给出一个明确的公认的定义。她在《复杂》一书中给出了复杂系统加以定义：『复杂系统是由大量组分组成的网络，不存在中央控制，通过简单运作规则产生出复杂的集体行为和复杂的信息处理，并通过学习和进化产生适应性。』<br>上述复杂系统中的组分对应软件系统中的组成部分，基于不同粒度可以是对象、函数、类、包、模块、组件和服务等。每一部分都应该是相对单一的职责，细粒度部分之间耦合提供更粗粒度功能，不同组分之间相互协作来提供系统功能，继而组合成我们复杂的软件系统。</p><h2 id="软件系统复杂性由何而来"><a href="#软件系统复杂性由何而来" class="headerlink" title="软件系统复杂性由何而来"></a>软件系统复杂性由何而来</h2><p>计算机的产生对我们生产生活产生的影响不言而喻，其中软件系统的功能是随着我们实际生活需求的变化而变化的。人有七情六欲带来的各种需求，接收信息的方式主要是视觉、听觉。而机器擅长的只是简单的逻辑处理和数值计算，两者之间有着巨大的鸿沟。如何让机器提供视觉和听觉的手段来满足人们的需求，这里抛开硬件不谈，软件层面有操作系统提供基本的软件运行环境。<br>软件系统则只需要专注于如何组织和管理数据来满足人们的工作生活娱乐需求，一方面要关注人的需求和需求变化，另一方面要关注机器层面能提供的计算能力。<br>软件系统的复杂性来自于两个方面，一方面是需求侧复杂，导致大多数系统的功能都难以理解；另一方面是难以把控需求的变化，虽然我们遵循一些设计原则可以对未来进行一些预判，但还是存在不可预测的风险。</p><h2 id="如何度量复杂度"><a href="#如何度量复杂度" class="headerlink" title="如何度量复杂度"></a>如何度量复杂度</h2><p>在《复杂》一书中作者列举了不同角度可能度量复杂性的方法。</p><ul><li>生物学上尝试通过基因组的规模来度量。</li><li>信息学上尝试通过熵、信息量、交互信息来度量。</li><li>用算法信息量度量复杂性（能够产生对事物完整描述的最短计算机程序的长度。）</li><li>此外还有逻辑深度、热力学深度、分形维度等方面。</li></ul><p>复杂度并没有一个统一明确的度量方式，我们可以站在一个角度上对具体的某类或粒度提供一个可供参考的度量方法。不论我们如何度量，我们在开发软件系统中的一个重要目标就是控制和降低系统复杂度。在巨著《人月神话》中提出了两个重要概念：</p><ul><li>本质复杂度：指由于一问题的本质不适合简单的求解方式，所有可行的求解方式都很复杂的情形。</li><li>偶然复杂度：指电脑软件开发过程中所引入不必要的复杂度。</li></ul><p>偶然复杂度不是待求解问题的本质，相对而言， 本质复杂度和待求解问题的本质有关，是无法避免的。偶然复杂度一般是因为选用求解问题的方法时所引入的。</p><p>在源代码层面为了描述工程质量有以下两个方面衡量：</p><ul><li>圈复杂度：根据代码中的路径数量计算的循环复杂性。每当一个函数的控制流发生分裂时，复杂度计数器就会增加1。每个函数的最小复杂度为1。由于关键字和功能的不同，这种计算方法在语言上略有不同。以 Java 为例增加复杂度的关键字有：if, for, while, case, catch, throw, &amp;&amp;。</li><li>认知复杂度：是由sonarQube设计的一个算法，算法将一段程序代码被理解的复杂程度，估算成一个整数——可以等同于代码的理解成本。作为指导程序员编写“既可测试又可维护”的方法。</li></ul><p>在认知复杂度的计算方法中主要基于以下三条规则：</p><ol><li>忽略那些允许将多个语句可读性地速记为一个的结构。</li><li>在代码的线性流程中，每中断一次就累加 1。</li><li>当断流结构被嵌套时难度累加 1。</li></ol><p>下面实例对比两种复杂度度量方法的差异，在不同写法上圈复杂度的统计和认知复杂度的统计有何差异。</p><p><img src="/resource/img/2021-10-29-02-16-53.png"></p><p>上图是两种写法在圈复杂度的统计方法，得出的值都是 4，也就是从逻辑上来说是相同的。但是在可读性上来说，明显右侧的 switch 代码更高。认知复杂度就是为了度量人的易于理解性上存在的。</p><p><img src="/resource/img/2021-10-29-02-17-00.png"></p><p>以上是认知复杂度算法给这两种方法打出了明显不同的分数，这些分数更能反映出它们的相对可理解性。更具体的内容可以查看 <a href="https://www.sonarsource.com/docs/CognitiveComplexity.pdf">CognitiveComplexity</a> 。</p><h2 id="如何管理系统复杂度"><a href="#如何管理系统复杂度" class="headerlink" title="如何管理系统复杂度"></a>如何管理系统复杂度</h2><p>架构的本质目标就是管理复杂度，而管理复杂度有以下三种有效的手段：</p><ul><li>抽象：从众多的具体事物当中抽取共同的、本质的属性，摒弃差异的非本质属性，简化描述形成概念。<br><img src="/resource/img/2021-10-29-02-17-13.png"></li><li>分治：把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。<br><img src="/resource/img/2021-10-29-02-17-22.png"></li><li>领域知识：是指一组有内在联系的知识的集合，它往往与特定的职业、研究方向、兴趣、社群或文化圈层等相关联。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/resource/img/2021-10-29-02-16-30.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;什么是复杂性&quot;&gt;&lt;a href=&quot;#什么是复杂性&quot; class=&quot;headerlink&quot; title=&quot;什么是复杂性&quot;&gt;&lt;/a&gt;什么是复杂性&lt;/h2&gt;</summary>
      
    
    
    
    
    <category term="架构" scheme="https://noogel.xyz/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>技术组件调研模板V1（以 Drools 为例）</title>
    <link href="https://noogel.xyz/2021/10/20/1.html"/>
    <id>https://noogel.xyz/2021/10/20/1.html</id>
    <published>2021-10-20T00:00:00.000Z</published>
    <updated>2025-07-23T07:30:58.915Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/resource/img/2021-12-10-01-44-47.png"></p><h2 id="初步认知"><a href="#初步认知" class="headerlink" title="初步认知"></a>初步认知</h2><blockquote><p>以 Drools 为例子</p></blockquote><h3 id="这个组件是什么，有什么功能？"><a href="#这个组件是什么，有什么功能？" class="headerlink" title="这个组件是什么，有什么功能？"></a>这个组件是什么，有什么功能？</h3><blockquote><p>Drools 是一个基于Charles Forgy’s的RETE算法的，易于访问企业策略、易于调整以及易于管理的开源业务规则引擎，符合业内标准，速度快、效率高。业务分析师人员或审核人员可以利用它轻松查看业务规则，从而检验是否已编码的规则执行了所需的业务规则。<br><strong>Drools相关概念</strong></p><ul><li>事实（Fact）：对象之间及对象属性之间的关系</li><li>规则（rule）：是由条件和结论构成的推理语句，一般表示为if…Then。一个规则的if部分称为LHS，then部分称为RHS。</li><li>模式（module）：就是指IF语句的条件。这里IF条件可能是有几个更小的条件组成的大条件。模式就是指的不能在继续分割下去的最小的原子条件。</li></ul><p>Drools通过 事实、规则和模式相互组合来完成工作，drools在开源规则引擎中使用率最广，但是在国内企业使用偏少，保险、支付行业使用稍多。</p></blockquote><h3 id="能解决什么问题？"><a href="#能解决什么问题？" class="headerlink" title="能解决什么问题？"></a>能解决什么问题？</h3><blockquote><p><strong>「规则引擎主要完成的就是将业务规则从代码中分离出来。」</strong> 在规则引擎中，利用规则语言将规则定义为if-then的形式，if中定义了规则的条件，then中定义了规则的结果。规则引擎会基于数据对这些规则进行计算，找出匹配的规则。这样，当规则需要修改时，无需进行代码级的修改，只需要修改对应的规则，可以有效减少代码的开发量和维护量。</p></blockquote><h3 id="这个组件对比竞品有什么优势和劣势？"><a href="#这个组件对比竞品有什么优势和劣势？" class="headerlink" title="这个组件对比竞品有什么优势和劣势？"></a>这个组件对比竞品有什么优势和劣势？</h3><blockquote><p>易用性、广泛性、高性能、高可用、高一致性等方面。<br>Java开源的规则引擎有：Drools、Easy Rules、Mandarax、IBM ILOG。使用最为广泛并且开源的是Drools。<br>规则引擎优点</p><ul><li>声明式编程</li><li>逻辑和数据分离</li><li>速度和可扩展性</li><li>知识集中化</li></ul><p>规则引擎缺点</p><ul><li>复杂性提高</li><li>需要学习新的规则语法</li><li>引入新组件的风险</li></ul></blockquote><h2 id="原理了解"><a href="#原理了解" class="headerlink" title="原理了解"></a>原理了解</h2><h3 id="这个组件实现机制是什么样的？"><a href="#这个组件实现机制是什么样的？" class="headerlink" title="这个组件实现机制是什么样的？"></a>这个组件实现机制是什么样的？</h3><blockquote><p>Drools规则引擎的结构示意图：<br><img src="/resource/img/2021-10-20-22-18-38.png"><br><img src="/resource/img/2021-10-20-22-18-46.png"><br>在 Drools 中，规则被存 放在 Production Memory（规则库）中，推理机要匹配的 facts（事实）被存在 Working Memory（工作内存）中。当时事实被插入到工作内存中后，规则引擎会把事实和规则库里的模式进行匹配，对于匹配成功的规则再由 Agenda 负责具体执行推理算法中被激发规则的结论部分，同时 Agenda 通过冲突决策策略管理这些冲突规则的执行顺序。<br>Drools 中规则冲突决策策略有</p><ul><li>优先级策略</li><li>复杂度优先策略</li><li>简单性优先策略</li><li>广度策略</li><li>深度策略</li><li>装载序号策略</li><li>随机策略</li></ul></blockquote><h3 id="使用了什么算法-模型-框架？"><a href="#使用了什么算法-模型-框架？" class="headerlink" title="使用了什么算法\模型\框架？"></a>使用了什么算法\模型\框架？</h3><blockquote><p><strong>Rete 算法</strong><br>最初是由卡内基梅隆大学的 Charles L.Forgy 博士在 1974 年发表的论文中所阐述的算法 , 该算法提供了专家系统的一个高效实现。自 Rete 算法提出以后 , 它就被用到一些大型的规则系统中 , 像 ILog、Jess、JBoss Rules 等都是基于 RETE 算法的规则引擎。</p><p>Rete 在拉丁语中译为”net”，即网络。Rete 匹配算法是一种进行大量模式集合和大量对象集合间比较的高效方法，通过网络筛选的方法找出所有匹配各个模式的对象和规则。</p><p>其核心思想是将分离的匹配项根据内容动态构造匹配树，以达到显著降低计算量的效果。Rete 算法可以被分为两个部分：规则编译和规则执行。当Rete算法进行事实的断言时，包含三个阶段：匹配、选择和执行，称做 match-select-act cycle。<br><img src="/resource/img/2021-10-20-22-19-00.png"><br>Drools 中的 Rete 算法被称为 ReteOO，表示 Drools 为面向对象系统（Object Oriented systems）增强并优化了 Rete 算法。</p></blockquote><h2 id="上手使用"><a href="#上手使用" class="headerlink" title="上手使用"></a>上手使用</h2><h3 id="使用场景有哪些？"><a href="#使用场景有哪些？" class="headerlink" title="使用场景有哪些？"></a>使用场景有哪些？</h3><blockquote><p>从Drools规则引擎的使用模版来看，输入、输出和判断三个中，判断是变化的，而输入和输出是基本固定的，所以适用的场合可以分为下面几种：</p><ul><li>输入和输出的参数不变，即：规则文件接收固定的参数，产生固定的输出。比如：根据货物重量计算运输价格，输入参数是货物重量，规则根据级差价格表，输出运输价格。</li><li>输入和输出的JavaBean Object不变，即：规则文件接收固定类型的JavaBean，产生固定类型的JavaBean。比如：根据顾客信息和当前购物信息计算优惠价格，输入参数是顾客当前的类别（VIP客户等）和当前购物的种类、数量，规则根据顾客类别、商品种类和购买数量输出优惠价格。</li></ul><p>所以，规则引擎适用于「问题确定」的场景，并且存在比较复杂的业务规则并且业务规则会「频繁变动」的系统。比如：</p><ul><li>风险控制系统（风险贷款、风险评估）</li><li>反欺诈项目（银行贷款、征信验证）</li><li>决策平台系统（财务计算）</li><li>促销平台系统（满减、打折、加价购）</li></ul></blockquote><h3 id="在项目中使用上需要怎么做？"><a href="#在项目中使用上需要怎么做？" class="headerlink" title="在项目中使用上需要怎么做？"></a>在项目中使用上需要怎么做？</h3><blockquote><p>TODO</p></blockquote><h3 id="在使用过程中容易踩到哪些坑？"><a href="#在使用过程中容易踩到哪些坑？" class="headerlink" title="在使用过程中容易踩到哪些坑？"></a>在使用过程中容易踩到哪些坑？</h3><blockquote><p>TODO</p></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p>网络文章、杂志专栏、论文等<br><a href="https://blog.csdn.net/Taobaojishu/article/details/108231696">https://blog.csdn.net/Taobaojishu/article/details/108231696</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/resource/img/2021-12-10-01-44-47.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;初步认知&quot;&gt;&lt;a href=&quot;#初步认知&quot; class=&quot;headerlink&quot; title=&quot;初步认知&quot;&gt;&lt;/a&gt;初步认知&lt;/h2&gt;&lt;blockqu</summary>
      
    
    
    
    
    <category term="效率" scheme="https://noogel.xyz/tags/%E6%95%88%E7%8E%87/"/>
    
  </entry>
  
  <entry>
    <title>旅游攻略模板（以西藏为例）</title>
    <link href="https://noogel.xyz/2021/09/08/1.html"/>
    <id>https://noogel.xyz/2021/09/08/1.html</id>
    <published>2021-09-08T00:00:00.000Z</published>
    <updated>2025-07-23T07:30:58.919Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>模板的好处就在于可以让你快速且全面的规划方案，一些你能想到和不能想到的地方。既能避免你在做旅游规划时漏掉什么，又能节省你思考的时间。有了模板你只需要按照大纲去调研即可。</strong></p><p><strong>如果你旅游前需要详细规划，那么这个模板很适合你。</strong><br><strong>如果你是想走开车就走的那种，可以跳过这篇。</strong></p><p><strong>模板按需填充即可，比如去西藏就需要特别关注海拔信息。去三亚就需要关注一下日出日落和潮汐时间。下面是我在做西藏旅游攻略做的一个简单攻略，仅供参考。</strong></p></blockquote><span id="more"></span><h2 id="物品清单（速查）"><a href="#物品清单（速查）" class="headerlink" title="物品清单（速查）"></a>物品清单（速查）</h2><table><thead><tr><th>类别</th><th>明细（气温：白天 15 - 20 ；夜间 5 - 10）</th></tr></thead><tbody><tr><td>其它装备</td><td>墨镜（镜夹）、遮阳帽、魔术头巾</td></tr><tr><td>上衣类</td><td>保暖衣两件<br>冲锋衣（防风）<br>轻便羽绒服</td></tr><tr><td>下衣类</td><td>保暖裤两件<br>冲锋裤（防风）</td></tr><tr><td>鞋袜</td><td>徒步鞋一双<br>薄袜 5 双</td></tr><tr><td>洗漱类</td><td>旅行牙刷牙膏、便携洗发露、毛巾，（不要洗澡）</td></tr><tr><td>工具类</td><td>充电装备：充电宝 2 个、充电器、充电线 2 根<br>拍摄装备：相机一个、电池两块、三脚架、B门<br>垃圾袋 10 个、湿巾 50 片、保温杯、口罩10个</td></tr><tr><td>关键物品</td><td>证件信息：身份证、社保卡、驾驶证<br>现金：500 分两处</td></tr><tr><td>关键药品</td><td>药品信息：藿香正气液（治水土不服）、感冒药、头晕药、葡萄糖<br><del>高原红景天（进藏前7天开始服用到出藏）</del>（没用）<br><img src="/resource/img/2021-12-12-23-25-09.png"><br>『我去过27次藏区，带过300多人，我的经验是在头疼腿疼时候，遵医嘱服用8分钱一包的阿咖酚散就很灵验』</td></tr></tbody></table><h2 id="前期规划"><a href="#前期规划" class="headerlink" title="前期规划"></a>前期规划</h2><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><ol><li>了解西藏的人文地理</li><li>拍风景照，山川湖泊</li></ol><h3 id="行程安排"><a href="#行程安排" class="headerlink" title="行程安排"></a>行程安排</h3><table><thead><tr><th>日期（星期）</th><th>行程</th><th>行程安排</th><th>其他备注</th></tr></thead><tbody><tr><td>9-30</td><td></td><td>准备做核酸检测</td><td></td></tr><tr><td>10-1 五</td><td>0</td><td>北京准备</td><td>理短发</td></tr><tr><td>10-2 六</td><td>1</td><td>北京 -&gt; 正定 待定<br>西藏航空 TV9980 正定 T2 18:25 -&gt; 贡嘎 T3 22:45</td><td>9-18 买票<br>洗澡洗头</td></tr><tr><td>10-3 日</td><td>2</td><td></td><td></td></tr><tr><td>10-4 一</td><td>3</td><td></td><td></td></tr><tr><td>10-5 二</td><td>4</td><td></td><td>洗头</td></tr><tr><td>10-6 三</td><td>5</td><td></td><td></td></tr><tr><td>10-7 四</td><td>6</td><td></td><td></td></tr><tr><td>10-8 五（假）</td><td>7</td><td></td><td>洗头</td></tr><tr><td>10-9 六（假）</td><td>8</td><td></td><td></td></tr><tr><td>10-10 日</td><td>9</td><td></td><td></td></tr><tr><td>10-11 一（假）</td><td>10</td><td>西藏航空 TV9927 贡嘎 T3 12:25 -&gt; 滨海T2 17:55<br>天津 -&gt; 北京 待定</td><td>9-27 买票<br>回京洗头</td></tr></tbody></table><h3 id="吃喝计划"><a href="#吃喝计划" class="headerlink" title="吃喝计划"></a>吃喝计划</h3><table><thead><tr><th>地点</th><th>推荐菜品</th><th>费用&#x2F;注意事项</th></tr></thead><tbody><tr><td>拉萨</td><td>酥油茶</td><td></td></tr><tr><td></td><td>糌粑</td><td></td></tr><tr><td></td><td>藏式白肠</td><td></td></tr><tr><td></td><td>藏香猪</td><td></td></tr><tr><td></td><td>鲁朗石锅鸡</td><td></td></tr></tbody></table><h3 id="玩乐计划"><a href="#玩乐计划" class="headerlink" title="玩乐计划"></a>玩乐计划</h3><p><strong>景点分布图</strong></p><p><img src="/resource/img/2021-12-12-23-39-51.png"></p><p><strong>景点明细</strong></p><table><thead><tr><th>景点</th><th>地点</th><th>海拔</th><th>图片</th><th>备注</th></tr></thead><tbody><tr><td>那根拉山口</td><td>当雄县境内，是通往纳木错的必经之地，也是藏民心中的神圣之地。</td><td>海拔达5190米</td><td></td><td></td></tr><tr><td>圣象天门</td><td>那曲地区班戈县青龙乡5村境内 ，圣湖纳木措北部恰多朗卡岛上。</td><td>4800米</td><td></td><td>日落星空银河<br>宿青龙小镇</td></tr><tr><td>纳木错</td><td>位于西藏自治区中部，是西藏第二大湖泊，也是中国第三大的咸水湖。</td><td>湖面海拔4718米</td><td></td><td></td></tr><tr><td>藏北草原</td><td></td><td></td><td></td><td></td></tr><tr><td>念青唐古拉山口</td><td></td><td></td><td></td><td>？？</td></tr><tr><td>羊八井温泉</td><td>拉萨市西北91.8公里的当雄县境内</td><td>海拔4231米</td><td></td><td>途径</td></tr><tr><td>尼木县</td><td>居雅鲁藏布江中游北岸，地势是北高南低，尼木河两岸为代表的河谷地区，地势平坦。</td><td>海拔: 3818米</td><td></td><td></td></tr><tr><td>日喀则</td><td></td><td>日喀则市区海拔3836米，市区海拔要比拉萨高。</td><td></td><td>宿</td></tr><tr><td>嘉措拉山口</td><td></td><td>5248</td><td></td><td>待一小时</td></tr><tr><td>定日</td><td>日喀则市</td><td>驻地协格尔海拔4300米。平均海拔5000米。</td><td></td><td></td></tr><tr><td>珠峰大本营</td><td></td><td>5200</td><td></td><td>看星空日落</td></tr><tr><td>加乌拉山口</td><td>前往珠穆朗玛峰大本营途中的一个垭口。在世界上唯一可以观赏5座8000米级雪峰的观景平台。</td><td>海拔5210米</td><td></td><td>一眼看尽5座8km雪山</td></tr><tr><td>奇林峡</td><td>日喀则地区定结县，处于尼泊尔、印度边境。</td><td>5018米</td><td></td><td>大自然的奇观</td></tr><tr><td>扎什伦布寺</td><td>日喀则市城西的尼玛山东面山坡上</td><td>海拔高度3874米</td><td></td><td></td></tr><tr><td>卡若拉冰川</td><td></td><td>冰舌前沿海拔5560米，观看卡若拉冰川的地方海拔约有5400米</td><td></td><td></td></tr><tr><td>拉满水库</td><td>日喀则地区江孜县龙马乡境内年楚河上游</td><td>坝址区高程4200~4300米</td><td></td><td></td></tr><tr><td>羊卓雍措（羊湖）</td><td></td><td>湖面海拔4,441米。</td><td></td><td></td></tr><tr><td>日托寺</td><td>坐落在羊湖内湖深处半岛山顶的寺庙</td><td></td><td></td><td></td></tr><tr><td>以下七日团景点</td><td></td><td></td><td></td><td></td></tr><tr><td>思金拉措</td><td>墨竹工卡县日多乡东南、山南地区桑日县增期乡以北，距川藏公路（318国道）约6公里，距墨竹工卡县城66公里，距拉萨市区124公里</td><td>海拔4500米</td><td></td><td></td></tr><tr><td>林芝</td><td>西藏东南部，雅鲁藏布江中下游</td><td>平均海拔3100米</td><td></td><td></td></tr><tr><td>雅鲁藏布大峡谷</td><td>主体在墨脱县</td><td>2880米</td><td></td><td></td></tr><tr><td>索松村</td><td>林芝市米林县派镇下辖自然村</td><td>3012米</td><td></td><td></td></tr><tr><td>米林朗县</td><td>林芝市，位于朗县位于林芝市西南部</td><td>平均海拔3200米</td><td></td><td></td></tr><tr><td>亲猴台</td><td></td><td></td><td></td><td></td></tr><tr><td>达古峡谷</td><td>山南市桑日县与加查县交界处(属桑日县增期乡达古村，距桑日县县城40公里)，离泽当有80km，距离拉萨220公里</td><td>3200米</td><td></td><td></td></tr><tr><td>拉姆拉措</td><td>“拉姆拉措”正是被莲花捧起来的圣湖。</td><td>4000米以上</td><td></td><td></td></tr><tr><td>加查&#x2F;泽当</td><td></td><td></td><td></td><td></td></tr><tr><td>岗巴拉山</td><td>西藏山南地区浪卡子县和贡嘎县之间</td><td>4990米</td><td></td><td></td></tr><tr><td>推村</td><td>拉萨西南300多公里的蒙达岗日雪山脚下、普姆雍措湖畔，是世界上海拔最高的行政村落</td><td>5070米</td><td></td><td></td></tr><tr><td>杰岗日神山</td><td></td><td></td><td></td><td></td></tr><tr><td>测东拉错</td><td></td><td></td><td></td><td></td></tr><tr><td>色林措</td><td>申扎、班戈和尼玛3县交界处，冈底斯山北麓，申扎县以北。</td><td>湖面海拔4530m</td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p><strong>旅游团对比</strong></p><table><thead><tr><th>编号</th><th>A</th><th>B</th><th>C1</th><th>C2</th><th>D1</th><th>D2</th><th>E1</th><th>E2</th><th>F</th></tr></thead><tbody><tr><td>渠道特点</td><td>微信关系5-4</td><td>国营飞猪房车团5-4</td><td>同A-国营飞猪5-4</td><td></td><td>同A-国营飞猪5-4</td><td></td><td>国营飞猪4-3</td><td>国营飞猪4-3</td><td>国营飞猪7-6</td></tr><tr><td>价格</td><td>3000</td><td>5000</td><td>2780</td><td>4680</td><td>2880</td><td>4780</td><td>1560-1880</td><td>2560</td><td>4180</td></tr><tr><td>链接</td><td></td><td><a href="https://traveldetail.fliggy.com/item.htm?spm=a1z10.3-b.w4011-2629574373.55.4c3167ffsmBSjx&id=655500767069&rn=ea8375367992a518f3d48057f2606b69&abbucket=17">【拉萨国企】西藏拉萨旅游珠峰大本营圣象天门纳木错5天4晚五日游-旅游度假-飞猪</a></td><td><a href="https://traveldetail.fliggy.com/item.htm?spm=a1z10.3-b.w4011-2629574373.46.4c3167ffsmBSjx&id=642153406458&rn=ea8375367992a518f3d48057f2606b69&abbucket=17">【拉萨国企】圣象天门珠峰大本营纳木错5天4晚五日游西藏拉萨旅游-旅游度假-飞猪</a></td><td></td><td></td><td></td><td><a href="https://traveldetail.fliggy.com/item.htm?spm=a1z10.3-b.w4011-2629574373.49.4c3167ffsmBSjx&id=581376564789&rn=ea8375367992a518f3d48057f2606b69&abbucket=17">【拉萨国企】珠峰大本营羊湖纳木错圣象天门4天西藏拉萨旅游四日-旅游度假-飞猪</a></td><td></td><td><a href="https://traveldetail.fliggy.com/item.htm?spm=a1z10.3-b.w4011-2629574373.52.4c3167ffsmBSjx&id=650482463613&rn=ea8375367992a518f3d48057f2606b69&abbucket=17">西藏拉萨林芝山南羊湖珠峰大本营纳木错圣象天门全景大环线7日游-旅游度假-飞猪</a></td></tr><tr><td>行程</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>行程特点</td><td>第一天去的海拔5000米，容易有高反。</td><td>第一天海拔4400，第二天才到 5000，舒适。</td><td>第一天去的海拔5000米，容易有高反。</td><td></td><td>* 第一天去的海拔5000米，容易有高反。<br>* 比A多了羌塘无人区行程，都在车上。</td><td></td><td>* 第一天去的海拔5000米，容易有高反。<br>* 自己做动车从日喀则回拉萨。<br>* 比五天团少羊卓雍措景点。</td><td></td><td>大环线，海拔由低到高。<br>穿越羌塘无人区。</td></tr><tr><td>车辆</td><td></td><td>4-5人房车团配无人机</td><td>7-17座正规旅游车</td><td>5座越野车</td><td>7-17座正规旅游车</td><td>5座越野车</td><td>7-17座正规旅游车</td><td>7-9座正规旅游车，无人机</td><td>无车辆信息</td></tr><tr><td>住宿</td><td>1晚圣象天门藏家民宿多人间或多人帐篷（通铺）+日喀则2晚域腾酒店或同等级别酒店+1晚珠峰营地藏家民宿（多人间）或帐篷（通铺）</td><td>日托寺、珠峰、圣象天门住房车上（房车无法洗澡），日喀则住三星或三钻酒店可洗澡，双人标间单床位价格，单人出行我们尽量拼房，如无人拼或不愿拼则需补房差。</td><td>近似A</td><td>近似A</td><td>近似A</td><td>近似A</td><td>近似A</td><td>近似A</td><td>近似A</td></tr><tr><td>退改规则</td><td>订单生效后，因买家原因取消订单的，费用扣除标准如下：行程开始前【7日以上】扣除20%违约金；行程开始前【4-6日】扣除30%违约金；行程开始前【1-3日】扣除50%违约金；行程开始当天扣除100%违约金。</td><td>【买家违约】订单生效后，因买家原因取消订单的，费用扣除标准如下：<br>【商家违约】订单生效后，因商家原因取消订单的，除全额退款外，商家还应向买家支付下表对应金额的违约金：<br>行程开始前    违约金（占订单总费用）<br>7日以上    0%；4—6日    20%；1—3日    40%；行程开始当日    60%</td><td>同 B</td><td>同 B</td><td>同 B</td><td>同 B</td><td>同 B</td><td>同 B</td><td>同 B</td></tr><tr><td>提醒事项</td><td>无右侧提醒</td><td>②.因珠峰大本营海拔较高达5200左右，所有含珠峰行程司机均会带大家前往氧气及大衣补给站点(医用型钢瓶氧气3L装约300，10L装大氧气约600左右，军大衣100左右，费用较高)，请根据自身身体是否有高反等情况自愿选择绝无强制消费，我社建议在拉萨提前自带便携社按压氧气(1L装约20左右一瓶，各大超市药店均有售，多带两个一般即可)，此氧气补给点并非购物点环节，有人需要有人不需要请理性客观对待及选择，特此告知说明。</td><td></td><td></td><td></td><td></td><td></td><td></td><td>同A</td></tr></tbody></table><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>PS: 当地的风俗禁忌；</p><p>特别提示：出现高原反应的最大因素，是心里因素！心里的恐慌和压力，是造成高反的最主要原因！所以，我们应该放松心态去旅行。</p><ol><li>严重高血压、哮喘病、心脏病这三类患者不建议进藏，一般旅行社都不接待。个别轻微症状可以先咨询医生建议。</li><li>身体健康的人都可以进藏，不需要提前做什么运动。反而，运动员进藏很容易高原反应。所以，进藏前多休息，禁剧烈运动。</li><li>可以准备一些普通药物，包括胃舒平，感冒药，头晕药等在行李上。切忌，严重感冒患者不要进藏。</li><li>西藏属于少数民族地区，人生地不熟，建议进藏前咨询好西藏当地的旅行社采取跟团游为佳。</li><li>西藏当地的银行主要是四家国有银行，中行、建行、农行、工行。农行的覆盖率最为广泛。取款的ATM机在拉萨市内有，下地区较少。</li><li>进藏前避免大量饮食，减少吸烟和喝酒。</li><li>西藏很多寺庙禁止穿短裙、短袖、戴帽子和墨镜入内的。</li><li>很多寺庙都是不允许拍照的，偏远地区的悠谢寺庙可以拍照，不过需要经过同意，不要随意对着朝圣者拍照，要拍照时必须经过别人允许。</li><li>尊重当地文化信仰，请勿在西藏谈论政治及宗教信仰。</li><li>藏民普遍都是热情好客的，未经允许不要对他们的脸拍照。请勿用手触摸藏族人的头，尤其是小朋友的。</li><li>在西藏天葬是不允许陌生人观看的，请尊重当地习俗，不要围观。</li><li>西藏很多湖都是当地的圣湖，游玩时切勿脱鞋下水。</li><li>没有高反或轻微高反不要吸氧，吸氧是有依赖性的，有明显高反头疼的可以吃抗高反药物、出现呕吐的喝葡萄糖，会有明显改善。</li></ol><p>珠峰大本营需要提前办理边防证。</p><h3 id="关于高反"><a href="#关于高反" class="headerlink" title="关于高反"></a>关于高反</h3><p><img src="/resource/img/2021-12-12-23-26-15.png"></p><p><img src="/resource/img/2021-12-12-23-26-28.png"></p><p><a href="https://www.zhihu.com/question/21451875">https://www.zhihu.com/question/21451875</a></p><h2 id="地理信息"><a href="#地理信息" class="headerlink" title="地理信息"></a>地理信息</h2><h3 id="日出日落时间表"><a href="#日出日落时间表" class="headerlink" title="日出日落时间表"></a>日出日落时间表</h3><p>拉萨</p><table><thead><tr><th>日期</th><th>日出</th><th>日中</th><th>日落</th></tr></thead><tbody><tr><td>2021年10月01日 周五</td><td>07:48:46</td><td>13:45:02</td><td>19:41:19</td></tr><tr><td>2021年10月02日 周六</td><td>07:49:20</td><td>13:44:43</td><td>19:40:07</td></tr><tr><td>2021年10月03日 周日</td><td>07:49:54</td><td>13:44:24</td><td>19:38:55</td></tr><tr><td>2021年10月04日 周一</td><td>07:50:28</td><td>13:44:06</td><td>19:37:44</td></tr><tr><td>2021年10月05日 周二</td><td>07:51:03</td><td>13:43:48</td><td>19:36:33</td></tr><tr><td>2021年10月06日 周三</td><td>07:51:38</td><td>13:43:30</td><td>19:35:22</td></tr><tr><td>2021年10月07日 周四</td><td>07:52:13</td><td>13:43:13</td><td>19:34:12</td></tr><tr><td>2021年10月08日 周五</td><td>07:52:48</td><td>13:42:56</td><td>19:33:03</td></tr><tr><td>2021年10月09日 周六</td><td>07:53:24</td><td>13:42:39</td><td>19:31:54</td></tr><tr><td>2021年10月10日 周日</td><td>07:54:01</td><td>13:42:23</td><td>19:30:46</td></tr><tr><td>2021年10月11日 周一</td><td>07:54:37</td><td>13:42:08</td><td>19:29:38</td></tr></tbody></table><p>参考：[拉萨市 2021年10月份 日出日落时刻查询 - 拉萨市日出日没时刻 - 查询拉萨市日出时间 - 查询拉萨市日落时间 (bmcx.com)](<a href="https://richurimo.bmcx.com/lasa__time__2021_10__richurimo/">https://richurimo.bmcx.com/lasa__time__2021_10__richurimo&#x2F;</a>)</p><h3 id="潮汐表"><a href="#潮汐表" class="headerlink" title="潮汐表"></a>潮汐表</h3><table><thead><tr><th>日期</th><th>满潮</th><th>干潮</th><th>满潮</th><th>干潮</th></tr></thead></table><h3 id="天气趋势（穿衣趋势）"><a href="#天气趋势（穿衣趋势）" class="headerlink" title="天气趋势（穿衣趋势）"></a>天气趋势（穿衣趋势）</h3><p><a href="http://www.weather.com.cn/radar/">天气地图 (weather.com.cn)</a></p><h4 id="气温特点"><a href="#气温特点" class="headerlink" title="气温特点"></a>气温特点</h4><p>拉萨气温</p><p><img src="/resource/img/2021-12-12-23-26-49.png"></p><p><a href="http://www.weather.com.cn/weather40d/101140101.shtml">【拉萨天气】拉萨40天天气预报,拉萨更长预报,拉萨天气日历,拉萨日历,15天天气预报,天气预报一周</a></p><p>北京气温</p><p>TODO</p><h4 id="天气变化"><a href="#天气变化" class="headerlink" title="天气变化"></a>天气变化</h4><p>天气多变不可琢磨</p><h3 id="海拔信息"><a href="#海拔信息" class="headerlink" title="海拔信息"></a>海拔信息</h3><table><thead><tr><th>地点</th><th>经纬</th><th>海拔（米）</th></tr></thead><tbody><tr><td>拉萨</td><td>东经91°06′，北纬29°36′</td><td>3650</td></tr><tr><td>珠峰大本营</td><td></td><td>5200</td></tr><tr><td>那根拉山口</td><td></td><td>5190</td></tr><tr><td>圣象天门</td><td></td><td>4800</td></tr><tr><td>日喀则</td><td></td><td>3836</td></tr><tr><td>羊卓雍措</td><td></td><td>湖面海拔4441米</td></tr></tbody></table><h3 id="风俗特点"><a href="#风俗特点" class="headerlink" title="风俗特点"></a>风俗特点</h3><p>TODO</p><h2 id="速查表"><a href="#速查表" class="headerlink" title="速查表"></a>速查表</h2><h3 id="关键交通（速查）"><a href="#关键交通（速查）" class="headerlink" title="关键交通（速查）"></a>关键交通（速查）</h3><table><thead><tr><th>地点</th><th>交通设施</th><th>关键距离</th></tr></thead><tbody><tr><td>—</td><td>—</td><td>—</td></tr></tbody></table><h3 id="气温衣物对照表（速查）"><a href="#气温衣物对照表（速查）" class="headerlink" title="气温衣物对照表（速查）"></a>气温衣物对照表（速查）</h3><table><thead><tr><th>天气</th><th>气温℃</th><th>穿衣建议</th></tr></thead><tbody><tr><td>酷热，很不舒适</td><td>≥40</td><td>停止户外作业，对老弱病幼人群采取保护措施</td></tr><tr><td>暑热，不舒适</td><td>≥37</td><td>避免在高稳时段进行户外活动，老弱病幼落实防暑降温保护措施。</td></tr><tr><td>闷热，不舒适</td><td>≥35</td><td>天气闷热，适宜着丝麻、轻棉织物制作的短衣、短裙、薄短裙、短裤等夏季服装。午后尽量减少户外活动，高温条件下作业和露天作业人员采取必要防护措施。</td></tr><tr><td>炎热，不舒适</td><td>33~34.9</td><td>天气炎热，适宜着短衫、短裙、短裤、薄型T恤衫、敞领短袖棉衫等夏季服装。</td></tr><tr><td>热，较不舒适</td><td>28~32.9</td><td>天气较热，适宜着棉麻面料的衬衫、薄长裙、薄T恤等夏季服装。年老体弱者：长袖衬衫和单裤。</td></tr><tr><td>热舒适</td><td>25~27.9</td><td>天气偏热，适宜着短衫、短裙、短套装、T恤等夏季服装。年老体弱者：单层薄衫裤、薄型棉衫。</td></tr><tr><td>较舒适</td><td>23~24.9</td><td>天气暖和，适宜着单层棉麻面料的短套装、T恤衫、薄牛仔衫裤、休闲服、职业套装等春秋过渡装。年老体弱者请适当增减衣服。</td></tr><tr><td>舒适</td><td>21~22.9</td><td>天气温暖，适宜着长袖衬衫加单裤、单层薄衫裤、薄型棉衫等春秋过渡装；年老体弱者：针织长袖衬衫＋背心、长裤、薄型套装。</td></tr><tr><td>凉舒适</td><td>18~20.9</td><td>天气温和，适宜着 单层薄衫裤、薄型棉衫、长裤、针织长袖衫、长袖 T 恤、薄型套装、牛仔衫裤、西服套装、薄型夹克等春秋过渡装；年老体弱者宜着针织长袖衬衫 + 马甲、长裤、夹克衫、西服套装等。</td></tr><tr><td>温凉，较舒适</td><td>15.0~17.9</td><td>天气温凉，适宜着夹衣、马甲衬衫、长裤、夹克衫、西服套装加薄羊毛衫等春秋服装。年老体弱者：夹衣或风衣加羊毛衫。</td></tr><tr><td>微凉</td><td>13~14.9</td><td>天气微凉，适宜着一件羊毛衫、夹克衫、西服套装、马甲衬衫＋夹克衫配长裤等春秋着装；年老体弱者：厚外套加毛衣、呢外套加羊毛衫。</td></tr><tr><td>较凉</td><td>11~12.9</td><td>天气较凉，适宜着厚外套加毛衣、大衣、毛套装、西服套装等春秋服装。体弱者宜着大衣、毛衣加呢外套等厚型春秋服装。</td></tr><tr><td>凉</td><td>8~10.9</td><td>天气凉，适宜着一到两件羊毛衫、大衣、毛套装、皮夹克等春秋着装；年老体弱者宜着大衣、夹衣或风衣加羊毛衫等厚型春秋着装。</td></tr><tr><td>微冷</td><td>5~7.9</td><td>天气微冷，适宜着毛衣、风衣、大衣、皮夹克、外套、毛套装、西装、防寒服等厚型春秋着装；老年体弱者，冬季着装：一到两件羊毛衫＋大衣或毛套装、薄棉外套等。</td></tr><tr><td>较冷</td><td>0~4.9</td><td>天气微冷，适宜着毛衣、风衣、大衣、皮夹克、外套、毛套装、西装、防寒服等厚型春秋着装；老年体弱者，冬季着装：一到两件羊毛衫＋大衣或毛套装、薄棉外套等。</td></tr><tr><td>冷</td><td>-4.9~0</td><td>天气冷，冬季着装：棉衣、羽绒衣、冬大衣、皮夹克、毛衣再外罩大衣等；年老体弱者尤其要注意保暖防冻。</td></tr><tr><td>寒冷(风力≤4)</td><td>-9.9~-5</td><td>天气寒冷，冬季着装：棉衣、羽绒服、冬大衣、皮夹克加羊毛衫、厚呢外套、呢帽、手套等；年老体弱者尽量少外出。</td></tr><tr><td>很冷（风力≥4）</td><td>-9.9~-5</td><td>温度极低，尽量少外出；建议着厚棉衣、厚羽绒服、冬大衣、皮夹克、裘皮大衣、棉（皮）帽、棉（皮）手套、棉（皮）靴等隆冬着装。</td></tr><tr><td>极冷</td><td>≤-10</td><td>温度极低，尽量少外出；建议着厚棉衣、厚羽绒服、冬大衣、皮夹克、裘皮大衣、棉（皮）帽、棉（皮）手套、棉（皮）靴等隆冬着装。</td></tr></tbody></table><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://zhuanlan.zhihu.com/p/46142152">西藏旅游攻略——第一步准备篇 - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/25852991">最详细的西藏旅游攻略！（仅供参考） - 知乎 (zhihu.com)</a></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;模板的好处就在于可以让你快速且全面的规划方案，一些你能想到和不能想到的地方。既能避免你在做旅游规划时漏掉什么，又能节省你思考的时间。有了模板你只需要按照大纲去调研即可。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果你旅游前需要详细规划，那么这个模板很适合你。&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;如果你是想走开车就走的那种，可以跳过这篇。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;模板按需填充即可，比如去西藏就需要特别关注海拔信息。去三亚就需要关注一下日出日落和潮汐时间。下面是我在做西藏旅游攻略做的一个简单攻略，仅供参考。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="效率" scheme="https://noogel.xyz/tags/%E6%95%88%E7%8E%87/"/>
    
    <category term="游记" scheme="https://noogel.xyz/tags/%E6%B8%B8%E8%AE%B0/"/>
    
  </entry>
  
</feed>
